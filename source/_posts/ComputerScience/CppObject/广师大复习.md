---
title: 广西师范大学复试常见提问
date: 2022.2.27 10:00
sticky: true
categories:
  - 计算机
tag: 
  - 复试
  - 计算机
  - 考研
valine: 
  placeholder: "1. 提问前请先仔细阅读本文档⚡\n2. 页面显示问题💥，请提供控制台截图📸或者您的测试网址\n3. 其他任何报错💣，请提供详细描述和截图📸，祝食用愉快💪"
---







# C++复试常问问题

## *1. C和C++区别

首先，结构不同，C语言结构只有成员变量，没有成员方法，而C++结构中可以有自己的成员变量和成员函数;

其次，设计不同，C语言进行过程化、抽象化的通用程序设计，C++既可以进行C语言的过程化程序设计，又可以进行以抽象数据类型为特点的基于对象的程序设计，还可以进行继承和多态为特点的面向对象的程序设计；

最后，函数库不同，C语言的标准函数库，他们是松散的，只有把功能相同的函数放在一个头文件中，而C++对于大多数的库函数都有很紧密的集成，是一个集体。

## *2. 封装、继承、多态

封装就是把属性和方法等集合在一个个类中，仅仅只提供公共接口给外界访问，这样就隔离了实现细节，提高了代码的安全性和复用性；可以避免代码被破坏。

继承就是使用已存在的类（即父类）作为基础，建立新类（即子类）的技术，子类可以增加新的属性或新的方法，又可以使用父类的非私有成员。使用类继承时，首先，子类拥有父类的非private的属性和方法，其次，子类可有拥有自己的属性和方法，即子类可以对父类进行扩展，最后，子类可以用自己的方法实现父类的方法。继承可以实现代码的重用，节省开发时间。

多态，简单来说就是，“一个接口，多中方法”，即用的是同一个接口，但是结果各不相同。如，函数重载、基于虚函数的多态等，多态的意义在于用于操作不同作用的对象，可以有不同的解释，产生不同的结果。多态又可以分为静态多态性，例如，函数重载，在程序运行之前，即程序编译的时候就确定了所执行的函数，动态多态性，例如，虚函数，不在编译时确定调用的是哪个对象，而是在程序运行过程中才能动态的确定操作所针对的对象。

## *3. static

静态变量就是在程序执行之前系统为之分配静态存储空间的变量，存放在静态变量区

静态又可以分为全局静态变量，局部静态变量，静态函数，类的静态成员变量，类的静态函数。全局静态变量作用于文件定义出到文件结尾，其他文件不可见，存在于整个程序运行期间；局部静态变量作用于局部作用区域，不会被销毁，函数再次调用时值不会被初始化，存在于整个程序运行期间；静态函数只有本文本可以是使用，不会同其他文件同名函数冲突；类的静态成员变量，作用于类的所有对象共享的变量；类的静态成员函数，作用于类的所有对象共享的函数；静态成员变量和静态成员函数在类外初始化；其中需要注意的是，全局变量存放在静态变量区，局部变量存放在堆栈区。

## 4. 指针和引用的比较

首先，指针有自己的空间，而引用只是一个别名；第二，指针可以初始化为NULL,而引用初始化时需要一个对象；第三，指针可以有多级指针，而引用只有一级，即没有引用的引用；第四，指针可以在初始化后，可以重新再指向一个对象，而引用初始化后，就不能再引用其他对象。

## *5. struct和class的区别（C++）

struct和class的共同点是,struct和class都可以定义成员和函数，都有继承和多态。而两者的不同点是，第一，class默认权限是private，struct的默认权限是public，第二，class可以声明类模板，而struct不可以

## 6. 智能指针

首先，智能指针的作用是管理一个指针，由于申请的空间在函数结束时忘记释放，造成内存泄漏，而使用智能指针可以在很大程度上避免这个问题，因为智能指针就是一个类，超出类的作用域时，类就会自动调用析构函数，析构函数就会自动释放资源。其次，智能指针的作用原理是在函数结束时自动释放内存空间，不需要手动释放内存。

## *7. new和malloc区别

首先，molloc与free成对出现，是C的标准库函数，而new和delete成对出现，是C++的运算符，其次，他们都可以动态的申请内存

## *8. C++内存管理

栈，用于存放函数形参、局部变量，超出作用域自动释放

堆，存放new分配的内存块，需要delete手动释放

自由存储区，存放molloc分配的内存块，需要free手动释放

静态区，存放全局变量，静态变量（包括局部静态变量），静态区的内容在整个程序的生命周期中都存在

常量区，存放const常量，不可以修改

程序代码区，存放二进制代码

## *9. 设计模式

单例

工厂

## 10. 内存泄漏

内存泄露是指向系统申请分配内存使用，但使用完后没有对内存进行释放，从而导致占用有效内存。解决的办法有，良好的编程习惯，用了new，就要记得delete，或者用智能指针避免。

## 11. 野指针

野指针是指向一个已经删除或者没有申请访问受限内存区域的指针。产生野指针的原因有指针没有初始化，指针释放后没有置NULL。解决办法，良好的编程习惯，指针要进行初始化，当指针被释放后要将其置NULL。

## 12. 数组与指针的区别

数组是用于存储多个数据类型相同的数据集合，数组存放在一边连续的存储单元中。指针相当于一个变量，存放的是其他变量的内存地址。

## 13. 在main函数执行前的代码

1. 初始化栈的指针
2. 静态变量或者全局变量的初始化
3. 如果全局变量未初始化，如果是内置类型会执行默认初始化
4. 一些非内置类型，会调用默认构造函数进行初始化
5. mian函数的形参压入栈中
6. 可能还有标准输入输出或错误流的初始化

## 14. 段错误

段错误是指访问的内存超出了系统所给这个程序的内存空间，主要原因，数组越界，解决办法，检查数组大小和数组下标，判断是否越界。

## *15. STL

STL又叫标准模板库，它的三大组件为容器，算法，迭代器。容器由可以分为序列式容器，如，vector,list,stack,queue，关联式容器，如，tree,set,map。算法可以分为查找，排序，计数等。迭代器，提供一种方法，使之能够依序访问某个容器的各个元素，而又无需暴露该容器的内部表示方式。

## 16. C++成员函数后面加const

给隐含的this指针加const，表示this所指向的东西是const的，也就是说这个函数中无法修改数据成员了，相当于只读。

## *17. 编译程序生成可执行文件的四个阶段

预处理：条件编译，头文件包含，宏替换的处理，生成.i文件

编译：将预处理后的文件转换成汇编语言，生成.s文件

汇编: 对.s文件进行汇编，变成目标代码，生成.o文件

链接：链接目标代码，生成可执行文件

## *18. 什么是虚函数/纯虚函数

虚函数，是指被virtual关键字修饰的成员函数，在某基类中声明为 virtual 并在一个或多个派生类中被重新定义的成员函数

纯虚函数是一种特殊的虚函数，在许多情况下，在基类中不能对虚函数给出有意义的实现，而把它声明为纯虚函数，它的实现留给该基类的派生类去做。纯虚函数的作用。纯虚函数也可以叫抽象函数，一般来说它只有函数名、参数和返回值类型，不需要函数体。这意味着它没有函数的实现，需要让派生类去实现。C++中的纯虚函数，一般在函数签名后使用=0作为此类函数的标志。

## *19. 结构体与联合体的区别

1. struct和union都是由多个不同的数据类型成员组成, 但在任何同一时刻, union中只存放了一个被选中的成员, 而struct的所有成员都存在。在struct中，各成员都占有自己的内存空间，它们是同时存在的。一个struct变量的总长度等于所有成员长度之和。在Union中，所有成员不能同时占用它的内存空间，它们不能同时存在。Union变量的长度等于最长的成员的长度。

2. 对于union的不同成员赋值, 将会对其它成员重写, 原来成员的值就不存在了, 而对于struct的不同成员赋值是互不影响的。

## *20. const和#define的区别

编译器处理方式不同，define定义的数据在预处理阶段中进行替换，const定义的变量在编译时确定其值；

类型检查不同，define定义的数据是无类型，不进行安全检查，可能会产生意想不到的错误，const定义的变量是有数据类型，编译时会进行类型检查。

内存空间不同，define定义的数据不进行内存分配，给出的是立即数，const定义的变量存放在常量区，不可修改。

## 21. sizeof和strlen的区别

sizeof是操作符，参数为任意类型，他的作用是计算类型所占内存的大小。

strlen是C标准函数库中的一个函数，参数为char*（c字符串类型），主要用于计算字符串的长度。

## 22. 派生类中构造函数，析构函数调用顺序？

在派生类中，先调用基类的构造函数，然后调用派生类的构造函数，其次调用派生类的析构函数，最后调用基类的析构函数。

## *23. 内联函数

内联函数，在编译期间将所调用函数的代码直接嵌入到主调函数中，而不是将流程转出。使用内联函数可以节省运行时间，但是会增加目标程序的长度。只有那些规模小而又被频繁调用的简单函数，才适合声明为inline函数。

## 24. 一个C++的程序由哪几个部分构成？其中的每一个部分起什么作用？

预处理，头文件#include、自定义#define、编译开关#program

全局声明，类、结构体、全局变量等声明

函数体：主程序和被调函数

## 25. C++为什么要规定对所有的变量要“先定义，后使用”

因为如果变量不先进行定义，编译器就不知道变量的类型，系统就没有办法给变量分配存储空间，所以就会出错。

## 26. 函数重载

允许用同一个函数名定义多个函数，而这些函数的参数个数和参数类型可以不相同

## 27. 头文件的内容



## 28. 析构函数

## 29. 常数据成员

## *30. 友元friend

## 31. 不能重载的运算符

## 32. ++重载

## *33. 重写&重定义&重载的区别

## 34. 三种传参方式

## *35.面向对象和面向过程

## 36. C++在什么情况下使用运算符重载

## 37.函数模板、模板实例化

## 38. C/C++分别如何处理调度次数高的函数

## 39. 什么是面向对象

面向对象是一种思想，是基于面向过程而言的，就是说面向对象是将功能通过对象来实现，将功能封装到对象中，让对象去实现具体的细节，面向对象的三大特征：封装，继承，多态。



