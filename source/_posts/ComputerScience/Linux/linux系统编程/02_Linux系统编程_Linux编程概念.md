## 文件和文件系统

▶<font color=red>文件是Linux中最基本和重要的抽象。</font>Linux遵循一切皆是文件的理念（虽然并不是像某些其他系统那么严格，如Plan9)。因此，很多的交互工作是通过读取和写入文件来完成，就算问题的目标并不是你日常所想的文件。

▶文件必须被打开才能被访问。文件可以**以只读方式或者只写方式打开，或者两者兼有。**一个打开的文件通过<font style="background:yellow">唯一的文件描述符</font>[^1]进行引用，该描述符是打开文件的<font style="background:yellow">元数据</font>[^2]至其本身的映射。在Linux内核中，这个描述符称为文件描述符，用一个整数表示（C语言中的类型为int),简写为fd。文件描述符在用户空间中共享，允许用户程序用文件描述符直接访问文件。大部分的Linux系统编程包括对文件描述符的打开，关闭等操作。

## 普通文件



​		我们常常说起的文件，就是Linux中的普通文件。一个普通文件包含以线性字节数组方式组织的数据，通常也称为==字节流==[^3]。在Linux中，文件没有更进一步的组织结构或者格式。字节可以是任何值，也可以以任何方式被组织在一个文件中，在系统级别，除了字节流，Linux并没有要求文件有特定的结构。

​		文件中的任何字节都可以被读或者写，这些操作开始于特定的字节，也就是文件中所谓的“地址”的概念。**这个地址就是文件位置或者文件偏移量**。这个文件位置是内核与每一个打开的文件关联的元数据非常重要的一部分。当文件首次打开时，位置为0。通常，随着对文件的读写操作（按字节进行）,文件的位置也随之增长。文件的位置也可以通过手工指定一个值，就算这个值超过了文件的结尾。**在超过文件结尾之后写入字节将会导致中间的字节填充为0**。尽管可以通过这样的方式在文件的末尾写入字节，但是却**不允许在文件的头部之前写入字节。**这种情况听上去很荒缪，实际上也没多大用处。文件位置起始于0,它不可能是负数。在文件中间写入字节将覆盖**位置偏移量**上的值。因此，通过在中间写入内容来扩展文件是不可行的，大部分文件写操作发生在文件的结尾，**文件位置的最大值只受存储该值的C语言类型的大小所限制**，在最新的版本的Linux上是64位。

​		==文件的大小==[^4]通过**字节来计算**，称为文件长度。文件长度，就是组成文件的线性数组里字节的数目。**文件的长度可以通过截断（truncation)来改变**。一个文件可以通过删除文件结尾部分而截短为稍小的文件。令人困惑的是，根据截断操作这个名字，**一个文件可以被截断成比原来更大的文件**，**在这种情况，文件以“0”进行填充（在文件的末尾）**。文件可以为空（长度为0),不包含任何可用字节。文件最大值，如同文件位置的最大值，受限于Linux内可用于管理文件的C语言类型的大小。然而，某些特定的文件系统，也可能强加自己的限制，将最大值限定在更小的值。

​		**同一个文件能被不同或者相同的进程多次打开**，**系统为每一个打开文件的实例提供唯一的文件描述符**。**<u>进程能够共享文件描述符，从而允许同一描述符被多个进程使用。</u>**内核并没有对并发文件访问强加任何限制，**不同的进程能够同时对同一个文件进行读写。<u>并发访问的结果取决于独立操作的顺序，且通常是不可预测的。用户空间程序必须调整他们自己的顺序以保证并发文件访问可以同步</u>。**

​		文件通过文件名进行访问，但事实上，对于文件本身并不与文件名称直接关联。相反，**文件通过`inode`(信息节点）来访问**，**`inode`使用唯一的数值进行标志。**该值称为**`inode`编号**（`inode number`),通常简写为`i-number`或者`ino`。**一个`inode`存储文件关联的元数据**，如它的修改时间截、所有者、类型、长度以及文件的数据的地址，唯独没有文件名。**`inode`既是Unix文件系统在磁盘上实际物理对象，也是Linux内核中的数据结构的概念实体。**

## 目录和链接



通过`inode`编号来访问文件显然是一个不明智的决定（也是一个潜在的安全漏洞）。因此，人们经常使用文件名来访问文件。目录就是用来提供访问文件时所需的名字的，目录将易读的名字和`inode`编号进行映射。名字与`inode`的配对，称为==链接（link)==[^5]。映射在物理磁盘上的形式，可以是一个简单的表格、一个哈希表或者其他任何形式，映射由内核代码针对 某一特定的文件系统 实现和管理。从概念上讲，**<u>一个目录可以被视为任何普通的文件，唯一的不同点是它仅仅存储名字和inode的映射</u>**。**内核直接使用这个映射将文件名解析为`inode`。**

最初，磁盘上只有根目录，这个目录通常标记为/。但我们所知道的是，系统上有很多目录。那么内核怎么知道该到哪一个目录查找给定的文件名呢？

如同之前所述，目录和普通文件相似，事实上，他们甚至也有关联的`inode`。因此，**目录内的链接能够指向别的目录的`inode`**。这也意味着目录可以嵌套到别的目录中，形成目录层次。这样就允许所有Unix用户都能够用熟悉的路径名来查找文件，如/home/blackbeard/landscaping.txt.

当内核打开类似的路径名时，它通过遍历**路径上的每一个==目录项==**[^6]**来查找下一项的`inode`**。在前面的例子中，内核从`/`开始，获取home的`inode`,跳转到那，然后获取`blackbeard`的`inode`,再进入该项，最终找到landscaping.txt的`inode`。这个操作过程称为目录或者文本的==路径解析==[^7]。内核也使用缓存（称为dentry cache)来存储目录解析的结构，提供==时间局部性==[^8]支持，加快查询速度。时间局部性支持，我们将在后续章节讨论。

<u>一个从根目录开始的路径名称</u>为**完全指定**（fully qualified)的，也叫做绝对路径。一些路径并不是完全指定的，相反，他们只是相对于其他目录（例如：todo/plunder)。这些路径称为相对路径。当遇到相对路径时，内核在当前的工作目录下进行路径解析。从当前工作目录开始，内核首先查找目录todo,从那里内核获取plunder的inode。

虽然目录可以看成是普通的文件，但是**内核不允许像操作普通文件一样打开和操作它们。**相反，他们必须通过几个特殊的系统调用来操作它们，不管在什么情况下，这些调用仅允许进行两个操作：**添加链接和删除链接**。如果允许用户空间绕过内核的管理而进行目录操作，那么一个非常简单的错误都可能导致文件系统崩溃。

## 硬链接

从概念上看，到目前为止还没有任何内容涉及防止多个名字解析到同一个`inode`上。事实上，这样做是可以的。我们**把将不同名字映射到同一个`inode`信息节点的多个链接称为硬链接。**

在复杂的文件系统结构中，**硬链接允许多个路径名指向相同的数据**。硬链接可以在同一个目录下，也可以在不同的目录中，无论在哪种情况下，内核完全可以将路径名解析到正确的信息节点上。例如，/home/bluebeard/map.txt和/home/blackbeard/treasure.txt都可以硬链接到指定的`inode`上。

删除目录结构中的一个文件将会引发一个**unlink操作**，该操作将**文件名和`inode`的映射信息从目录中移除**。然而，因为Linux支持硬链接，文件系统不能在每一次unlink操作都移除`inode`以及和它关联的数据。如果在文件系统别的地方存在另一个硬链接怎么办？为了保证每个文件在所有的链接都移除后才彻底删除文件，每个`inode`还包含一个**链接计数**（link count)来跟踪文件系统中指向该文件的硬链接数目。**当路径名解除链接，链接计数将减1**。**当它为0的时候，`inode`和它关联的数据才正真的从文件系统中删除。**

## 符号链接

因为`inode`编号在自己文件系统之外没有任何意义，所以不能跨文件系统建立链接。为了允许跨越文件系统建立链接，Unix系统还实现了符号链接（通常
简称为`symlinks`)。

**符号链接**看上去像**普通文件**，每个`symlink`都有自己的**`inode`**和**包含被链接**
**文件完整路径名的数据块**。这意味着符号链接可以指向任何地方，包括不同文
件系统上的文件和目录，甚至不存在的文件和目录。指向不存在文件的符号链
接称为**坏链接**。

相比硬链接，符号接连解析需要更多开销。因为**有效的解析符号链接需要解析两个文件**：**符号链接**和**被链接的文件**。硬链接不需要额外的开销，因为一次或多次进入文件系统访问被链接的文件并没有任何区别。尽管符号链接的解析的开销不大，但仍然被认为是消极的。

相比硬链接，符号链接缺少一定的透明性。使用硬链接是完全透明的，实
际操作中，它需要找出被链接文件是否被多次链接。而操作符号链接需要特殊
的系统调用。符号链接作为一种文件访问的快捷方式而不是文件系统内部链接
时，这种透明性的缺乏也具有一定的积极意义。

## 特殊文件

特殊文件是以文件方式表示的内核对象。一直以来，Unix系统支持了一些不同的特殊文件，Linux支持四种类型的特殊文件：**块设备文件**、**字符设备文件**、**命名管道**和**Unix域套接字**。特殊文件是将某些抽象融入文件系统的一种方法，是一切皆文件理念的实践。Linux提供了创建特殊文件的系统调用。

对Unix系统的设备进行访问通过设备文件来实现，**设备文件的表现和特征**与**文件系统中的普通文件一样**。<u>设备文件可以被打开、读取和写入，以此允许用户空间程序访问和操作系统上的（物理和虚拟的）设备</u>。Unix的设备通常分为两类：**字符设备**和**块设备**。每种设备类型都有自己的专用设备文件。

**访问字符设备**如同**访问==字节线性队列==**。设备驱动程序将字节按序写入队列，用户空间程序则按照字节被写入队列的顺序进行读取。键盘就是典型的字符设备。如果你敲入”peg”，应用程序将从键盘设备中读取p,然后是e,最后是g。当没有更多的字符需要读取时，设备返回end-of-file(EOF)。漏读数据或者以任何其他的顺序读取都没有意义。字符设备通过**字符设备文件**（character device file)进行访问。

相比之下，**块设备**则不同，它以**==字节数组==的方式进行访问**。设备驱动将字节映射到可寻址的设备上，用户空间可以自由的以任何顺序访问数组中的任何字节，你可以读取字节12,字节7然后再读字节12。**块设备通常是存储设备**，硬盘、软盘、CD-ROM驱动器和闪存都是典型的块设备，它们通过块设备文件（block device files)进行访问。

**命名管道**（通常叫FIFOs,是“先进先出”的简称）是**一种==以文件描述符为信道==的进程间通信（IPC)机制**，通过一种特殊文件进行访问。普通管道是将一个程序的输出以“管道”的方式传送给另一个程序，并做为该程序的输入。它们通过系统调用在内存中创建而不在任何文件系统中存在。命名管道和普通管道一样，但是通过文件进行访问。称为FIFO特殊文件，不相关的进程也可以访问这个文件而进行交互。套接字是最后一种类型的特殊文件。

**套接字**是进程间通信中的高级形式，它允许不同进程进行通信，不仅仅是同一台机器，不同机器也可以。事实上，套接字是网络和因特网编程的基础。它们演化出多个变种，包括Unix域套接字，这是本地机器进行交互的套接字格式。相比网络上的套接字交互需要通过主机名和端口对来确定交互的目标，Unix域套接字使用文件系统上的特殊文件进行交互，该文件称为套接字文件。

## 文件系统和名字空间

Linux提供了一个全局统一的文件和目录的名字空间，不会像windows操作系统上对磁盘进行分区，从而产生不同的名字空间。

文件系统是**以合法层次结构组织的文件和目录的集合**。文件系统能从全局的文件和目录的名字空间独立的添加和移除。这些操作称为挂载（mounting)和卸载（unmounting)。每个文件系统都要挂载在名字空间中特定的位置，这个位置称为挂载点。文件系统的根目录可以通过挂载点访问。例如，挂载CD到/media/cdrom，然后就可以通过访问挂载点来访问CD上的文件系统的根目录。第一个被挂载的文件系统位于名字空间的根部/,称为根文件系统。Linux系统总有一个根文件系统。除此之外，可在其他的挂载点挂载其他的文件系统。

文件系统一般来讲是存在于物理介质上的（如存在磁盘上）,同时Linux也支持存储在内存上的虚拟文件系统和跨网络的网络文件系统。物理文件系统存在于如CD、软盘、闪存或者硬盘等块存储设备。其中一些设备是可分区的，这意味着他们可以切分成多个独立操作的文件系统。Linux支持大部分的文件系统（包含了大部分用户所希望的文件系统）,例如媒体文件系统（media-specific filesystems)(如ISO9660),网络文件系统（NFS),原生文件系统（ext3),其他Unix系统的文件系统（XFS)以及非Unix文件系统（FAT)。

块设备最小访问地址单元为扇区，扇区是设备的物理单位。扇区一般是2的指数倍，通常为512字节。**块设备无法转移或者访问比扇区更小的数据单元**。**所有的I/O操作都发生在一个或多个扇区上。**

同样，文件系统中**最小的逻辑地址单元是块**，块是文件系统中的抽象而不是对物理介质的抽象，块通常是**2的指数倍与扇区大小的乘积**。**块一般大于扇区的大小，但是必须小于页的大小**（最小可访问的内存管理单元，一个硬件部件）。普通块大小为512B,1KB和4KB。

从历史的角度讲，Unix系统仅有单一共享命名空间，系统上所有的进程和用户都可见。Linux另辟溪径，支持进程独立的名字空间，允许每一个进程拥有一个系统文件和目录层次的唯一视图。默认情况下，子进程继承父进程的名字空间，但是一个进程可以通过选择一系列挂载节点和独立的根目录来创建自己的名字空间。

## 进程

如果说文件是Unix系统最重要的抽象概念，那么进程仅次于文件。进程是执行中的目标代码：活动的、生存的、运行的程序。除了目标代码，进程还包含数据、资源、状态以及虚拟化的计算机。

进程从可执行目标代码开始其生命周期。这些目标代码具有内核能够解析的可执行格式（Linux下最常用的格式是ELF),且可以由机器执行。可执行格式代码包含有元数据，多个代码和数据段。“段”是加载到线性内存块的线性目标代码块。所有片段内的字节将一视同仁，赋予相同的权限，一般也用于同样的目的。

最重要和通用的段莫过于代码段，数据段和bss段。代码段包含可执行代码和只读数据，如常量，经常标记为只读和可执行。数据段包含已初始化的数据，如定义了值的C变量，通常标记为可读写的。bss段包含未初始化的全局数据，因为C标准规定C变量的默认值全为0,因此没有必要在磁盘上的目标代码中保存这些0。相反，目标代码可以简单的列举bss段中未初始化的变量，内核将映射0页面（全0的内存页）到那个加载进内存的段，为了优化性能人们设计了bss段。这个名称带有几分历史痕迹，它是block started by symbol,或者blockstorage segment的缩写。其他ELF中可执行的通用段都是绝对地址段（absolutsection)(包含不可再定位符号）和未定义段（容器）。

一个进程还和由内核仲裁和管理的系统资源关联，进程典型的资源请求和操作只能通过系统调用。资源包括计时器，挂起信号量、打开文件，网络连接，硬件和进程通信。一个进程的资源，进程相关的数据和统计信息都存储在内核中该进程的进程描述符中。

进程是一种虚拟的抽象。Linux内核支持抢占式多任务和虚拟内存，它给进程提供了虚拟处理器和内存的虚拟视图。从进程的视角看，系统完全由该进程控制。也就是说，尽管给定的进程和其他的进程共用调度，但是看起来好像他在独立控制整个系统。系统将无缝透明的重新进行进程调度，将系统的处理器和所有进程共享，而进程不会感到区别。类似的，每一个进程获得一个独立的线性地址空间，就像它独立控制整个系统内存。通过虚拟内存和分页调度，内核允许多个进程共存在系统上，每个进程操作都有自己的地址空间。内核通过现代处理器的硬件支持来管理这种虚拟化，它使得操作系统能够并发管理多个独立的进程。

## 线程

一个进程包含一个或多个执行线程（通常只叫线程）,线程是进程中的活
动单位。线程是一种抽象，它负责执行代码和维护进程的运行状态。

大部分进程只包含一个线程，他们被称为单线程的（single-thread),包含多个线程的进程称为多线程的（multithreaded)。从传统上讲，因为Unix保持简洁、期望加快进程创建时间、保持健壮的进程通信机制，这些都减少了对线程的需求。可以说，Unix程序被单线程化了。

线程包括栈（如同在非线程系统上的进程栈，主要用于存储局部变量）、处理器状态、目标代码的当前位置（通常是处理器的指令指针）。进程剩下的部分由所有线程共享。

Linux内核实现了一个独特的线程视图：他们是偶然共享某些资源的（大多数情况下是一个地址空间）进程。在用户空间，Linux根据POSIX1003.1c实现线程（pthread)。目前Linux线程实现的名称为Native POSIX Threading Li-brary(NPTL)是glibc库的一部分。

## 进程体系

每一个进程都由一个唯一的正整数标识，即进程ID(pid)。第一个进程的pid是1,接下来每一个进程接受一个新的唯一的pid。

在Linux中，进程有一个严格的层次结构，这就是广为人知的进程树。进程树以第一个进程，也就是init进程（一般是init(8)程序）为根。新进程通过fork()系统调用创建。fork()复制了调用进程，而原进程称为父进程，新进程称为子进程。除了第一个进程外，每一个进程都有父进程。如果父进程在先于子进程终止，内核将init进程指定为它的父进程。

如果进程终止，它并不会立即从系统中移除。相反，内核将在内存中保存进程的部分内容，允许父进程查询该进程终止的状态，这被称为终止进程等待。一旦父进程已经确认它的终止的子进程，子进程就完全的删除了。如一个进程已经终止，但父进程尚未获知它的状态，则称为僵尸进程（zombie)。init进程等待其所有的子进程，保证它的子进程不会永久处于僵死状态。

## 用户和组

Linux中通过用户和组进行认证。每个用户和唯一的正整数关联，称为用户ID(uid)。每一个进程与一个用户ID关联，用来识别运行这个进程的用户，一般称为进程的真实 uid(real uid)。在Linux内核中，uid是用户的唯一标识。但用户一般都是通过用户名而不是数字id来指代自己或者其他用户。用户名和他们对应的用户id存储在/etc/passwd中，而库例程将其用户名映射到相应的uid上。

在登陆的过程中，用户向login(1)程序提交用户名和密码。如果提供的用户名和密码都正确，login(1)程序将根据/etc/passwd为用户生成一个登陆shell(loginshell),并将用户id作为进程的uid。子进程继承父进程的uid。

uid 0 是超级用户root的用户id。超级用户拥有做任何事情的特权，例如只有root用户有权限修改进程的uid。因此，login(1)的用户为超级管理员。

除了真实UID(real uid)之外，每个进程有一个有效UID(effective uid),一个保留 uid(saved uid)和文件系统 uid(filesystem uid)。真实UID(real uid)是启动进程的用户，有效UID(effective uid)可以使进程在其他用户的权限下运行，保留uid(saveduid)保存原来的有效UID(effective uid),它的值决定了用户将切换到哪个有效UID(effective uid)中。文件系统uid通常和有效UID(effective uid)相等，用来检测文件系统的访问权限。

每一个用户都归属于一个或者多个组，包括列在/etc/passwd中的基本组（primary group)或登录组（login group),也可能是/etc/group中其他附加组。每一个进程因此也有一个组ID(gid),因此也有真实gid(real gid),有效gid(effective gid),保留gid(saved gid)以及文件系统gid(filesystem gid)。进程和用户登入组关联，和其他附加组没有关系。

一些安全机制只允许进程在满足特定权限时才能进行某些操作。传统的Unix的原则非常简单：uid为0的进程可以访问的资源，其他的进程都不可访问。近来，Linux采用了更有效率的机制来代替传统的安全机制，它取消了简单的二元判断方式，允许内核进行更细粒度的访问控制设置。

## 权限

Linux上的标准文件权限和安全机制与Unix一致。

每一个文件都有一个所有者，所属组以及权限位集。这些位描述了所有者、所属组以及其他人对文件进行读、写和执行的权限。这三类每一个对应三个位，共9位。文件所有者和权限信息存储在文件的inode中。

对于普通文件，权限是很显然的，它们已经清楚表明读文件，写文件和执行文件的权限。虽然特殊文件实际读和写的内容由特殊文件自己确定，但是特殊文件上的读和写权限与普通文件的一样，执行权限在特殊文件上被忽略。目录的读权限是允许目录中的内容被列出，写权限允许在目录中添加新的链接，执行权限允许目录进入和使用该路径。

## 信号

信号是一种单向异步通知机制，信号可能是从内核发送到进程，也可能是从进程到进程，或者进程给自己。信号一般用于通知进程发生某些事件，如段错误或者用户输入Ctrl+C。

Linux内核实现了大约30个信号（实际的数字由架构决定）,每一个信号由一个数字常量和文本名表示。例如，SIGHUP用于表示终端挂起，在i386上的值为1。

除了SIGKILL(进程中断）和SIGSTOP(进程停止）外，进程能够根据接收到的信号进行控制。他们可以使用默认的信号处理操作，可能是中断进程、中断并做内存信息转储（coredump)、停止进程，或者什么也不做，具体的操作取决于信号值。另外，进程可以选择显式的忽略或者处理信号。忽略信号是将信号丢弃，不做处理。处理信号将执行用户编写的信号处理函数，程序将在接收到信号时跳到处理函数，信号处理程序返回后，将把程序控制权回交给原来的程序，在之前中断的指令处继续执行。

## 进程间通讯

允许进程交换信息和通知彼此所发生的事件是操作系统最重要的工作之一。Linux内核实现了传统的Unix的进程间通讯（IPC)机制，包括SystemV和POSIX共同定义和标准化的机制，以及Linux自定义的机制。

Linux支持的进程间通讯机制包括管道，命名管道，信号量，消息队列，共享内存和快速用户空间互斥体（Futexes)。

## 错误处理

不用说，检测和处理错误是极其极其重要的。在系统编程中，错误通常通过函数的返回值表示，并通过特殊的变量ermo来描述。glibc对库函数和系统调用的errno提供透明支持。本书所提及的大量接口都使用这个机制来报告错误。

函数通过特殊的返回值（通常是-1,具体值取决于函数）,来通知调用者所发生的错误。错误值告诉调用函数发生了错误，但是不提供发生错误的原因，ermo变量用于定位错误的原因。

该变量在<errno.h&gt;中定义如下：

extern int errno;

erron的值仅仅在ermo设置函数显示错误后（通常返回-1)短时间有效，否则，任何后续成功执行的函数都可以修改其值。

ermo值可以直接被读写，它是可修改的左值（lvalue)。ermo的值与指定错误的文本信息一一对应。预处理器#define同样将ermo映射到相应的数字值上。如，预处理器定义EACCESS等于1,表示“权限不足”，表格1-2上列举了标准定义和与错误相匹配的文字描述。

| 错误标准定义 |         描述         |
| :----------: | :------------------: |
|    E2BIG     |     参数列表太长     |
|   EACCESS    |       权限不足       |
|    EAGAIN    |         重试         |
|    EBADF     |      文件号错误      |
|    EBUSY     |     设备或资源忙     |
|    ECHILD    |       无子进程       |
|     EDOM     | 数学参数不在函数域内 |
|    EEXIST    |      文件已存在      |
|    EFAULT    |       地址错误       |
|    EFBIG     |       文件太大       |
|    EINTR     |    系统调用被中断    |
|    EINVAL    |       参数无效       |
|     EIO      |       I/O错误        |
|    EISDIR    |        是目录        |
|    EMFILE    |     打开文件太多     |
|    EMLINK    |       太多链接       |
|    ENFILE    |      文件表溢出      |
|    ENODEV    |       无此设备       |
|    ENOENT    |    无此文件或目录    |
|   ENOEXEC    |     执行格式错误     |
|    ENOMEM    |       内存用尽       |
|    ENOSPC    |    设备无剩余空间    |
|   ENOTDIR    |        非目录        |
|    ENOTTY    |  不合理I/O控制操作   |
|    ENXIO     |    无此设备或地址    |
|    EPERM     |      操作不允许      |
|    EPIPE     |       管道损坏       |
|    ERANGE    |     结果范围太大     |
|    EROFS     |     只读文件系统     |
|    ESPIPE    |       非法定位       |
|    ESRCH     |       无此进程       |
|   ETXTBSY    |      文本文件忙      |
|    EXDEV     |    跨文件系统链接    |




















[^1]: 文件描述符是一个用于与进程打开文件时创建的文件列表相关联的描述符，该描述符为大于0的整型数据，用户可以用它来操作文件。
[^2]: 元数据是一个或多个数据的集合，文件描述符对应的文件列表就是一个元数据，它由一个或多个不同的数据组成。
[^3]: 以线性字节数组方式组织的数据
[^4]: 文件的大小就是文件的字节数，即文件的长度
[^5]: 文件中的链接是指inode和文件名的映射
[^6]: directory entry,在内核中称为`dentry`
[^7]: 路径解析是指系统通过用户提供的路径中的目录或文件来解析目录或文件的`inode`从而获取用户指定的文件或目录
[^8]: 时间局部性是指最近最晚访问过的数据可能使用是最频繁的