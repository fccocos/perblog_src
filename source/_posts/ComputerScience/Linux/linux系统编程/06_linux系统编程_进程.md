## 进程和程序

### 进程的初步定义

==进程是一个可执行程序的实例==

### 程序的定义

程序是包含一系列信息的文件，这些信息描述了如何创建一个进程。

### 程序包含的内容

- 二进制文件格式的标志：用于描述可执行文件的元信息，内核用此信息来解释文件中的其他信息。
- 机器语言指令：对程序算法进行编码
- 数据: 程序文件包含的变量初始化和程序使用的字面量值
- 程序入口地址：标识程序开始执行的起始指令位置
- 符号表及重定位表：描述程序中函数和变量的位置和名称。
- 共享库和动态链接信息：列出了程序运行时需要使用到的共享库，以及加载共享库的动态连接器的路径名。
- 其他信息：用于描述如何创建进程

### 进程的定义

==进程是内核定义的抽象的实体，并为该实体分配用于执行程序的各项系统资源==

### 从内核角度看进程

进程是由用户内存空间和一系列内核数据结构组成。

用户内存空间包含了程序代码和代码所要使用的变量。

内核数据结构则用于维护==进程状态信息==

记录在内核数据结构中的信息包括

- 与进程相关的标识符
- 虚拟内存表
- 打开文件的描述符表
- 信号传递及处理的相关信息
- 进程资源使用及限制
- 当前工作目录
- 还有大量的其他信息

### UNIX历史上用过的程序文件格式

1. `a.out` 汇编程序输出
2. `COFF` (Common Object File Frame) 通用对象文件格式
3. `ELF` (Executable Link Frame)  可执行链接文件 （现在在用的格式）

## 进程号和父进程号

每一进程都有一个进程号(`PID`)，进程号是一个正数，用来唯一标识系统中的进程。

获取进程号的系统调用
```c
#include <unistd.h>
pid_t getpid(void ); //Always successfully returns process ID of caller
```

`pid_t`为`int`类型。

一般说，程序与运行的进程号之间没有固定的关系。

在Linux2.4版本之前，在32位系统中，Linux内核限制进程号必须小于等于32767，由内核常量PID_MAX来定义。

在Linux2.6版本之后，虽然其默认上限仍为32767, 但是可以通过`/proc/sys/kernel/pid_max`文件来对其进行调整(其值=最大值+1)。

在Linux2.6版本之后，在32位系统中，`pid_max`的值为32768，但是在64系统中，`pid_max`文件的最大值可以高达$2^{22}$

获取当前进程的父进程的系统调用

```c
#include <unistd.h>
pid_t getppid(void);//Always successfully returns process ID of parent of caller
```

每一个进程的父进程号反应了系统上所有进程间的树状关系。

可以用`ptree(1)`调用来查看系统中的进程"家族树"

如果当前进程的父进程终结，那么当前进程就会成为"孤儿"，`init`进程随即将收养该进程。

## 进程内存布局

## 虚拟内存管理

## 栈和栈帧

## 命令行参数

`argv[0]`的一个实用应用技巧：首先为同一个程序创建多个链接，然后让程序查看`argv[0]`, 并根据调用程序的命令来执行不同任务。

可以通过`/proc/PID/cmdline`文件来读取任意进程的命令行参数，也可以通过`/proc/self/cmdline`文件访问自己的命令行参数。

可以通过全局变量获取程序的名称

```c
#include <errno.h>

#define _GNU_SOURCE
program_invocation_name;//提供用于调用该程序的完整路径名
program_invocation_short_name;//提供路径名的基本名称部分
```

`argv`和`environ`数组,以及这些参数最初指向的字符串，都驻留在进程正之上的一个单一的、连续的内存区域。

此区域可存储的字符上限为ARG_MAX, 此宏在`limits.h`中定义，可以使用`sysconf(_SC_ARG_MAX)`函数来确定该上限值。

## 环境列表

环境是“名称-值”的成对集合，可存储任何信息。列中的名称称为环境变量

新建进程时，会继承父进程的环境副本，只是一种原始的通信方式。

环境提供了将信息从父进程传递到子进程的方法。

由于子进程在创建时才能够获得父进程的环境副本，所以这以信息传递是单向的、一次性的。子进程创建后，父、子进程均可以改变各自的环境变量，且这些变更对对方而言是不可见的。

### 从程序中访问环境

可以使用全局变量`char **environ`来访问环境列表，其用法和`argv`类似

还可以通过声明`main()`函数中的第三个参数来访问环境列表

`int main(int argc, char* argv[], char* envp[])`

该参数的作用域在`main()`函数内，属于局部作用域。（不建议使用该方法访问环境）

`getevn()`函数可以从进程环境中检索单个值。

```c
#include <stdlib.h>
char* getenv(const char* name);//Returns pointer to string,or NULL if no such varible
```

`name`参数应该传入环境变量名

## 执行非局部跳转