## 进程和程序

### 进程的初步定义

==进程是一个可执行程序的实例==

### 程序的定义

程序是包含一系列信息的文件，这些信息描述了如何创建一个进程。

### 程序包含的内容

- 二进制文件格式的标志：用于描述可执行文件的元信息，内核用此信息来解释文件中的其他信息。
- 机器语言指令：对程序算法进行编码
- 数据: 程序文件包含的变量初始化和程序使用的字面量值
- 程序入口地址：标识程序开始执行的起始指令位置
- 符号表及重定位表：描述程序中函数和变量的位置和名称。
- 共享库和动态链接信息：列出了程序运行时需要使用到的共享库，以及加载共享库的动态连接器的路径名。
- 其他信息：用于描述如何创建进程

### 进程的定义

==进程是内核定义的抽象的实体，并为该实体分配用于执行程序的各项系统资源==

### 从内核角度看进程

进程是由用户内存空间和一系列内核数据结构组成。

用户内存空间包含了程序代码和代码所要使用的变量。

内核数据结构则用于维护==进程状态信息==

记录在内核数据结构中的信息包括

- 与进程相关的标识符
- 虚拟内存表
- 打开文件的描述符表
- 信号传递及处理的相关信息
- 进程资源使用及限制
- 当前工作目录
- 还有大量的其他信息

### UNIX历史上用过的程序文件格式

1. `a.out` 汇编程序输出
2. `COFF` (Common Object File Frame) 通用对象文件格式
3. `ELF` (Executable Link Frame)  可执行链接文件 （现在在用的格式）

## 进程号和父进程号

每一进程都有一个进程号(`PID`)，进程号是一个正数，用来唯一标识系统中的进程。

获取进程号的系统调用
```c
#include <unistd.h>
pid_t getpid(void ); //Always successfully returns process ID of caller
```

`pid_t`为`int`类型。

一般说，程序与运行的进程号之间没有固定的关系。

在Linux2.4版本之前，在32位系统中，Linux内核限制进程号必须小于等于32767，由内核常量PID_MAX来定义。

在Linux2.6版本之后，虽然其默认上限仍为32767, 但是可以通过`/proc/sys/kernel/pid_max`文件来对其进行调整(其值=最大值+1)。

在Linux2.6版本之后，在32位系统中，`pid_max`的值为32768，但是在64系统中，`pid_max`文件的最大值可以高达$2^{22}$

获取当前进程的父进程的系统调用

```c
#include <unistd.h>
pid_t getppid(void);//Always successfully returns process ID of parent of caller
```

每一个进程的父进程号反应了系统上所有进程间的树状关系。

可以用`ptree(1)`调用来查看系统中的进程"家族树"

如果当前进程的父进程终结，那么当前进程就会成为"孤儿"，`init`进程随即将收养该进程。

## 进程内存布局

每个进程所分配的内存由很多部分组成，通常称之为“段（segment）”。文本段包含了进程运行的程序机器语言指令。

- ==文本段==具有只读属性，以防止进程通过错误指针意外修改自身指令。因为多个进程可同时运行同一程序，所以又将文本段设为可共享，这样，一份程序代码的拷贝可以映射到所有这些进程的虚拟地址空间中。

- ==初始化数据段==包含显式初始化的全局变量和静态变量。

  当程序加载到内存时，从可执行文件中读取这些变量的值。

- ==未初始化数据段==包含了未进行显式初始化的全局变量和静态变量程序启动之前，系统将本段内所有内存初始化为0。出于历史原因，此段常被称为BSS 段，这源于老版本的汇编语言助记符“block started by symbol”。将经过初始化的全局变量和静态变量与未经初始化的全局变量和静态变量分开存放，其主要原因在于程序在磁盘上存储时，没有必要为未经初始化的变量分配存储空间。相反，可执行文件只需记录未初始化数据段的位置及所需大小，直到运行时再由程序加载器来分配这一空间。
- ==栈（stack）==是一个动态增长和收缩的段，由栈帧（stack frames）组成。系统会为每个当前调用的函数分配一个栈帧。栈帧中存储了函数的局部变量（所谓自动变量）、实参和返回值。
-  ==堆（heap）==是可在运行时（为变量）动态进行内存分配的一块区域。堆顶端称作program break。

对于初始化和未初始化的数据段而言，不太常用、但表述更清晰的称谓分别是用户初始化数据段（user-initialized data segment）和零初始化数据段（zero-initialized data segment）。

例题：请用注释将下列代码中的变量在进程内存各段的位置进行说明

```c
#include <stdio.h>
#include <stdlib.h>

char globBuff[65535];//___(未初始化数据区，属于静态全局区)
int primes[]={1,2,3,4,5};//___(初始化数据区，属静态全局区)
static int square(int x) //___(为square函数分配栈帧)
{
    int result;//___(存放在square函数的栈帧中)
    result = result*result;
    return result;//___(通过传递via寄存器返回值)
}
static void doCal(int vla)//___(为doCaL函数配栈帧)
{
    printf("The quare of %d is %d \n", val. square(val));
    if(val<1000)
    {
        int t;//___(存放在doCal函数的栈帧中)
        t = val*val*val;
           printf("The cube of %d\n",val, t);  
    }
}

int main(int argc, char *argv[]) //___()
{
    static int key = 9973;//___()
    static char mbuf[10240000];//___()
    char *p;//___()
    p=malloc(1024);//___()
    doCalc(key);//___()
    exit(EXIT_SUCCESS);//___()
}

```

在Linux系统可以使用C语言的环境变量提供的3个全集符号(etext, edata, end),可以在程序中使用这些符号来获取相应程序文本段、初始数据段和非初始化数据段结尾处下一个字节的地址。

使用说明：

```c
//使用etext edata end需要用extern来声明
extern char etext,edata,end;
```

各段在x86-32位体系结构中的布局，如下图所示。

![image-20220601112442154](pic\05_linux系统编程_深入探究文件IO\各段在32位体系中的布局.png)

## 虚拟内存管理

### 虚拟内存管理的实现原理

Linux，像多数现代内核一样，采用了虚拟内存管理技术。该技术利用了大多数程序的一个典型特征，即访问局部性（locality of reference），以求高效使用CPU 和RAM（物理内存）资源。大多数程序都展现了两种类型的局部性。

- 空间局部性（Spatial locality）：是指程序倾向于访问在最近访问过的内存地址附近的内存（由于指令是顺序执行的，且有时会按顺序处理数据结构）。

- 时间局部性（Temporal locality）：是指程序倾向于在不久的将来再次访问最近刚访问过的内存地址（由于循环）。

正是由于访问局部性特征，使得程序即便仅有部分地址空间存在于RAM 中，依然可能得以执行。

### 虚拟内存的分页机制

- 虚拟内存的规划之一是==将每个程序使用的内存切割成小型的、固定大小的“页”（page）单元（在x86-32中的页大小位4kB）==。相应地，==将RAM 划分成一系列与虚存页尺寸相同的页帧。==

- 任一时刻，每个程序仅有部分页需要驻留在==物理内存页帧中==。这些页构成了所谓驻留集（resident set）。

- ==程序未使用的页拷贝保存在交换区（swap area）内==——这是磁盘空间中的保留区域，作为计算机RAM 的补充——仅在需要时才会载入物理内存。

- <font color=red>若进程欲访问的页面目前并未驻留在物理内存中，将会发生页面错误（page fault），内核即刻挂起进程的执行，同时从磁盘中将该页面载入内存。</font>

为支持这一组织方式，==内核需要为每个进程维护一张页表（page table）==。该页表描述了==每页在进程虚拟地址空间（virtual address space）中的位置==（可为进程所用的所有虚拟内存页面的集合）。==页表中的每个条目要么指出一个虚拟页面在RAM 中的所在位置，要么表明其当前驻留在磁盘上。==

![image-20220601113802659](pic\05_linux系统编程_深入探究文件IO\虚拟内存概览.png)

在进程虚拟地址空间中，并非所有的地址范围都需要页表条目。通常情况下，由于可能存在大段的虚拟地址空间并未投入使用，故而也无必要为其维护相应的页表条目。==若进程试图访问的地址并无页表条目与之对应，那么进程将收到一个SIGSEGV 信号。==

==由于内核能够为进程分配和释放页（和页表条目），所以进程的有效虚拟地址范围在其生命周期中可以发生变化==。这可能会发生于如下场景。

- 由于栈向下增长超出之前曾达到的位置。

- 当在堆中分配或释放内存时，通过调用brk()、sbrk()或malloc 函数族来提升program break 的位置。

- 当调用shmat()连接System V 共享内存区时，或者当调用shmdt()脱离共享内存区时
- 当调用mmap()创建内存映射时，或者当调用munmap()解除内存映射时

> # 虚拟内存的实现需要硬件中分页内存管理单元（PMMU）的支持。PMMU 把要访问的每个虚拟内存地址转换成相应的物理内存地址，当特定虚拟内存地址所对应的页没有驻留于RAM 中时，将以页面错误通知内核。

### 虚拟内存管理的优点

虚拟内存管理使进程的虚拟地址空间与RAM 物理地址空间隔离开来的优点

- 进程与进程、进程与内核相互隔离，所以一个进程不能读取或修改另一进程或内核的内存。这是因为每个进程的页表条目指向RAM（或交换区）中截然不同的物理页面集合。

- 适当情况下，两个或者更多进程能够共享内存。这是由于内核可以使不同进程的页表条目指向相同的RAM 页。内存共享常发生于如下两种场景。

  - 执行同一程序的多个进程，可共享一份（只读的）程序代码副本。当多个程序执行相同的程序文件（或加载相同的共享库）时，会隐式地实现这一类型的共享

  - 进程可以使用shmget()和mmap()系统调用显式地请求与其他进程共享内存区。这么做是出于进程间通信的目的。

- 便于实现内存保护机制；也就是说，可以对页表条目进行标记，以表示相关页面内容是可读、可写、可执行亦或是这些保护措施的组合。多个进程共享RAM 页面时，允许每个进程对内存采取不同的保护措施。例如，一个进程可能以只读方式访问某页面，而另一进程则以读写方式访问同一页面。

- 程序员和编译器、链接器之类的工具无需关注程序在RAM 中的物理布局。

-  因为需要驻留在内存中的仅是程序的一部分，所以程序的加载和运行都很快。而且，一个进程所占用的内存（即虚拟内存大小）能够超出RAM 容量。
- 由于每个进程使用的RAM 减少了，RAM 中同时可以容纳的进程数量就增多了。这增大了如下事件的概率：在任一时刻，CPU 都可执行至少一个进程，因而往往也会提高CPU 的利用率。

## 栈和栈帧

函数的调用和返回使栈的增长和收缩呈线性。X86-32 体系架构之上的Linux（和多数其他Linux 和UNIX 实现），栈驻留在内存的高端并向下增长（朝堆的方向）。专用寄存器—栈指针（stack pointer），用于跟踪当前栈顶。每次调用函数时，会在栈上新分配一帧，每当函数返回时，再从栈上将此帧移去。

有时，会用用户栈（user stack）来表示此处所讨论的栈，以便与内核栈区分开来。内核栈是每个进程保留在内核内存中的内存区域，在执行系统调用的过程中供（内核）内部函数调用使用。（由于用户栈驻留在不受保护的用户内存中，所以内核无法利用用户栈来达成这一目的。）

每个（用户）栈帧包括如下信息：

- 函数实参和局部变量：由于这些变量都是在调用函数时自动创建的，因此在C 语言中称其为自动变量。函数返回时将自动销毁这些变量（因为栈帧会被释放），这也是自动变量与静态（以及全局）变量主要的语义区别：后者与函数执行无关，且长期存在。

- （函数）调用的链接信息：每个函数都会用到一些CPU 寄存器，比如程序计数器，其指向下一条将要执行的机器语言指令。每当一函数调用另一函数时，会在被调用函数的栈帧中保存这些寄存器的副本，以便函数返回时能为函数调用者将寄存器恢复原状。因为函数能够嵌套调用，所以栈中可能有多个栈帧。（若一函数递归调用自身，则该函数在栈中将有多个栈帧。）

  ![image-20220601145207304](F:\PerBlog\source\_posts\ComputerScience\Linux\linux系统编程\pic\05_linux系统编程_深入探究文件IO\一个进程栈的示例.png)

## 命令行参数：`argc` `argv`

`argv[0]`的一个实用应用技巧：首先为同一个程序创建多个链接，然后让程序查看`argv[0]`, 并根据调用程序的命令来执行不同任务。

可以通过`/proc/PID/cmdline`文件来读取任意进程的命令行参数，也可以通过`/proc/self/cmdline`文件访问自己的命令行参数。

可以通过全局变量获取程序的名称

```c
#include <errno.h>

#define _GNU_SOURCE
program_invocation_name;//提供用于调用该程序的完整路径名
program_invocation_short_name;//提供路径名的基本名称部分
```

`argv`和`environ`数组,以及这些参数最初指向的字符串，都驻留在进程正之上的一个单一的、连续的内存区域。

此区域可存储的字符上限为ARG_MAX, 此宏在`limits.h`中定义，可以使用`sysconf(_SC_ARG_MAX)`函数来确定该上限值。

## 环境列表

环境是“名称-值”的成对集合，可存储任何信息。列中的名称称为环境变量

新建进程时，会继承父进程的环境副本，只是一种原始的通信方式。

环境提供了将信息从父进程传递到子进程的方法。

由于子进程在创建时才能够获得父进程的环境副本，所以这以信息传递是单向的、一次性的。子进程创建后，父、子进程均可以改变各自的环境变量，且这些变更对对方而言是不可见的。

### 从程序中访问环境

可以使用全局变量`char **environ`来访问环境列表，其用法和`argv`类似

还可以通过声明`main()`函数中的第三个参数来访问环境列表

`int main(int argc, char* argv[], char* envp[])`

该参数的作用域在`main()`函数内，属于局部作用域。（不建议使用该方法访问环境）

### 从程序中操作环境的函数

#### `getenv()`函数

- `getevn()`函数可以从进程环境中检索单个值。

```c
#include <stdlib.h>
char* getenv(const char* name);//Returns pointer to string,or NULL if no such varible
```

`name`参数应该传入环境变量名

#### `putenv()`函数

- `putenv()`函数向进程的环境变量中添加一个新的变量，或者修改一个已经存在的环境变量的值

```c
#include <stdlib.h>
char* putenv(const char* string);//Return 0 on success, or nozero on error
```

`string` 是一个字符指针，指向`name=value`形式的字符串

需要注意的是，`putevn`函数中参数`string`设置的环境变量与`environ`变量中某一元素所指向的位置相同，因此`string`参数不能为自动变量。因为定义此变量的函数一旦返回，就有可能会重写这块内存区域。

#### `setenv()`函数

- `setenv()`函数与`putenv()`系统调用类似，但是它不是一个标准的系统调用，它是`glibc`库的一个非标准扩展。

  ```c
  #include <stdlib.h>
  int setenv(const char* name, const char* value, int overwrite);//Return 0 on success, or -1 on error
  ```

  `setenv`函数为环境变量分配一块缓冲区，并将`name`和`value`所指向的值复制到缓冲区中，以此创建一个新的环境变量。需要注意的是，`name`和`value`都不能有`=`字符出现，因为该函数会自动添加。

  `name`参数：为环境变量的名字

  `value`参数：为环境变量的值

  `overwrite`参数：重写标志，如果为0，对于已经存在的环境变量不修改；如果为1，则用参数`value`设置的内容来覆盖已存在环境变量的值。

  `setenv`函数，将环境变量复制到环境列表中。


#### `unsetenv()`函数

- `unsetenv()`函数：从环境变量中删除由`name`标识的环境变量

  ```c
  #include <stdlib.h>
  int unsetenv(const char* name);
  ```

  `name`参数：指向需要删除环境变量名，其中不能包含`=`

#### `clearenv()`函数

`clearenv()`函数用于清空环境列表`environ`变量

## 执行非局部跳转:`setjmp()`和`longjmp()`

`非局部`是指跳转的目标为当前执行函数之外的某个位置。

非局部跳转函数的应用场景：在一个深度嵌套的函数调用中发生了错误，需要放弃当前任务，从多层函数调用中返回，并在较高层级的函数中继续执行。

```c
#include <setjmp.h>
int setjmp(jmp_buf env);//Return 0 on initial call, nozero on return via longjmp()
void longjmp(jmp_buf env, int val);
```

- `setjmp()`调用为后续由 `longjmp()`调用执行的跳转确立了跳转目标。该目标正是程序发起`setjmp()`调用的位置。
- 从编程角度看来，调用`longjmp()`函数后，看起来就和从第二次调用`setjmp()`返回时完全一样。
- 通过查看`setjmp()`返回的整数值，可以区分`setjmp` 调用是初始返回还是第二次“返回”。
- 初始调用返回值为0，后续“伪”返回的返回值为`longjmp()`调用中val 参数所指定的任意值。通过对`val `参数使用不同值，能够区分出程序中跳转至同一目标的不同起跳位置。
- 如果指定`longjmp()`函数的val 参数值为0,则`longjmp()`调用实际会将其替换为1。
- 这两个函数的入参`env `为成功实现跳转提供了黏合剂。`setjmp()`函数把当前进程环境的各种信息保存到`env` 参数中。调用`longjmp()`时必须指定相同的`env `变量，以此来执行“伪”返回。由于对`setjmp()`函数和`longjmp()`函数的调用分别位于不同函数，所以应该将`env `参数定义为全局变量，或者将`env` 作为函数入参来传递，后一种做法较为少见。
- 调用`setjmp()`时，`env `除了存储当前进程的其他信息外，还==保存了程序计数寄存器==（指向当前正在执行的机器语言指令）和==栈指针寄存器==（标记栈顶）的副本。这些信息能够使后续的`longjmp()`调用完成两个关键步骤的操作。
  - 将发起`longjmp()`调用的函数与之前调用`setjmp()`的函数之间的函数栈帧从栈上剥离。有时又将此过程称为“解开栈（unwinding the stack）”，这是通过将栈指针寄存器重置为`env `参数内的保存值来实现的。
  - 重置程序计数寄存器，使程序得以从初始的`setjmp()`调用位置继续执行。同样，此功能是通过`env `参数中的保存值（程序计数寄存器）来实现的。

### 对setjump函数的使用限制

SUSv3 和C99 规定，对setjmp()的调用只能在如下语境中使用。

- 构成选择或迭代语句中（if、switch、while 等）的整个控制表达式。

- 作为一元操作符!（not）的操作对象，其最终表达式构成了选择或迭代语句的整个控制表达式。

- 作为比较操作（==、!=、<等）的一部分，另一操作对象必须是一个整数常量表达式，且其最终表达式构成选择或迭代语句的整个控制表达式。

- 作为独立的函数调用，且没有嵌入到更大的表达式之中。

注意：C 语言赋值语句不在上述列表之列。以下形式的语句是不符合标准的：`s = setjmp(evn);`

之所以规定这些限制，是因为作为常规函数的setjmp()实现无法保证拥有足够信息来保存所有寄存器值和封闭表达式中用到的临时栈位置，以便于在longjmp()调用后此类信息能得以正确恢复。因此，==仅允许在足够简单且无需临时存储的表达式中调用setjmp()==。

### 滥用longjump问题

如果将env 缓冲区定义为全局变量，对所有函数可见（这也是通常用法），那么就可以执行如下操作序列。
1． 调用函数 x()，使用setjmp()调用在全局变量env 中建立一个跳转目标。
2． 从函数 x()中返回。
3． 调用函数 y()，使用env 变量调用longjmp()函数。

这是一个严重错误，因为longjmp()调用不能跳转到一个已经返回的函数中。思考一下，在这种情况下，longjmp()函数会对栈打什么主意—尝试将栈解开，恢复到一个不存在的栈帧位置，这无疑将引起混乱。如果幸运的话，程序会一死（crash）了之。然而，取决于栈的状态，也可能会引起调用与返回间的死循环，而程序好像真地从一个当前并未执行的函数中返回了。（在多线程程序中有与之相类似的滥用，在线程某甲中调用setjmp()函数，却在线程某乙中调用longjmp()。）

### 优化编译器的问题

优化编译器会重组程序的指令执行顺序，并在CPU 寄存器中，而非RAM 中存储某些变量。这种优化一般依赖于反映了程序词法结构的运行时（run-time）控制流程。由于setjmp()和longjmp()的跳转操作需在运行时才能得以确立和执行，并未在程序的词法结构中有所反映，故而编译器在进行优化时也无法将其考虑在内。此外，某些应用程序二进制接口（ABI）实现的语义要求longjmp()函数恢复先前setjmp()调用所保存的CPU 寄存器副本。这意味着longjmp()操作会致使经过优化的变量被赋以错误值。

具备良好移植性的程序应在调用setjmp()的函数中，将指针变量和char、int、float、long 等任何简单类型的所有局部变量都声明为volatile。

将变量声明为volatile，是告诉优化器不要对其进行优化，从而避免了代码重组。

### 尽可能避免使用setjmp()函数和longjmp()函数

如果说goto 语句会使程序难以阅读，那么非局部跳转会让事情的糟糕程度增加一个数量级，因为它能在程序中任意两个函数间传递控制。因此，应当慎用setjmp()函数和longjmp()函数。在设计和编码时花点心思来避免使用这两个函数，这通常是值得的。程序更具可读性，可能会更具可移植性。话虽如此，但在编写信号处理器时，这些函数偶尔还会派上用场—讨论信号时将重新论及这些函数的变体（sigsetjmp()函数和siglongjmp()函数）。