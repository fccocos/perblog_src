## 虚拟文件系统(VFS)

### VFS的概念

**虚拟文件系统**（有时也叫做virtual file switch)是一种Linux内核的<u>文件操作</u>的**抽象机制**。它允许内核在**无需了解文件系统类型**的情况下，**使用文件系统函数**和**操作文件系统数据。**

### VFS实现的原理

VFS实现这种抽象的方法是使用一种**通用文件模型**（common file model),它
是所有Linux文件系统的基础。基于函数指针和==各种面向对象方法==[^1],通用文件
模型提供了一种Linux内核文件系统必须遵循的框架。它允许VFS对文件系统
发起请求。框架提供了钩子来支持读，建立链接，同步以及其他功能。每种文
件系统再使用合适的函数来处理相应操作。**这种方法强制要求文件系统间需要有一定的共性。**举个例子，VFS工作于inode,superblock和目录条目之上。一个非Unix的文件系统可能缺少类Unix的概念如inodes,只不过需要去处理解决。确实如此：Linux可以很好的支持像FAT和NTFS这样的文件系统。

### VFS的优点

- 一个简单的系统调用可以从任意媒介上的任意文件系统统上读；

- 一个简单的工具可以从一个文件系统拷贝到另一个上。

- 所有文件系统都支持同样的概念，同样的接口，和同样的调用。一切都正常工作——而且工作得很好。

### read调用过程

当一个应用发起一个read()系统调用，就开始了一段奇妙的旅程。C库提供了系统调用的定义，而在**调用的时候**转化为适当的==**陷阱态**==[^2]。当一个用户空间进程转入内核态，则转交**系统调用处理器**处理，最终交给**read()系统调用**，**内核**确认文件描述符所对应的对象类型。然后内核调用与相关类型对应的read()函数。对于文件系统而言，这个函数是文件系统代码的一部分。然后该函数继续其工作——举例来说，从文件系统中读取数据并把数据返回给用户空间的read()调用，该调用返回复制数据到用户空间的**系统调用处理器**，然后将数据复制到用户空间，最后read()系统调用返回而进程继续执行。
对系统程序员来说，VFS的影响是很重要的。程序员不需担心文件所在的文件系统或者介质。通用系统调用——read(),write（）,以及其他——能够在意支持的文件系统和介质上操作文件。

[^1]: C语言实现的面向对象方法
[^2]: 陷阱指的是当异常或者中断发生时，处理器捕捉到一个执行线程，并且将控制权转移到操作系统中某一个==固定地址==的机制。它是一种软中断。

