# 内存分配

## 在堆上分配内存

堆：一段长度可变的连续虚拟内存，，始于进程的未初始化数据段末尾，随着内存的分配和释放而增减。

堆的当前内存边界称为 `program break`

### 调整`program break`: `brk`和`sbrk`

改变堆的大小（即分配或释放内存），其实就像命令内核改变进程的program break 位置一样简单。最初，program break 正好位于未初始化数据段末尾之后。

![image-20220616133205981](07_linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B_%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D.assets/image-20220616133205981-16553575345231.png)

在program break 的位置抬升后，程序可以访问新分配区域内的任何内存地址，而==此时物理内存页尚未分配==。内核会在进程==首次==试图访问这些虚拟内存地址时==自动分配新的物理内存页==。

`brk`和`sbrk`系统调用用于操作`program break`

```c
#include <unistd.h>
int brk(void *end_data_segment);// Returns 0 on success, or -1 on error
void *sbrk(intptr_t incrment);// Returns previous program break on success, or (void*) -1 on error
```

系统调用`brk`的说明

- 功能：将`program break`的位置设为参数`end_data_segment`所指定的位置。
  - 如果将`program break`的值设置为比其初始位置（即&end的位置）要低，有可能导致无法预知的行为。
  - `program break `可以设定的精确上限取决于一系列因素，这包括进程中对数据段大小的资源限制，以及内存映射、共享内存段、共享库的位置。
- 参数说明
  - `end_data_segment` 为一个空指针类型。由于虚拟内存以页为单位进行分配，`end_data_segment` 实际会四舍五入到下一个内存页的边界处。

系统调用`sbrk`的说明

- 功能: 将`program break` 在原有地址上增加从参数`increment `传入的大小。
  - 在Linux 中，`sbrk()`是在`brk()`基础上实现的一个==库函数==

- 参数说明
  - `increment`为一个`intptr_t`类型的变量，`intptr_t`是一个整型数据类型。
- 返回值
  - 成功返回一个之前`program break`的地址，即如果`program break`增加，那么返回值是指向新分配内存的起始位置的指针。
  - 失败返回-1并设置errno

### 在堆上分配内存: malloc和free

#### malloc函数

`malloc`函数与`brk`和`sbrk`相比较，所拥有的优点

1. 是C标准的一部分
2. 更易于在多线程中使用
3. 接口简单，允许分配小块内存
4. 允许随意释放内存块，它们被维护于一张空闲内存列表中，在后续内存分配调用时循环使用。

malloc( )函数在堆上分配参数size 字节大小的内存，并返回指向新分配内存起始位置处的指针，其所分配的内存未经初始化。

```c
#include <stdlib.h>

void *malloc(size_t size); // Returns pointer to allocated memory on success,or NULL on error
```

由于malloc()的返回类型为void*，因而可以将其赋给任意类型的C 指针。malloc()返回内存块所采用的字节对齐方式，总是适宜于高效访问任何类型的C 语言数据结构。在大多数硬件架构上，这实际意味着malloc 是基于8 字节或16 字节边界来分配内存的。

> # 在Linux中`malloc(0)`将返回一小块可以用`free`释放的内存

#### `free`函数

free()函数释放`ptr `参数所指向的内存块，该参数应该是之前由`malloc()`，或者其他堆内存分配函数之一所返回的地址。

```c
#include <stdlib.h>
void free(void *ptr);
```

==一般情况下，free()并不降低program break 的位置，而是将这块内存填加到空闲内存列表中，供后续的malloc()函数循环使用==。这么做是出于以下几个原因。

- 被释放的内存块通常会位于堆的中间，而非堆的顶部，因而降低porgram break 是不可能的。
- 它最大限度地减少了程序必须执行的`sbrk()`调用次数。
- 在大多数情况下，降低`program break `的位置不会对那些分配大量内存的程序有多少帮助，因为它们通常倾向于 持有已分配内存 或是 反复释放和重新分配内存，而非释放所有内存后再持续运行一段时间。

如果传给free()的是一个空指针，那么函数将什么都不做。(不会产生错误)

在调用free()后对参数`ptr `的任何使用，例如将其再次传递给free()，将产生错误，并可能导致不可预知的结果。

### malloc和free的实现

#### malloc函数的实现原理

`malloc`函数首先会扫描之前由`free()`所释放的空闲内存块列表，以求找到尺寸大于或等于要求的一块空闲内存。（取决于具体实现，采用的扫描策略会有所不同。例如，first-fit 或best-fito。）如果这一内存块的尺寸正好与要求相当，就把它直接返回给调用者。如果是一块较大的内存，那么将对其进行分割，在将一块大小相当的内存返回给调用者的同时，把较小的那块空闲内存块保留在空闲列表中。

如果在空闲内存列表中根本找不到足够大的空闲内存块，那么`malloc()`会调用`sbrk()`以分配更多的内存。为减少对`sbrk()`的调用次数，`malloc()`并未只是严格按所需字节数来分配内存，而是以更大幅度（以虚拟内存页大小的数倍）来增加`program break`，并将超出部分置于空闲内存列表。

#### free函数的实现原理

当free()将内存块置于空闲列表之上时，是如何知晓内存块大小的？

这是通过一个小技巧来实现的。当malloc()分配内存块时，会额外分配几个字
节来存放记录这块内存大小的整数值。该整数位于内存块的起始处，而实际返回给调用者的内存地址恰好位于这一长度记录字节之后。

![image-20220616143616248](07_linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B_%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D.assets/image-20220616143616248-16553613797243.png)

当将内存块置于空闲内存列表（双向链表）时，free()会使用内存块本身的空间来存放链表指针，将自身添加到列表中。

![image-20220616143812824](07_linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B_%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D.assets/image-20220616143812824.png)

随着对内存不断地释放和重新分配，空闲列表中的空闲内存会和已分配的在用内存混杂在一起。

![image-20220616143944078](07_linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B_%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D.assets/image-20220616143944078-16553615854105.png)

假设经由一个错误指针，程序无意间增加了冠于一块已分配内存的长度值，并随即释放这块内存，`free()`因之会在空闲列表中记录下这块长度失真的内存。随后，`malloc()`也许会重新分配这块内存，从而导致如下场景：程序的两个指针分别指向两块它认为互不相干的已分配内存，但实际上这两块内存却相互重叠。至于其他的出错情况则数不胜数。

要避免这类错误，应该遵守以下规则。

- 分配一块内存后，应当小心谨慎，不要改变这块内存范围外的任何内容。错误的指针运算，或者循环更新内存块内容时出现的“off-by-one”（一字之偏）错误，都有可能导致这一情况。
- 释放同一块已分配内存超过一次是错误的。Linux 上的 glibc 库经常报出分段错误(SIGSEGV 信号）。这是好事，因为它提醒我们犯下了一个编程错误。然而，当两次释放同一块内存时，更常见的后果是导致不可预知的行为。
- 若非经由malloc 函数包中函数所返回的指针，绝不能在调用free()函数时使用。
- 在编写需要长时间运行的程序（例如，shell 或网络守护进程）时，出于各种目的，如果需要反复分配内存，那么应当确保释放所有已使用完毕的内存。如若不然，堆将稳步增长，直至抵达可用虚拟内存的上限，在此之后分配内存的任何尝试都将以失败告终。这种情况被称之为“内存泄漏”。

#### malloc调试工具和库

- `mtrace()`和`muntrace()`函数分别在程序中打开和关闭对内存分配调用进行跟踪的功能。这些函数要与环境变量`MALLOC_TRACE` 搭配使用，该变量定义了写入跟踪信息的文件名。在被调用时，`mtrace()`会检查是否定义了该文件，又是否可以打开文件并写入。如果一切正常，那么会在文件里跟踪和记录所有对`malloc` 函数包中函数的调用。由于生成文件不易于理解，还提供有一个脚本（`mtrace`）用于分析文件，并
  生成易于理解的汇总报告。出于安全原因，设置用户ID 和设置组ID 的程序会忽略对mtrace()的调用。
- `mcheck()`和`mprobe()`函数允许程序对已分配内存块进行一致性检查。例如，当程序试图在已分配内存之外进行写操作时，它们将捕获这个错误。这些函数提供的功能和下述`malloc` 调试库有重叠之处。使用这些函数的程序，必须使用`cc-lmcheck` 选项与`mcheck `库链接。
- `MALLOC_CHECK_`_环境变量（注意结尾处的下划线）提供了类似于`mcheck()`和`mprobe()`函数的功能。（两者之间的一个显著区别在于使用：`MALLOC_CHECK_`无需对程序进行修改和重新编译。）通过为此变量设置不同的整数值，可以控制程序对内存分配错误的响应方式。可能的设置有：0，意即忽略错误；1，意即在标准错误输出（stderr）中打印诊断错误；2，意即调用abort()来终止程序。并非所有的内存分配和释
  放错误都是由MALLOC_CHECK_检测出的，它所发现的只是常见错误。但是，这种技术快速、易用，较之于malloc 调试库具有较低的运行时开销。出于安全原因，设置用户ID 和设置组ID 的程序将忽略MALLOC_CHECK_设置。

#### 控制和监测malloc 函数包

glibc 手册介绍了一系列非标准函数，可用于监测和控制malloc 包中函数的内存分配，其中包括如下几个函数。

- 函数mallopt()能修改各项参数，以控制malloc()所采用的算法。例如，此类参数之一就指定了在调用sbrk()函数进行堆收缩之前，在空闲列表尾部必须保有的可释放内存空间的最小值。另一参数则规定了从堆中分配的内存块大小的上限，超出上限的内存块则使用mmap()系统调用来分配。
- mallinfo()函数返回一个结构，其中包含由malloc()分配内存的各种统计数据。

### 在堆上分配内存的其他办法

#### `calloc`函数

函数calloc()用于给一组相同对象分配内存。

```c
#include <stdlib.h>
void* callocl(size_t numitems, size_t size);// Returns pointer to allocated memory onb success, or NULL on error
```

参数mumitems 指定分配对象的数量，size 指定每个对象的大小。在分配了适当大小的内存块后，calloc()返回指向这块内存起始处的指针（如果无法分配内存，则返回NULL）。

与malloc()不同，calloc()会将已分配的内存初始化为0。

#### `realloc`函数

realloc()函数用来调整（通常是增加）一块内存的大小，而此块内存应是之前由malloc 包中函数所分配的。

```c
#include <stdlib.h>
void *realloc(void *ptr, size_t size);//Returns pointer to allocated memory on success, or NULL on error
```

参数ptr 是指向需要调整大小的内存块的指针。参数size 指定所需调整大小的期望值。如果成功，realloc()返回指向大小调整后内存块的指针。与调用前的指针相比，二者指向的位置可能不同。如果发生错误，realloc()返回NULL，对ptr 指针指向的内存块则原封不动（SUSv3 要求满足这一约定）。

若realloc()增加了已分配内存块的大小，则不会对额外分配的字节进行初始化。

使用calloc()或realloc()分配的内存应使用free()来释放。

通常情况下，当增大已分配内存时，realloc()会试图去合并在空闲列表中紧随其后且大小满足要求的内存块。

- 若原内存块位于堆的顶部，那么realloc()将对堆空间进行扩展。
- 如果这块内存位于堆的中部，且紧邻其后的空闲内存空间大小不足，realloc()会分配一块新内存，并将原有数据复制到新内存块中。

最后这种情况最为常见，还会占用大量CPU资源。一般情况下，应尽量避免调用realloc()。

### 分配对齐的内存

分配对齐内存的目的在于分配内存时，起始地址要与2 的整数
次幂边界对齐，该特征对于某些应用非常有用

#### `memalign()`函数

```c
#include <malloc.h>
void *memalign(size_t boundary, size_t size);
/*Returns pointer to allocated memory on success, or NULL on errors*/
```

函数 `memalign()`分配 size 个字节的内存，起始地址是参数 boundary 的整数倍，而boundary必须是2 的整数次幂。函数返回已分配内存的地址。

#### `posix_memalign()`函数

```c
#include <stdlib.h>
int posix_memalign(void **memptr, size_t alignment, size_t size);// Returns 0 on success, or a positive error number on error
```

函数posix_memalign()与memalign()存在以下两方面的不同。

- 已分配的内存地址通过参数memptr 返回。
-  内存与alignment 参数的整数倍对齐，alignment 必须是`sizeof（void*）`（在大多数硬件架构上是4 或8 个字节）与2 的整数次幂两者间的乘积。

`sizeof(void*)`为计算指针的大小，32位平台4字节，64位平台8字节。

还要注意该函数与众不同的返回值，出错时不是返回−1，而是直接返回一个错误号（即通常在errno 中返回的正整数）。

由memalign()或posix_memalign()分配的内存块应该调用free()来释放。

## 在堆栈上分配内存：`alloca()`

和malloc 函数包中的函数功能一样，`alloca()`也可以动态分配内存，不过不是从堆上分配内存，而是通过增加栈帧的大小从堆栈上分配。根据定义，当前调用函数的栈帧位于堆栈的顶部，故而这种方法是可行的。因此，帧的上方存在扩展空间，只需修改堆栈指针值即可。

![image-20220616133205981](07_linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B_%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D.assets/image-20220616133205981-16553575345231.png)

```c
#include <alloca.h>
void *alloca(size_t size);//Returns pointer to allocated block of memory
```

参数size 指定在堆栈上分配的字节数。函数alloca()将指向已分配内存块的指针作为其返回值。

不需要（实际上也绝不能）调用free()来释放由alloca()分配的内存。同样，也不可能调用realloc()来调整由alloca()分配的内存大小。

若调用alloca()造成堆栈溢出，则程序的行为无法预知，特别是在没有收到一个NULL 返回值通知错误的情况下。（事实上，在此情况下，可能会收到一个SIGSEGV 信号。）

请注意，不能在一个函数的参数列表中调用alloca(), 如果在函数参数列表中使用了，这会使alloca()分配的堆栈空间出现在当前函数参数的空间内（函数参数都位于栈帧内的固定位置）

使用alloca()来分配内存相对于malloc()有一定优势。其中之一是，alloca()分配内存的速度要快于malloc()，因为编译器将alloca()作为内联代码处理，并通过直接调整堆栈指针来实现。此外，alloca()也不需要维护空闲内存块列表。

另一个优点在于，由alloca()分配的内存随栈帧的移除而自动释放，亦即当调用alloca 的函数返回之时。之所以如此，是因为函数返回时所执行的代码会重置栈指针寄存器，使其指向前一帧的末尾（即，假设堆栈向下增长，则指向恰好位于当前栈帧起始处之上的地址）。由于在函数的所有返回路径中都无需确保去释放所有的已分配内存，一些函数的编码也变得简单得多。

在信号处理程序中调用longjmp()或siglongjmp()以执行非局部跳转时，alloca()的作用尤其突出。此时，在“起跳”函数和“落地”函数之间的函数中，如果使用了malloc()来分配内存，要想避免内存泄漏就极其困难，甚至是不可能的。与之相反，alloca()完全可以避免这一问题，因为堆栈是由这些调用展开的，所以已分配的内存会被自动释放。