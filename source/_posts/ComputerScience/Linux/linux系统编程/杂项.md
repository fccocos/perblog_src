## getopt函数详谈

```c
#include <unistd.h>
extern int optind,opterr,optopt;
extern char* optarg;
int getopt(int argc, char* const argv[], const char *optstring);
```

函数getopt0解析给定在参数argc和argv中的命令行参数集合。这两个参数通常是从mainO函数的参数列表中获取。参数optstring指定了函数getopt0应该寻找的命令行选项集合，该参数由一组字符组成，每个字符标识一个选项。SUSv3中规定了getopt()至少应该接受62个字符[a-ZA-Z0-9]作为选项。除了：、？和-这几个对getopt()来说有着特殊意义的字符外，大多数实现还允许其他的字符也作为选项出现。每个选项字符后可以跟一个冒号字符（:),表示这选项带有一个参数。

我们通过连续调用getopt0来解析命令行。每次调用都会返回下一个未处理选项的信息。如果找到了选项，那么代表该选项的字符就作为函数结果返回。如果到达了选项列表的结尾，getopt()就返回-1。如果选项带有参数，getoptO就把全局变量optarg设为指向这个参数。

注意getopt0的函数返回值类型为int。我们必须注意不能把getopt0的返回值赋值给char类型的变量，因为当工作在char型变量是无符号整数的系统上时，char型变量同-1之间的比较操作就不会成功。

每次调用getopt（),全局变量optind都得到更新，其中包含着参数列表argv中未处理的下一个元素的索引。（当把多个选项归组到一个单独的单词中时，getopt()内部会做一些记录工作，以此跟踪该单词，找出下一个待处理的部分。）在首次调用getopt0之前，变量optind会自动设为1。在如下两种情况中我们可能会用到这个变量。

- 如果getopt0返回了-1,表示目前没有更多的选项可解析了，且optind的值比argc要小，那么argv[optind]就表示命令行中下一个非选项单词。

- 如果我们处理多个命令行向量或者重新扫描相同的命令行，那么我们必须手动将
  optind重新设为1。在下列情况中，getopt0函数会返回-1,表示已到达选项列表的结尾。

- 由argc加上argv所代表的列表已到达结尾（即argv[optind]为NULL)。

- argv中下一个未处理的单字不是以选项分隔符打头的（即，argv[optind][0]不是连字符）。

- argv中下一个未处理的单字只由一个单独的连字符组成（即，argv[optind]为-)。有些命令可以理解这种参数，该单字本身代表了特殊的意义，见5.11节中的描述

- argv中下一个未处理的单字由两个连字符（-)组成。在这种情况下，getoptQ会悄悄地读取这两个连字符，并将optind调整为指向双连字符之后的下一个单字。就算命令行中的下一个单字（在双连字符之后）看起来像一个选项（即，以一个连字符开头）这种语法也能让用户指出命令的选项结尾。比如，如果我们想利用grep在文件中查找字符串-k,那么我们可以写成grep--kmyfile。

当getopt()在处理选项列表时，可能会出现两种错误。一种错误是当遇到某个没有指定optstring中的选项时会出现。另一种错误是当某个选项需要一个参数，而参数却未提供时会出现（即，选项出现在命令行的结尾）。有关getopt()是如何处理并上报这些错误的规则如下。

- 默认情况下，getopt0在标准错误输出上打印出一条恰当的错误消息，并将字符？作为函数返回的结果。在这种情况下，全局变量optopt返回出现错误的选项字符（即，未能识别出来的或缺少参数的那个选项）。

- 全局变量opterr可用来禁止显示由getopt0打印出的错误消息。默认情况下，这个变量被设为1。如果我们将它设为0,那么getopt()将不再打印错误消息，而是表现的如同上一条所描述的那样。程序可以通过检查函数返回值是否为？字符来判断是否出错，并打印出用户自定义的错误消息。

- 此外，还有一种方法可以用来禁止显示错误消息。可以在参数optstring中将第一个字符指定为冒号（这么做会重载将opterr设为0的效果）。在这种情况下，错误上报的规则同将opterr设为0时一样，只是此时缺失参数的选项会通过函数返回：来报告。如果需要的话，我们可以根据不同的返回值来区分这两类错误（未识别的选项，以及缺失参数的选项）。

getopt函数使用的完整示例：

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

static void
usageError(const char *progName, char *msg, int opt);

int main(int argc, char *argv[])
{
    char *pstr = NULL; //用于指向有参选项的参数
    int opt;           //用于返回getopt函数的返回结果
    while ((opt = getopt(argc, argv, ":a:b:cde")) != -1)
    {
        printf("opt = %3d (%c); optind = %d; optarg = %s\n",
               opt,
               (unsigned char)opt,
               optind,
               optarg);
        if (opt == '?' || opt == ':')
            printf("optopt = %3d (%c); optind = %d\n",
                   optopt,
                   (unsigned char)optopt,
                   optind);
        switch (opt)
        {
        case 'a':
            printf("there is the option a, who is a option with argument:%s\n", optarg);
            break;
        case 'b':
            printf("there is the option b, who is a option with argument:%s\n", optarg);
            break;

        case 'c':
            printf("there is the option c, who is a option without argument\n");
            break;
        case 'd':
            printf("there is the option d, who is a option without argument\n");
            break;
        case ':':
            usageError(argv[0], "Missing argument", optopt);
        case '?':
            usageError(argv[0], "Unrecognized option", optopt);
        default:
            fprintf(stderr, "Unexpected case in switch()\n");
            break;
        }
    }

    if(opt==-1&&argc==1&&optind==1)
    {
        fprintf(stderr, "there is not any option or argument in your command line, please input some arguments\n");
        fprintf(stderr, "\t Usage:%s [-a arg1] [-b arg2] [-c] [-d] arg3\n", argv[0]);
        exit(EXIT_FAILURE);
    }
    if(optind<argc)
    {
        fprintf(stdout,"there is a non-option argument:%s in command line, or, just one\n", argv[optind]);
        exit(EXIT_SUCCESS);
    }


    exit(EXIT_SUCCESS);
}

static void
usageError(const char *progName, char *msg, int opt)
{
    if (msg != NULL && *msg != '\0')
        fprintf(stderr, "%s (-%c)\n", msg, (unsigned char)opt);
    fprintf(stderr, "\t Usage:%s [-a arg1] [-b arg2] [-c] [-d] arg3\n", progName);

    exit(EXIT_FAILURE);
}
```

运行结果

[![OVe41I.png](https://s1.ax1x.com/2022/05/04/OVe41I.png)](https://imgtu.com/i/OVe41I)