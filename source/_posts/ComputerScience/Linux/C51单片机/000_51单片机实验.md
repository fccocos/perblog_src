# 实验一：LED

## LED的电路图

![image-20220523152009816](.\pic\image-20220523152009816.png)

## 实验题目

1. LED点亮
2. LED闪烁
3. LED流水灯：循环点亮LED

用<<和>>运算符实现走马灯

```c
int main(void)
{
    while(1)
    {
        int i;
        for(i=0;i<8;i++){
            LED_PORT = ~(0x01<<i);
            sleep(100000);
        }
//0111 1111 ~ 1000 0000  >>1 0100 0000 ~ 1011 1111 (~ >>1)        
        for(i=1;i<8;i++){
            LED_PORT = ~LED_PORT;
            LED_PORT = ~(LED_PORT >>1);
            sleep(100000);
        }  
    }
}
```

用库函数`_crol_()`和`_cror_()`实现走马灯，在头文件`#include <intrins.h>`

```c
#include <reg52.h>
#include <intrins.h>
#define LED_PORT P2
typedef unsigned int u16;/*8为操作系统中*/
typedef unsigned char u8;

int main(void)
{
    int i;
    LED_PORT = ~0x01; 
    sleep(100000);
    while (1)
    {
        for (i = 0; i < 7; i++)
        {
            LED_PORT = _crol_(LED_PORT, 1);
            sleep(100000);
        }
        for (i = 0; i < 7; i++)
        {
            LED_PORT = _cror_(LED_PORT, 1);
            sleep(100000);
        }
    }
}

```

## 实验现象

![微信图片_20220523184208](.\pic\微信图片_20220523184208.jpg)

# 实  验二：蜂鸣器实验

## 蜂鸣器简介

蜂鸣器是一种一体化结构的电子讯响器，采用直流电压供电。

蜂鸣器主要分为==压电式蜂鸣器==和==电磁式蜂鸣器==两种类型。

### 压电式蜂鸣器

压电式蜂鸣器主要由==多谐振荡器==[^1]、==压电蜂鸣片==、==阻抗匹配器==及==共鸣箱==、==外壳==等组成。

多谐振荡器由晶体管或集成电路构成，当接通电源后（1.5~15V 直流工
作电压），多谐振荡器起振,输出1.5～5kHZ 的音频信号，阻抗匹配器推动压电
蜂鸣片发声。

#### 无源蜂鸣器和有源蜂鸣器

无源蜂鸣器：是指蜂鸣器内部不含有振荡电路。无源蜂鸣器则需提供一定频率的脉冲信号才能发声，频率大小通常在==1.5-5KHz== 之间。对于无源蜂鸣器，如果<font color=skyblue>改变频率就可以调节蜂鸣器音调，产生各种不同音色、音调的声音。</font><font color=oxff>如果改变输出电平的高低电平占空比，则可以改变蜂鸣器的声音大小。</font>

有源蜂鸣器：蜂鸣器内部自带振荡电路，只需提供电源即可发声

STC89C5xx系列开发板使用的无源蜂鸣器。

### 电磁式蜂鸣器

电磁式蜂鸣器由==振荡器==、==电磁线圈==、==磁铁==、==振动膜片==及==外壳==等组成。

接通电源后，振荡器产生的音频信号电流通过电磁线圈，使电磁线圈产生磁场，振动膜片在电磁线圈和磁铁的相互作用下，周期性地振动发声。

### 压电式蜂鸣器和电磁式蜂鸣器的区别

压电式蜂鸣器发声，需提供一定频率的脉冲信号

电磁式蜂鸣器发声，只需提供电源即可。

## 硬件实现

![image-20220523201853326](.\pic\image-20220523201853326.png)<img src=".\pic\image-20220523201923332.png" alt="image-20220523201923332" style="zoom:80%;" />

### 蜂鸣器的驱动

由于单片机的IO驱动电流不够大，因此不能将蜂鸣器和IO直接连接，所以我们先通过三极管把电流放大后再驱动蜂鸣器。此时，IO口只起控制作用，没有驱动作用。

在STC89C51单片机中，使用ULN2003芯片来驱动。

当P25 输出高电平，BEEP 则输出低电平；当P25 输出低电平，BEEP 则输出高电平，类似一个非门。开发板上使用的是无源蜂鸣器，它需要一定频率的脉冲（高低电平）才会发声，因此需要让P25 脚以一定频率不断输出高低电平信号才能控制蜂鸣器发出声音。



## 实验题目

实现蜂鸣器的发声

```c
sbit BEEP = P2^5;
void sleep(unsigned int seconds); 
void main()
{
    //蜂鸣器要想发出响声，就必须不断的输出高低电平
    //即，控制端P2.5必须输出脉冲
    int i = 2000;
    while( i--)
    {
        BEEP = !BEEP;
        sleep(50);
    }

}
void sleep(unsigned int seconds)
{
    while(seconds--);
}

```

 

[^1]: 多谐振荡器由晶体管或集成电路构成

实验结果：

<audio id="audio" controls="" perload="one">
    <source id="mp3" src="./pic/蜂鸣器实验.mp3">
    <source id="mp3" src="  https://m701.music.126.net/20220523222116/3e80e2d1e58b08f081cf59dd656b6de1/jdyyaac/obj/w5rDlsOJwrLDjj7CmsOj/14096427565/7854/7b14/6110/6a83aac06435d939143701eebe126ed9.m4a">
</audio>

今天的实验到此为止，庆祝一下🎉🎉🎉🎉, 给自己放一首歌犒劳一下自己

<audio id="audio" controls="" perload="two">
    <source id="mp3" src="https://m701.music.126.net/20220523222116/3e80e2d1e58b08f081cf59dd656b6de1/jdyyaac/obj/w5rDlsOJwrLDjj7CmsOj/14096427565/7854/7b14/6110/6a83aac06435d939143701eebe126ed9.m4a">
</audio>

------------------------------

​                             <font size=20>  Day 01 Over</font> 2022.5.23

--------------------------------------

***************************************************************

# 实验三：静态数码管

## 数码管简介

数码管是一种半导体发光器件，其基本单元是==发光二极管==。

### 一位数码管的组成

#### 七段式

由七个发光二极管组成

#### 八段式

由八个发光二极管组成，其中一个是用于表示小数点(DP)

### 共阳极数码管

将所有发光二极管的阳极接到一起形成公共阳极(COM)的数码管，共阳数码管在应用时应将公共极COM 接到+5V，当某一字段发光二极管的阴极为低电平时，相应字段就点亮，当某一字段的阴极为高电平时，相应字段就不亮。

<font color=red>总结：共阳极数码管，阳极COM接+5v，阴极接低电平点亮，阴极接高电平熄灭</font>

### 共阴极数码管

指将所有发光二极管的阴极接到一起形成公共阴极(COM)的数
码管，共阴数码管在应用时应将公共极COM 接到地线GND 上，当某一字段发光
二极管的阳极为高电平时，相应字段就点亮，当某一字段的阳极为低电平时，相
应字段就不亮。

<font color=red>总结：共阴极数码管，阴极COM接地（GND），阳极接高电平点亮，阳极接低电平导通</font>

### 数码管显示原理

#### 数码管原理图

![image-20220524055743489](.\pic\image-20220524055743489.png)

如果使用共阴数码管，需要注意增加单片机IO 口驱动电流，因为共阴数码管是要靠单片机IO 口输出电流来点亮的，但**单片机I/O 口难以输出稳定的、如此大的电流**，所以数码管与单片机连接时**需要加驱动电路**，可以<font color=blue>用上拉电阻的方法</font>或<font color=blue>使用专门的数码管驱动芯片</font>，比如74HC573、74HC245 等，其输出电流较大，电路接口简单。

数码管内部发光二极管点亮时，也需要5mA 以上的电流，而且电流不可过大，否则会烧坏发光二极管。因此不仅要防止数码管电流过大，同时要防止流经数码管的电流集中到单片机时电流不能过大，否则会损坏主芯片。

一般共阳极数码管更为常用，为什么呢？

这是因为数码管的非公共端往往接在IC 芯片的I/O 上，而IC 芯片的驱动能力往往是比较小的，如果采用共阴极数码管，它的驱动端在非公共端， 就有可能受限于IC 芯片输出电流不够而显示昏暗，要外加上拉电阻或者是增加三极管加大驱动能力。但是IC 芯片的灌电流，即输入电流范围比较大。

总结：IC芯片的驱动力弱，不能为共阴极数码管提高足够的驱动力，此外如果外加上拉电阻或增加三极管加大驱动能力，但由于IC芯片的灌电流，不利于电流的方法。

使用共阳极数码管的好处是：将驱动数码管的工作交到公共端（一般接驱动电源），加大驱动电源的功率自然要比加大IC 芯片I/O口的驱动电流简单许多。另一方面，这样也能减轻主芯片的负担。

开发版使用的是共阴极数码管，原理图如下

![image-20220524061728914](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220524061728914.png)

#### 共阴极数码管表

0x3f, 0x06, 0x5b, 0x4f, 0x66, 0x6d,0x7d, 0x07, 0x7f, 0x6f, 0x77, 0x7c,0x39, 0x5e, 0x79, 0x71, 0x00
0         1        2        3       4        5       6        7       8       9       A      B      C       D       E       F    无显示

共阳极数码管表

0xC0, 0xF9, 0xA4, 0xB0, 0x99, 0x92,
0          1        2        3         4       5
0x82, 0xF8, 0x80, 0x90, 0x88, 0x83,
6          7        8        9        A        B
0xC6, 0xA1, 0x86, 0x8E, 0xFF,
C          D       E       F      无显示

### 动态数码管和静态数码管

静态显示的特点是每个数码管的段选必须接一个8 位数据线来保持显示的字形码。当送入一次字形码后，显示字形可一直保持，直到送入新字形码为止。这种方法的优点是占用CPU 时间少，显示便于监测和控制。缺点是硬件电路比较复杂，成本较
高。

动态显示的特点是将所有数码管的段选线并联在一起，由位选线控制是哪一
位数码管有效。选亮数码管采用动态扫描显示。所谓动态扫描显示即轮流向各位
数码管送出字形码和相应的位选，利用发光管的余辉和人眼视觉暂留作用，使人
的感觉好像各位数码管同时都在显示。

## 硬件设计

![image-20220524064500236](.\pic\image-20220524064500236.png)![image-20220524064511298](.\pic\image-20220524064511298.png)

## 软件设计

| 数字 | DP   | g    | f    | e    | d    | c    | b    | a    | 十六进制 |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | -------- |
| 0    | 0    | 0    | 1    | 1    | 1    | 1    | 1    | 1    | 0x3F     |
| 1    | 0    | 0    | 0    | 0    | 0    | 1    | 1    | 0    | 0x06     |
| 2    | 0    | 1    | 0    | 1    | 1    | 0    | 1    | 1    | 0x5B     |
| 3    | 0    | 1    | 0    | 0    | 1    | 1    | 1    | 1    | 0x4F     |
| 4    | 0    | 1    | 1    | 0    | 0    | 1    | 1    | 0    | 0x66     |
| 5    | 0    | 1    | 1    | 0    | 1    | 1    | 0    | 1    | 0x6D     |
| 6    | 0    | 1    | 1    | 1    | 1    | 1    | 0    | 1    | 0x7D     |
| 7    | 0    | 0    | 0    | 0    | 0    | 1    | 1    | 1    | 0x07     |
| 8    | 0    | 1    | 1    | 1    | 1    | 1    | 1    | 1    | 0x7F     |
| 9    | 0    | 1    | 1    | 0    | 1    | 1    | 1    | 1    | 0x6F     |
| A    | 0    | 1    | 1    | 1    | 0    | 1    | 1    | 1    | 0x77     |
| B    | 0    | 1    | 1    | 1    | 1    | 1    | 0    | 0    | 0x7C     |
| C    | 0    | 0    | 1    | 1    | 1    | 0    | 0    | 1    | 0x39     |
| D    | 0    | 1    | 0    | 1    | 1    | 1    | 1    | 0    | 0x5E     |
| E    | 0    | 1    | 1    | 1    | 1    | 0    | 0    | 1    | 0x79     |
| F    | 0    | 1    | 1    | 1    | 0    | 0    | 0    | 1    | 0x71     |
| .    | 1    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0x80     |

### 实验目的

用共阴极数码管，一次显示数字0-F

### 实验代码

```c
#include <reg52.h>

typedef unsigned char u8;
typedef unsigned int u16;

#define SMG_A_DP_PORT P0

//静态数码管的控制端口P0

// 数码管显示数字的字码0-F
u8 gsmg_code[17]={0x3f, 0x06, 0x5b, 0x4f, 0x66, 0x6d,0x7d, 0x07, 0x7f, 0x6f, 0x77, 0x7c,0x39, 0x5e, 0x79, 0x71};

void sleep(u16 timeout)
{
    while(timeout--);
}

int main()
{
    int i;
    while(1)
    {
        for(i=0;i<17; ++i)
        {
            SMG_A_DP_PORT = gsmg_code[i];
            sleep(300000);
            SMG_A_DP_PORT = 0x00;
        }
    }
}
```

## 实验结果

<iframe height=400 width=400 src="./pic/静态数码管实验.mp4"></iframe>



# 实验四：数码管动态显示

## 数码管动态显示原理

利用减少段选线，分开位选线，利用位选线不同时选择通断，改变段选数据来实现。

即，利用人眼的视觉差和二极管的余辉，来同时在不同的数码管上显示不同的数字，也就是第一个点亮和最后一个点亮得数码管得时间差不能大于24ms(人眼在正常情况下只能分辨变化超过24ms间隔的运动)。

### 74H138译码器

74HC138D 是一种三通道输入、八通道输出译码器，主要应用于消费类电子产
品。

#### 主要特性

①采用CMOS工艺

②低功耗

③工作电压：3.0V-5.0V

④封装形式：SOP16

#### 引脚功能定义

![image-20220524141656954](pic\image-20220524141656954.png)

![image-20220524141742781](pic\image-20220524141742781.png)

![image-20220524141827907](pic\image-20220524141827907.png)



### 74H245收发器

74HC245 是一种三态输出、八路信号收发器，主要应用于大屏显示，以及其
它的消费类电子产品中增加驱动。

#### 主要特性

①采用CMOS工艺

②宽电压工作范围：3.0V-5.0V

③双向三态输出

④八线双向收发器

⑤封装形式：SOP20, SOP20-2, TSSOP20, DIP20

#### 管脚功能定义

![image-20220524135922886](.\pic\image-20220524135922886.png)

![image-20220524141020853](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220524141020853.png)

![image-20220524141028834](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220524141028834.png)

## 硬件电路设计

![image-20220524142853696](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220524142853696.png)

通过P2.2, P2.3, P2.4来控制位选线，从而控制显示其中一个数码管。

## 软件设计

```c
/**
 * *********************************************
 * 
 * Type: C51 Single Chip Macrocomputer
 * Name: Dynamical display of Digital tube
 * Chip: STC89C516RD+  74HC128 74HC245
 * PIN: P0.0~P0.7 P2.2 P2.4 P2.5 
 * Author: Gunfire
 * Date: 2022.5.24
 * *********************************************
*/

#include "REG52.H"


#define SEGMENT_OF_LINE_SELECTION P0 //段选线


typedef unsigned char uint8_t;
typedef unsigned int uint16_t;
typedef unsigned long uint32_t;

typedef signed char int8_t;
typedef signed int int16_t;
typedef signed long int32_t;


sbit A0 = P2^2; // low
sbit A1 = P2^3; // minor low
sbit A2 = P2^4; // high

void sleep(uint32_t timeout)
{
    while(timeout--);
}
/*  0     1     2     3     4     5    6     7    8      9     A    b     C    d     E     F    不显示*/
/*0x3f, 0x06, 0x5b, 0x4f, 0x66, 0x6d,0x7d, 0x07, 0x7f, 0x6f, 0x77, 0x7c,0x39, 0x5e, 0x79, 0x71, 0x00*/
void main()
{
    // 1st --> show 0   2nd --> show 1 ... last --> show 7
    // P2.4 --> A2  P2.3 --> A1  P2.2 --> A0    数码管位数     显示数字    P2.7   p2.6   p2.5   p2.4    p2.3  p2.2  p2.1 p2.0  十六进制
    /**                                                                    DP      g      f      e       d     c     b    a      
     *          0            0            0     第0位数码管        0        0      0      1      1       1     1     1     1      0x3f
     *          0            0            1     第1位              1        0                                                     0x06                                               
     *          0            1            0     第2位              2        0                                                     0x5b
     *          0            1            1     第3位              3        0                                                     0x4f
     *          1            0            0     第4位              4        0                                                     0x66
     *          1            0            1     第5位              5        0                                                     0x7d
     *          1            1            0     第6位              6        0                                                     0x07
     *          1            1            1     第7位              7        0                                                     0x7f   
     */ 
    uint8_t smg_code[8]={0x3f, 0x06, 0x5b, 0x4f, 0x66, 0x6d,0x7d, 0x07};


    int i;
    while(1)
    {
        for(i=0;i<8;i++)
        {
            switch(i)
            {
                case 0: 
                    //点亮第0位数码管
                    A2 = 0;  A1 = 0;  A0 = 0;
                    break;
                case 1: 
                    //点亮第1位数码管
                    A2 = 0;  A1 = 0;  A0 = 1;
                    break;
                case 2: 
                    //点亮第2位数码管
                    A2 = 0;  A1 = 1;  A0 = 0;
                    break;
                case 3: 
                    //点亮第3位数码管
                    A2 = 0;  A1 = 1;  A0 = 1;
                    break;
                case 4: 
                //点亮第4位数码管
                A2 = 1;  A1 = 0;  A0 = 0;
                    break;
                case 5: 
                        //点亮第5位数码管
                    A2 = 1;  A1 = 0;  A0 = 1;
                    break;
                case 6: 
                    //点亮第6位数码管
                    A2 = 1;  A1 = 1;  A0 = 0;
                    break;
                case 7: 
                    //点亮第7位数码管
                    A2 = 1;  A1 = 1;  A0 = 1;
                    break;
            }
            SEGMENT_OF_LINE_SELECTION = smg_code[i];
            sleep(10);//1000
            SEGMENT_OF_LINE_SELECTION = 0x00;//消音
        }

    }
}

```

## 实验结果

sleep(1000)的结果

<iframe height = 400 src="pic/数码管动态显示.mp4"></iframe>

sleep(10)的结果

![微信图片_20220524154734](pic\微信图片_20220524154734.jpg)

# 实验五：独立按键实验

## 实验原理

按键消抖

硬件消抖

软件消抖

1. io口高电平
2. 读取IO电平是否该改变来判断按键是否按下
3. 延时读取IO电平（一般为10ms）， 如果仍为低电平，说明按键按下
4. 执行按键控制程序

独立按键原理图

![image-20220524163621077](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220524163621077.png)



## 实验思路

1. 设置P3.1,P3.0,P3.2,P3.4为高电平（51单片机除P0口，其他端口默认为高电平）
2. 通过软件方法来为按键消抖
3. 为K1, K2,K3,K4编写控制程序
4. 控制对象LED，控制对象的状态：亮和灭
5. 实际控制P0端口P0.0~P0.7端口的高低电平

## 代码实现

```c
/**
 * @file main.c
 * @author Gunfire (gunfirefc70@163.com)
 * @brief Realizing the control of independent keys
 * @version 0.1
 * @date 2022-05-24
 * @OnChipMemories: STC89C516RD+
 * @types: C51 chip macrocomputer
 * @copyright Copyright (c) 2022
 *
 */

#include <reg52.h>

//按键状态
#define press 0
#define unpress 1

//声明按键
sbit key1 = P3 ^ 1;
sbit key2 = P3 ^ 0;
sbit key3 = P3 ^ 2;
sbit key4 = P3 ^ 3;

//声明LED
sbit LED1 = P2 ^ 0;
sbit LED2 = P2 ^ 1;
sbit LED3 = P2 ^ 2;
sbit LED4 = P2 ^ 3;

/**
 *  1. 设置P3.1,P3.0,P3.2,P3.4为高电平（51单片机除P0口，其他端口默认为高电平）
    2. 通过软件方法来为按键消抖
    3. 为K1, K2,K3,K4编写控制程序
    4. 控制对象LED，控制对象的状态：亮和灭
    5. 实际控制P0端口P0.0~P0.7端口的高低电平
 */
/*软件消抖流程*/
/**
 * 1. 先设置IO为高电平
 * 2. 判断按键是否按下
 * 3. 延迟10ms
 * 4. 判断IO是否为低电平
 * 5. 如果为低电平，写入控制程序
 */

void sleep(unsigned int seconds)
{
    while (seconds--)
        ;
}

void main()
{
    int pressed = 1;
    while (1)
    {

        if (key1 == press)
        {
            sleep(1000); //消抖
            if (key1 == press)
            {
                LED1 = !LED1;
            }
        }
        if (key2 == press)
        {
            sleep(1000);
            if (key2 == press)
            {
                LED2 = !LED2;
            }
        }
        if (key3 == press)
        {
            sleep(1000);
            if (key3 == press)
            {
                LED3 = !LED3;
            }
        }

        if (key4 == press)
        {
            sleep(1000);
            if (key4 == press)
            {
                LED4 = !LED4;
            }
        }
    }
}

```



## 实验结果

<iframe height=500 src="pic/独立按键.mp4"

实验不足，对于按键采用连续的判断方式，导致有可能在按键按下后，会对按键判断多次，从而导致当按键按下取消后，LED出现亮或灭成为一种随机随状态。

实验改进：保证每一个按键按下后，只做一次状态改变。

代码如下：

```c
/**
 * @file main.c
 * @author Gunfire (gunfirefc70@163.com)
 * @brief Realizing the control of independent keys
 * @version 0.1
 * @date 2022-05-24
 * @OnChipMemories: STC89C516RD+
 * @types: C51 chip macrocomputer
 * @copyright Copyright (c) 2022
 *
 */

#include <reg52.h>

//按键状态
#define KEY1_PRESS 1
#define KEY2_PRESS 2
#define KEY3_PRESS 3
#define KEY4_PRESS 4
#define KEY_UNPRESS 0  

//声明按键
sbit key1 = P3 ^ 1;
sbit key2 = P3 ^ 0;
sbit key3 = P3 ^ 2;
sbit key4 = P3 ^ 3;

//声明LED
sbit LED1 = P2 ^ 0;
sbit LED2 = P2 ^ 1;
sbit LED3 = P2 ^ 2;
sbit LED4 = P2 ^ 3;

/**
 *  1. 设置P3.1,P3.0,P3.2,P3.4为高电平（51单片机除P0口，其他端口默认为高电平）
    2. 通过软件方法来为按键消抖
    3. 为K1, K2,K3,K4编写控制程序
    4. 控制对象LED，控制对象的状态：亮和灭
    5. 实际控制P0端口P0.0~P0.7端口的高低电平
 */
/*软件消抖流程*/
/**
 * 1. 先设置IO为高电平
 * 2. 判断按键是否按下
 * 3. 延迟10ms
 * 4. 判断IO是否为低电平
 * 5. 如果为低电平，写入控制程序
 */

void sleep(unsigned int seconds)
{
    while (seconds--)
        ;
}

unsigned char key_scan(unsigned char mode)
{
    static unsigned char key = 1;
    if(mode) key=1;
    if(key==1&&(key1==0||key2==0||key3==0||key4==0))
    {
        sleep(1000);
        key=0;
        if(key1==0) return KEY1_PRESS;
        if(key2==0) return KEY2_PRESS;
        if(key3==0) return KEY3_PRESS;
        if(key4==0) return KEY4_PRESS;
    }
    else if(key1==1&&key2==1&&key3==1&&key4==1)
    {
        key=1;
    }
    return KEY_UNPRESS;
}

void main()
{
    int pressed = 1;
    while (1)
    {
        unsigned char key = key_scan(0);
        if(key == KEY1_PRESS)
            LED1 = !LED1;
        if(key == KEY2_PRESS)
            LED2 = !LED2;
        if(key == KEY3_PRESS)
            LED3 = !LED3;
        if(key == KEY4_PRESS)
            LED4 = !LED4;
    }
}

```

现在，假设其中有一个按键按下，在按下后的第一次判断为，`key==1`&&`按键按下`，其中一个LED点亮，按下后的每一次判断为`key==0`&&`按键按下`，就会返回KEY_UNPRESS, 不会改变LED的状态了，从而避免了按键按下后对一个LED状态的多次改变。

# 实验六：矩阵键盘实验

矩阵键盘与独立键盘的检测按键按下的处理机制一样。

独立键盘有一端固定为低电平，便于我们编程。

## 检测单片机IO口送出低电平

### 行列扫描检测法

先将其中一行（列）固定为低电平，其余列全为高电平，然后扫描所有的列（行）是否有低电平，有则可以判断有按键按下。然后按照相同的方法，对剩余的行（列）做行列扫描。

### 线反转检测法

使所有行线为低电平时，检测所有列线是否有低电平，如果有，就记录列线值；然后再翻转，使所有列线都为低电平，检测所有行线的值，由于有按键按下，行线的值也会有变化，记录行线的值。从而就可以检测到全部按键。

## 硬件设计

![image-20220525061618312](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220525061618312.png)

## 软件设计

### 行列扫描法的设计与实现

0~3为列线，4~7为行线

| 十六进制数 | 7    | 6    | 5    | 4    | 3    | 2    | 1    | 0    |           | 按键坐标 | 按键 | 对应数字 | 数字下标 |
| ---------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | --------- | -------- | ---- | -------- | -------- |
| 0xEE       | 1    | 1    | 1    | 0    | 1    | 1    | 1    | 0    | 第一列为0 | (4,4)    | S16  | F        | 15       |
| 0xDE       | 1    | 1    | 0    | 1    | 1    | 1    | 1    | 0    |           | (3,4)    | S12  | B        | 11       |
| 0xBE       | 1    | 0    | 1    | 1    | 1    | 1    | 1    | 0    |           | (2,4)    | S8   | 7        | 7        |
| 0x7E       | 0    | 1    | 1    | 1    | 1    | 1    | 1    | 0    |           | (1,4)    | S4   | 3        | 3        |
| 0xED       | 1    | 1    | 1    | 0    | 1    | 1    | 0    | 1    | 第二列为0 | (4,3)    | S15  | E        | 14       |
| 0xDD       | 1    | 1    | 0    | 1    | 1    | 1    | 0    | 1    |           | (3,3)    | S11  | A        | 10       |
| 0xBD       | 1    | 0    | 1    | 1    | 1    | 1    | 0    | 1    |           | (2,3)    | S7   | 6        | 6        |
| 0x7D       | 0    | 1    | 1    | 1    | 1    | 1    | 0    | 1    |           | (1,3)    | S3   | 2        | 2        |
| 0xEB       | 1    | 1    | 1    | 0    | 1    | 0    | 1    | 1    | 第三列为0 | (4,2)    | S14  | D        | 13       |
| 0xDB       | 1    | 1    | 0    | 1    | 1    | 0    | 1    | 1    |           | (3,2)    | S10  | 9        | 9        |
| 0xBB       | 1    | 0    | 1    | 1    | 1    | 0    | 1    | 1    |           | (2,2)    | S6   | 5        | 5        |
| 0x7B       | 0    | 1    | 1    | 1    | 1    | 0    | 1    | 1    |           | (1,2)    | S2   | 1        | 1        |
| 0xE7       | 1    | 1    | 1    | 0    | 0    | 1    | 1    | 1    | 第四列为0 | (4,1)    | S13  | C        | 12       |
| 0xD7       | 1    | 1    | 0    | 1    | 0    | 1    | 1    | 1    |           | (3,1)    | S9   | 8        | 8        |
| 0xB7       | 1    | 0    | 1    | 1    | 0    | 1    | 1    | 1    |           | (2,1)    | S5   | 4        | 4        |
| 0x77       | 0    | 1    | 1    | 1    | 0    | 1    | 1    | 1    |           | (1,1)    | S1   | 0        | 0        |

```c
/*使用行列扫描法*/
s8 matrix_keys_ranks_scan()
{
    s8 value_index=-1;
    //将第4根列线为低电平1111 1110 0xFE
    MATRIX_KEYS = 0xFE;
    if(MATRIX_KEYS!=0xFE)//判断第一列是否有按键按下
    {
        delay_10ms(1000);//消抖
        
        switch(MATRIX_KEYS)
        {
            case S16:
                value_index = 15;
                break;
            case S12:
                value_index = 11;
                break;
            case S8:
                value_index = 7;
                break;
            case S4:
                value_index = 3;
                break;
        }
    }//0XFE

    //将第三根列线为低电平1111 1101 0xFD
    MATRIX_KEYS = 0xFD;
    if(MATRIX_KEYS!=0xFD)//判断第一列是否有按键按下
    {
        delay_10ms(1000);//消抖
        
        switch(MATRIX_KEYS)
        {
            case S15:
                value_index = 14;
                break;
            case S11:
                value_index = 10;
                break;
            case S7:
                value_index = 6;
                break;
            case S3:
                value_index = 2;
                break;
        }
    }//0XFD

    //将第二根列线为低电平1111 1011 0xFB
    MATRIX_KEYS = 0xFB;
    if(MATRIX_KEYS!=0xFB)//判断第一列是否有按键按下
    {
        delay_10ms(1000);//消抖
        
        switch(MATRIX_KEYS)
        {
            case S14:
                value_index = 13;
                break;
            case S10:
                value_index = 9;
                break;
            case S6:
                value_index = 5;
                break;
            case S2:
                value_index = 1;
                break;
        }
    }//0XFB

    //将第一根列线为低电平1111 0111 0xF7
    MATRIX_KEYS = 0xF7;
    if(MATRIX_KEYS!=0xF7)//判断第一列是否有按键按下
    {
        delay_10ms(1000);//消抖
        
        switch(MATRIX_KEYS)
        {
            case S13:
                value_index = 12;
                break;
            case S9:
                value_index = 8;
                break;
            case S5:
                value_index = 4;
                break;
            case S1:
                value_index = 0;
                break;
        }
    }//0XF7

    return value_index;
}
```

### 线反转法的设计与实现

|      | 7    | 6    | 5    | 4    | 3    | 2    | 1    | 0    | 行线值 | 列线值 |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ------ | ------ |
| 1    | 1    | 1    | 1    | 0    | 0    | 0    | 0    | 0    | 4      |        |
|      | 0    | 0    | 0    | 0    | 1    | 1    | 1    | 0    |        | 0      |
| 2    | 1    | 1    | 0    | 1    | 0    | 0    | 0    | 0    | 5      |        |
|      | 0    | 0    | 0    | 0    | 1    | 1    | 0    | 1    |        | 1      |
| 3    | 1    | 0    | 1    | 1    | 0    | 0    | 0    | 0    | 6      |        |
|      | 0    | 0    | 0    | 0    | 1    | 0    | 1    | 1    |        | 2      |
| 4    | 0    | 1    | 1    | 1    | 0    | 0    | 0    | 0    | 7      |        |
|      | 0    | 0    | 0    | 0    | 0    | 1    | 1    | 1    |        | 3      |
| ...  | ...  | ...  | ...  | ...  | ...  | ...  | ...  | ...  | ...    | ...    |

```c
/*使用反转法进行按键检测*/
s8 matrix_keys_flap_scan()
{
    static s8 value_index = -1;
    
    //将所有的行线置为低电平0000 1111 0x0F
    MATRIX_KEYS = 0x0F;
    if(MATRIX_KEYS != 0x0F)
    {
        delay_10ms(1000);
        //检测列
        MATRIX_KEYS = 0x0F;
        switch(MATRIX_KEYS)//获取列线 第一列 0 第二列 1 第三列2 第四列 3
        {
            case 0x07: value_index = 0; break;
            case 0x0B: value_index = 1; break;
            case 0x0D: value_index = 2; break;
            case 0x0E: value_index = 3; break;
        }
        //进行反转，检测行
        MATRIX_KEYS = 0xF0;
        switch(MATRIX_KEYS)//获取行线 第一不变， 第二行 +4， 第三行 +8， 第四行 +12
        {
            case 0x70: value_index = value_index; break;
            case 0xB0: value_index = value_index+4; break;
            case 0xD0: value_index = value_index+8; break;
            case 0xE0: value_index = value_index+12; break;
        }
    }else value_index = -1;

    return value_index;
}
```

### 实现代码

```c
#include <reg52.h>

typedef unsigned char u8;
typedef unsigned int u16;
typedef char s8;

//定义按键
/*第四列按键*/
#define S16 0xEE
#define S12 0xDE
#define S8  0xBE
#define S4  0x7E

/*第三列按键*/
#define S15 0xED
#define S11 0xDD
#define S7  0xBD
#define S3  0x7D

/*第二列按键*/
#define S14 0xEB
#define S10 0xDB
#define S6  0xBB
#define S2  0x7B

/*第一列按键*/
#define S13 0xE7
#define S9  0xD7
#define S5  0xB7
#define S1  0x77

//定义数码管的段选端口P0
#define  DITIGALTUBE_ZERO_PORT P0

//定义数码管未选线
sbit A2 = P2^4;
sbit A1 = P2^3;
sbit A0 = P2^2;

//定义矩阵按键端口P1
#define MATRIX_KEYS P1



void delay_10ms(u16 timecout)
{
    while (timecout--);
}

/*使用行列扫描法*/
s8 matrix_keys_ranks_scan()
{
    s8 value_index=-1;
    //将第4根列线为低电平1111 1110 0xFE
    MATRIX_KEYS = 0xFE;
    if(MATRIX_KEYS!=0xFE)//判断第一列是否有按键按下
    {
        delay_10ms(1000);//消抖
        
        switch(MATRIX_KEYS)
        {
            case S16:
                value_index = 15;
                break;
            case S12:
                value_index = 11;
                break;
            case S8:
                value_index = 7;
                break;
            case S4:
                value_index = 3;
                break;
        }
    }//0XFE

    //将第三根列线为低电平1111 1101 0xFD
    MATRIX_KEYS = 0xFD;
    if(MATRIX_KEYS!=0xFD)//判断第一列是否有按键按下
    {
        delay_10ms(1000);//消抖
        
        switch(MATRIX_KEYS)
        {
            case S15:
                value_index = 14;
                break;
            case S11:
                value_index = 10;
                break;
            case S7:
                value_index = 6;
                break;
            case S3:
                value_index = 2;
                break;
        }
    }//0XFD

    //将第二根列线为低电平1111 1011 0xFB
    MATRIX_KEYS = 0xFB;
    if(MATRIX_KEYS!=0xFB)//判断第一列是否有按键按下
    {
        delay_10ms(1000);//消抖
        
        switch(MATRIX_KEYS)
        {
            case S14:
                value_index = 13;
                break;
            case S10:
                value_index = 9;
                break;
            case S6:
                value_index = 5;
                break;
            case S2:
                value_index = 1;
                break;
        }
    }//0XFB

    //将第一根列线为低电平1111 0111 0xF7
    MATRIX_KEYS = 0xF7;
    if(MATRIX_KEYS!=0xF7)//判断第一列是否有按键按下
    {
        delay_10ms(1000);//消抖
        
        switch(MATRIX_KEYS)
        {
            case S13:
                value_index = 12;
                break;
            case S9:
                value_index = 8;
                break;
            case S5:
                value_index = 4;
                break;
            case S1:
                value_index = 0;
                break;
        }
    }//0XF7

    return value_index;
}

/*使用反转法进行按键检测*/
s8 matrix_keys_flap_scan()
{
    static s8 value_index = -1;
    
    //将所有的行线置为低电平0000 1111 0x0F
    MATRIX_KEYS = 0x0F;
    if(MATRIX_KEYS != 0x0F)
    {
        delay_10ms(1000);
        //检测列
        MATRIX_KEYS = 0x0F;
        switch(MATRIX_KEYS)//获取列线 第一列 0 第二列 1 第三列2 第四列 3
        {
            case 0x07: value_index = 0; break;
            case 0x0B: value_index = 1; break;
            case 0x0D: value_index = 2; break;
            case 0x0E: value_index = 3; break;
        }
        //进行反转，检测行
        MATRIX_KEYS = 0xF0;
        switch(MATRIX_KEYS)//获取行线 第一不变， 第二行 +4， 第三行 +8， 第四行 +12
        {
            case 0x70: value_index = value_index; break;
            case 0xB0: value_index = value_index+4; break;
            case 0xD0: value_index = value_index+8; break;
            case 0xE0: value_index = value_index+12; break;
        }
    }else value_index = -1;

    return value_index;
}

u8 smg_code[]={
        0x3f, 0x06, 0x5b, 0x4f, //0 1 2 3
        0x66, 0x6d, 0x7d, 0x07, //4 5 6 7
        0x7f, 0x6f, 0x77, 0x7c, //8 9 A B
        0x39, 0x5e, 0x79, 0x71  //C D E F
        };

void main(void)
{
    s8 index = -1;
    
    while(1)
    {
        index = matrix_keys_flap_scan();
        A2 = 1; A1= 0; A0 = 1;
        if(index !=-1)
        {
            DITIGALTUBE_ZERO_PORT = smg_code[index];
        }
    }
}
```



## 实验结果

<iframe height=400 src="pic/矩阵按键.mp4">



# 实验七：IO扩展（串转并）-74HC595

用74HC595开扩展芯片的IO口

## 74HC595芯片

74HC595 是一个8 位串行输入、并行输出的位移缓存器，其中并行输出为三
态输出（即高电平、低电平和高阻抗）。

![image-20220525143838753](pic\image-20220525143838753.png)

| 管脚             | 功能                       |
| ---------------- | -------------------------- |
| 15，1~7脚：Q0~Q7 | 并行数据输出               |
| 9脚：#QH         | 低电平有效，串行数据输出   |
| 10脚：#MR        | 低电平有效，低电平复位引脚 |
| 11脚：SH_CP      | 移位寄存器时钟输入         |
| 12脚：ST_CP      | 存储寄存器时钟输入         |
| 13脚：#OE        | 低电平有效，输出使能       |
| 14脚：DS         | 串行数据输入               |

74HC595 是具有8 位移位寄存器和一个存储器，三态输出功能。

移位寄存器和存储器是单独的时钟。

数据在SH_CP 的上升沿输入，在ST_CP的上升沿进入到存储器中。

如果两个时钟连在一起，则移位寄存器总是比存储器早一个脉冲。

移位寄存器有一个串行输入（DS），和一个串行输出（#QH），和一个异步的低电平复位（#MR），存储寄存器有一个并行8 位的，具有三态的总线输出。

==当MR 为高电平，OE 为低电平时，数据在SH_CP 上升沿进入移位寄存器，在ST_CP 上升沿输出到并行端口。==

## 硬件模块

1. 8*8LED点阵模块
2. 74HC595串转并芯片

![image-20220525152408645](pic\image-20220525152408645.png)

![image-20220525152346821](pic\image-20220525152346821.png)

| 引脚                            | 名字               |
| ------------------------------- | ------------------ |
| 15，1~7：QA~QH                  | 并行数据输出       |
| 9：QH‘                          | 串行数据输出       |
| 10：#SRCLR(shift reset clock)   | 低电平复位         |
| 11：SRCLK(shift register clock) | 移位寄存器时钟输入 |
| 12：RCLK(register clock)        | 存储寄存器时钟输入 |
| 13: OE(outpt enable)            | 输出使能           |
| 14:SER（Serial）                | 串行数据输入       |

P3.4~P3.6控制74HC595芯片的SER(串行数据输入)、RCLK(存储寄存器时钟)、SRCLK(移位寄存器时钟)

#SRCLR引脚接VCC

15,1~7引脚 连接LED点阵的8根引脚A1~A8

OE接使能端

## 软件实现



## 实验结果

<iframe height=400 src="pic/74H595扩展IO-串转并.mp4">

# 实验八：LED点阵实验

## 实验要求

1. 在点阵中输入一个点
2. 在点阵中输出数字0-9
3. 在点阵中输出字符a-z
4. 在点阵中输入汉字

## 实验程序

```c
#include <gunfire_condefine.h>

void hc595_write(gu8 dat)
{
    int i;
    for (i = 0; i < 8; i++)
    {
        GUNFIRE_HC595_SER = dat >> 7;
        dat <<= 1;
        GUNFIRE_HC595_SRCLK = 0;
        delay_10us(1);
        GUNFIRE_HC595_SRCLK = 1;
        delay_10us(1);
    }
    GUNFIRE_HC595_RCLK = 0;
    delay_10us(1);
    GUNFIRE_HC595_RCLK = 1;
}

gu8 words_lib_row[][8] = {
    //行
    {0x00,0x7C,0x82,0x82,0x82,0x7C,0x00,0x00}// 0
}; // 22

gu8 words_lib_col[][8] = {
    //列
    {0x7f,0xbf,0xdf,0xef,0xf7,0xfb,0xfd,0xfe}
};

int main()
{
    gu8 j = 0;
    GUNFIRE_LED_MAXTRIX_K = 0x00;
    while (1)
    {
        for (j = 0; j < 8; ++j)
        {
            GUNFIRE_LED_MAXTRIX_K = words_lib_col[0][j];
            hc595_write(words_lib_row[0][j]);

            delay_10us(100);
            hc595_write(0x00);
        }
    }
}
```

字模库

```c
gu8 words_lib_row[][8] = {
    //行
    // {0x00, 0x7C, 0x82, 0x82, 0x82, 0x7C, 0x00, 0x00},  // 0
    // {0x30, 0x48, 0x44, 0x22, 0x44, 0x48, 0x30, 0x00},//love
    {0x10, 0x32, 0x55, 0xFF, 0x10, 0xFE, 0x15, 0x53}, //我
    {0x30, 0x48, 0x44, 0x22, 0x44, 0x48, 0x30, 0x00}, // love
    {0x20, 0x7F, 0xA0, 0x44, 0xC9, 0x7F, 0x48, 0x74}, //你
    {0x38, 0x28, 0x28, 0xFF, 0x28, 0x28, 0x38, 0x00}, //中
    {0xFF, 0x85, 0xD5, 0xFD, 0xD5, 0x8D, 0xFF, 0x00}  //国
};
```



## 实验结果

![微信图片_20220525215234](pic\微信图片_20220525215234.jpg)

通过LED矩阵显示“我爱你中国”

<iframe height=420 src="pic/LED矩阵显示文字.mp4">

# 实验九：直流电机实验

## 涉及的设备和芯片

### 直流电机

直流电机是指能将直流电能转换成机械能（直流电动机）或将机械能转换成直流电能（直流发电机）的旋转电机。它是能实现直流电能和机械能互相转换的电机。

当它作电动机运行时是直流电动机，将电能转换为机械能；作发电机运行时是直流发电机，将机械能转换为电能。

![image-20220526063647851](pic\image-20220526063647851.png)

直流电机的结构应由定子和转子两大部分组成。

直流电机运行时静止不动的部分称为定子，定子的主要作用是产生磁场，由机座、主磁极、换向极、端盖、轴承和电刷装置等组成。

运行时转动的部分称为转子，其主要作用是产生电磁转矩和感应电动势，是直流电机进行能量转换的枢纽，所以通常又称为电枢，由转轴、电枢铁心、电枢绕组、换向器和风扇等组成。

直流电机没有正负之分，在两端加上直流电就能工作。需要知道直流电机的
额定电压和额定功率，不能使之长时间超负荷运作。在交换接线后，可以形成
正反转。

开发板配置的直流电机为5V 直流电机，其主要参数如下：
	轴长：8mm
	轴径：2mm
	电压：1-6V
	参考电流：0.35-0.4A
	3V 转速：17000-18000 转每分钟

### ULN2003驱动芯片

ULN2003是==一个单片高电压、高电流的达林顿晶体管阵列集成电路。==

它是由7 对NPN 达林顿管组成的，它的高电压输出特性和阴极箝位二极管可以转换感应负载。单个达林顿对的集电极电流是500mA。达林顿管并联可以承受更大的电流。此电路主要应用于继电器驱动器，字锤驱动器，灯驱动器，显示驱动器（LED 气体放电），线路驱动器和逻辑缓冲器。ULN2003 的每对达林顿管都有一个2.7k串联电阻，可以直接和TTL 或5V CMOS 装置。

不仅可以用来驱动直流电机，还可用来驱动五线四相步进电机，比如28BYJ-48 步进电机。

（1）主要特点
	①500mA 额定集电极电流（单个输出）
	②高电压输出：50V
	③输入和各种逻辑类型兼容
	④继电器驱动器

（2）逻辑框图

![image-20220526065202769](pic\image-20220526065202769.png)

从上图可以很容易理解该芯片的使用方法，其内部相当于非门电路，即输入高输出为低，输入为低输出是高，这里要注意：==因为ULN2003 的输出是集电极开路，ULN2003 要输出高电平，必须在输出口外接上拉电阻。这也就能解释在后面连接直流电机时为什么不能直接将ULN2003 的2 个输出口接电机线，而必须一根线接电源，另一个才接ULN2003 输出口。==



## 硬件原理图

![image-20220526065723556](pic\image-20220526065723556.png)

ULN2003 的输入口与单片机的P1.0-P1.3 连接，对应输出则是OUT1-OUT4

电机的一根线连接在VCC 上，另一根连接在OUT1 上，因此可通过单片机P1.0 口输出**高电平来控制电机旋转**，**输出低电源控制电机停止**。

注意：单片机P1.0 输出低电平时，ULN2003的OUT1 并不会输出高电平导致停止，而是因为集电极开路，导致电机无电流流入致使停止。

## 实验代码

```c
#include <gunfire_condefine.h>

int main()
{
    delay_ms(2000);//两秒的准备
    while(1)
    {
    GUNFIRE_DC_Motor = 1;
    delay_ms(5000);//跑5s
    GUNFIRE_DC_Motor = 0;
    delay_ms(3000);//休息3s
    }
}
```



## 实验结果

<iframe height=420 src="pic/直流电机.mp4">

# 实验十：步进电机

## 涉及设备

### 步进电机

步进电机是将电脉冲信号转变为角位移或线位移的开环控制元件。在非超载的情况下，电机的转速、停止的位置只取决于脉冲信号的频率和脉冲数，而不受负载变化的影响，即给电机加一个脉冲信号，电机则转过一个步距角。这一线性关系的存在，加上步进电机只有周期性的误差而无累计误差等特点。使得在速度、位置等控制领域用步进电机来控制变的非常的简单。虽然步进电机已被广泛的应用，但步进电机并不能像普通的直流电机，交流电机在常规下使用。它必须由双环形脉冲信号、功率驱动电路等组成控制系统方可使用。

混合式步进电机原理图

![image-20220526080343517](pic\image-20220526080343517.png)

#### 步进电机工作原理

![image-20220526080603264](pic\image-20220526080603264.png)

通常步进电机的转子为永磁体，当电流流过定子绕组时，定子绕组产生一矢量磁场。磁场会带动转子旋转一定的角度，使得转子的一对磁场方向与定子的磁场方向一致。当定子的矢量磁场旋转一个角度，转子也随着该磁场转步距角。每输入一个电脉冲，电动机转动一个角度前进一步。它输出的角位移与输入的脉冲数成正比、转速与脉冲频率成正比。改变绕组通电的顺序，电机就会反转。所以可以控制脉冲数量、频率及电动机各相绕组的通电顺序来控制步进电机的转动。

#### 步进电机极性区分

单极性

双极性

<img src="pic\image-20220526083401487.png" alt="image-20220526083401487" style="zoom:150%;" />



## 软件实现

![image-20220526091925237](pic\image-20220526091925237.png)

![image-20220526065723556](pic\image-20220526065723556.png)

1. 步进电机的速度：与脉冲的频率成正相关
2. 步进电机的运行方向：与相位的通电顺序顺序相关

## 软件设计

在`gunfire_condefine.h`中关于步进电机的全局变量声明

```c
#define GUNFIRE_DC_STEP_MOTOR_CONTROL P1 // 直接用P1端口的低四位来控制步进电机
//直流步进电机相位控制引脚
sbit GUNFIRE_DC_Step_Motor_Phase_D = P1^0;
sbit GUNFIRE_DC_Step_Motor_Phase_C = P1^1;
sbit GUNFIRE_DC_Step_Motor_Phase_B = P1^2;
sbit GUNFIRE_DC_Step_Motor_Phase_A = P1^3;
```

`gunfire_C51_DCStepMotor_func.h`

```c
#ifndef GUNFIRE_C51_DCSTEPMOTOR_FUNC_H
#define GUNFIRE_C51_DCSTEPMOTOR_FUNC_H

#define GUNFIRE_C51_DCSTEPMOTOR_MAXSPEED 1
#define GUNFIRE_C51_DCSTEPMOTOR_MINSPEED 5
#define GUNFIRE_C51_DCSTEPMOTOR_PULSES_SIZE 8

/*
初始化
*/
void G_DCStepMotor_Initial();

/**
 * @brief 步进电机运行
 */
void G_DCStepMotor_Run();
/**
 * @brief 步进电机暂停运行
 * 
 */
void G_DCStepMotor_Stop();

/**
 * @brief 将步进电机的脉冲序列逆置，用于实现电机的反向
 */
void  G_Reverse_Pluses();

/**
 * @brief 电机加速。
 * 实质是控制脉冲的频率，通过delay函数来实现
 */
void G_DCStepMotor_SpeedUp();

/**
 * @brief 电机减速
 * 实质是控制脉冲的频率，通过delay函数来实现
 * @param down 一次减速多少
 */
void G_DCStepMotor_SpeedDown();

/**
 * @brief 电机转向反转
 */
void G_DCStepMotor_Reverse();

void G_IndependentKey_Control();

#endif
```



`gunfire_C51_DCStepMotor_func.cpp`

```c
#include "gunfire_C51_DCStepMotor_func.h"
#include <gunfire_condefine.h>

/*直流步进电机28BYJ-48*/
// 脉冲序列（正向旋转）
static gu8 gunfire_DCStepMotor_pulses[GUNFIRE_C51_DCSTEPMOTOR_PULSES_SIZE]={0x01,0x03,0x02,0x06,0x04,0x0C,0x08,0x09};

//步进电机的初始速度
static gu8 gunfire_DCStepMotor_Speed;
static gu8 gunfire_DCStepMotor_isRunning;
static gu8 G_IndependentKey_Scan(gu8 mode);

void G_IndependentKey_Control()
{
    gu8 key = G_IndependentKey_Scan(0);
    if(key == GUNFIRE_INDEPENDENTKEY1_PRESSED)//反向
        G_DCStepMotor_Reverse();
    if(key == GUNFIRE_INDEPENDENTKEY2_PRESSED)//加速
        G_DCStepMotor_SpeedUp();
    if(key==GUNFIRE_INDEPENDENTKEY3_PRESSED)//减速
        G_DCStepMotor_SpeedDown();
    if(key ==GUNFIRE_INDEPENDENTKEY4_PRESSED)//暂停
        G_DCStepMotor_Stop();
}

/*
初始化
*/
void G_DCStepMotor_Initial()
{
    GUNFIRE_DC_STEP_MOTOR_CONTROL = 0x00;
    gunfire_DCStepMotor_Speed = GUNFIRE_C51_DCSTEPMOTOR_MAXSPEED;
    gunfire_DCStepMotor_isRunning = 1;
}

/**
 * @brief 步进电机运行
 */
void G_DCStepMotor_Run()
{
    int i;
    G_IndependentKey_Control();
    while(gunfire_DCStepMotor_isRunning)
    {
        for(i = 0; i < GUNFIRE_C51_DCSTEPMOTOR_PULSES_SIZE; i++)
        {
            GUNFIRE_DC_STEP_MOTOR_CONTROL = gunfire_DCStepMotor_pulses[i];
            delay_ms(gunfire_DCStepMotor_Speed);
            GUNFIRE_DC_STEP_MOTOR_CONTROL = 0x00;
            G_IndependentKey_Control();
        }
        
    }
}

/**
 * @brief 步进电机暂停运行
 */
void G_DCStepMotor_Stop()
{
        gunfire_DCStepMotor_isRunning = !gunfire_DCStepMotor_isRunning;
}

/**
 * @brief 将步进电机的脉冲序列逆置，用于实现电机的反向
 */
void  G_Reverse_Pluses()
{
    gu8 i,j;
    for(i=0,j=7;i<j;i++,j--)
    {
        G_Swap(&gunfire_DCStepMotor_pulses[i],&gunfire_DCStepMotor_pulses[j]);
    }
}

/**
 * @brief 电机加速。
 * 实质是控制脉冲的频率，通过delay函数来实现
 */
void G_DCStepMotor_SpeedUp()
{
    if(gunfire_DCStepMotor_Speed>GUNFIRE_C51_DCSTEPMOTOR_MAXSPEED)
        gunfire_DCStepMotor_Speed--;
}

/**
 * @brief 电机减速
 * 实质是控制脉冲的频率，通过delay函数来实现
 */
void G_DCStepMotor_SpeedDown()
{
    if(gunfire_DCStepMotor_Speed < GUNFIRE_C51_DCSTEPMOTOR_MINSPEED)
        gunfire_DCStepMotor_Speed++;
}

/**
 * @brief 电机转向反转
 */
void G_DCStepMotor_Reverse()
{
    G_Reverse_Pluses();
}

static gu8 G_IndependentKey_Scan(gu8 mode)
{
    static gu8 key = 1;
    if(mode) key = 1;
    if(key==1&&(GUNFIRE_independentKey1==0||
                GUNFIRE_independentKey2==0||
                GUNFIRE_independentKey3==0||
                GUNFIRE_independentKey4==0))
    {
        delay_10us(1000);
        key=0;
        if(GUNFIRE_independentKey1==0)
        return GUNFIRE_INDEPENDENTKEY1_PRESSED;
        if(GUNFIRE_independentKey2==0)
        return GUNFIRE_INDEPENDENTKEY2_PRESSED;
        if(GUNFIRE_independentKey3==0)
        return GUNFIRE_INDEPENDENTKEY3_PRESSED;
        if(GUNFIRE_independentKey4)
        return GUNFIRE_INDEPENDENTKEY4_PRESSED;
    }
    else if(GUNFIRE_independentKey1==1&&
            GUNFIRE_independentKey2==1&&
            GUNFIRE_independentKey3==1&&
            GUNFIRE_independentKey4==1)
    {
        key =1;
    }
    
    return GUNFIRE_INDEPENDENTKEY_UNPRESS;
}
```

`main.cpp`

```c
#include "gunfire_C51_DCStepMotor_func.h"

void main(void)
{   
    G_DCStepMotor_Initial();
    while(1)
    {
        G_DCStepMotor_Run();
    }
}
```

## 实验结果

![](F:\PerBlog\source\_posts\ComputerScience\Linux\C51单片机\pic\微信图片_20220526152514.jpg)



# 实验十一：外部中断实验

![image-20220527164229710](pic\image-20220527164229710.png)

![image-20220527164320656](pic\image-20220527164320656.png)

开启CPU中断：`EA =1`

开启外部中断0:`EX0 = 1`

中断0的触发方式：`IT0 = 0(电平)/1(边沿)`

编写中断服务程序：

```
void int_func() interrupt 0 [using 0/1] 
```

## 硬件模块

![image-20220527164803347](pic\image-20220527164803347.png)

![image-20220527164806882](pic\image-20220527164806882.png)

## 软件实现

```c
#include <reg52.h>

sbit LED2 = P2 ^ 1;

sbit key2 = P3 ^ 2;


void init_INT0();

void delay_10us(unsigned int us);

void main(void)
{
    init_INT0();
    while (1)
    {}
}

void init_INT0()
{
    EA = 1;
    EX0 = 1;
    IT0 = 1;
}

void delay_10us(unsigned int us)
{
    while (us--)
        ;
}

void key_int() interrupt 0
{
    delay_10us(1000);
    if (key2 == 0)
    {
        LED2 = !LED2;
    }   
    
}
```

## 实验结果

![微信图片_20220527174536](pic\微信图片_20220527174536.jpg)



# 实验十二：定时器中断

使用T/C0定时/计数器

运行定时器0：`TR=1`

为定时器选择工作模式: `TMOD|=0x01(0x00, 0x02,0x03)`

为定时器赋值: `TH0 = 0xFC; TL0 = 0x18;` 定时1ms

为定时器开中断: `ET0=1`

为CPU开中断:`EA=1` 

## 实验要求

用定时器控制LED灯1s间隔闪烁

## 硬件模块

LED模块和定时器0

## 程序实现

```c
#include <reg52.h>
#include <intrins.h>

#define LED P2
sbit led0 = P2^0;
sbit led1 = P2^1;
sbit led2 = P2^2;
sbit led3 = P2^3;


void timer0_init()
{
    TR0 = 1; //开启timer0
    ET0 = 1; // 开启timer0的中断
    EA = 1; // 开启cpu中断
    TMOD |= 0x01;//为timer0启用工作模式1 将TH0和TL0合并为一个16bit的定时器
    /*计算1ms的定时初始值
        外部晶振频率12MHz
        1个时钟周期 = 1/12M s
        1个机器周期 = 12个时钟周期 = 1us
        所以1ms = 1000个机器周期 = 1000us
        1000 = 2^10-24 = 2^10-(2^4 + 2^3)
        0100 0000 0000
    -   0000 0001 1000
        0000 0011 1110 1000--->1000

        1111 1111 1111 1111--->65535
    -   0000 0011 1110 1000--->1000
        1111 1100 0001 0111--->64535
    +   0000 0000 0000 0001--->1
        1111 1100 0001 1000--->64536
    0x   f    c     1    8
         ------     ------
            ||        ||
           TH0       TL0
    */
    TH0 = 0xfc;
    TL0 = 0x18;

}

void main(void)
{
    timer0_init();
    while(1);
}

void timer0_INT() interrupt 1
{
    static unsigned int i;
    unsigned char j;
    TH0 = 0xfc;
    TL0 = 0x18;
    i++;
    if(i==500)//定时1s
    {
        LED =~(0x01<<j++);
        if(j==8)
            j=0;
        i=0;
    }
}
```

## 实验结果

<iframe height=500 src="pic/定时器.mp4">
# 实验十三：UART串口通信

```c
#include <reg52.h>

void UART_init(unsigned char botelv)
{
    
    TMOD |= 0x20; //启用定时器的工作方式2
    SCON = 0x50;  //启用串口通信的工作方式1
    PCON = 0x80;
    TH1 = botelv;
    TL1 = botelv;
    ES = 1;
    TR1 = 1;
    EA = 1;       // 启动CPU中断
}
void main()
{
    UART_init(0xFA);

    while (1){}
}

void UART_INT() interrupt 4
{
    unsigned char rec_data;
    RI = 0;
    rec_data = SBUF;
    SBUF = rec_data;
    while (!TI);
        TI = 0;
}
```



实验结果

![image-20220529172407720](pic\image-20220529172407720.png)






































































































































# 总结

1. P2端口控制LED模块

2. P1端口控制2个四位一体数码管的段选线

3. P2.2, P2.3, P2.4控制2个四位一体数码管的位选线

4. P2.5控制蜂鸣器

5. P3.1, P3.0, P3.2, P3.3 控制独立按键k1,k2,k3,k4

6. P1控制4*4矩阵按键的行线和列线，高四位为行线， 低四位为列线

7. P3.4~P3.6控制74HC595芯片的SER(串行数据输入)、RCLK(存储寄存器时钟)、SRCLK(移位寄存器时钟)

8. P0控制8*8LED点阵的K1~K8

9. P1.0通过ULN2003驱动芯片来控制直流电机，高电平电机工作，低电平电机停止

10. P1.0, P1.1, P1.2, P1.3通过ULN2003驱动芯片来控制五线四相步进电机28BYJ-48的四个相位。

11. EA为CPU中断允许位

12. EX0为外部中断0允许位

13. IT0位外部中断0的触发方式，0表示低电平有效，1表示下降沿有效，IT0对应的IO口位P3.2

    

    

    

