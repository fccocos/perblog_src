---
title: 05_C++_模板
date: 2022/4/18/ 10:00
categories:
  - 计算机科学
tags:
  - 嵌入式
  - C++语言
  - 笔记
sticky: true
valine:
  placeholder: "1. 提问前请先仔细阅读本文档⚡\n2. 页面显示问题💥，请提供控制台截图📸或者您的测试网址\n3. 其他任何报错💣，请提供详细描述和截图📸，祝食用愉快💪"
---



# C++模板

## 模板概论

c++提供了函数模板(function template.)。所谓**<u>函数模板，实际上是建立一个通用函数，其函数类型和形参类型不具体制定，用一个虚拟的类型来代表，这个通用函数就成为函数模板。</u>**凡是函数体相同的函数都可以用这个模板代替，不必定义多个函数，只需在模板中定义一次即可。在调用函数时系统会根据实参的类型来取代模板中的虚拟类型，从而实现不同函数的功能。

c++提供两种模板机制：函数模板和类模板

类属：类型参数化，又称参数模板

总结：

- :large_orange_diamond:模板把函数或类要处理的数据类型参数化，表现为参数的多态性，成为类属。
- :large_orange_diamond:模板用于表达逻辑结构相同，但具体数据元素类型不同的数据对象的通用行为。

 >C++模板最重要的技术：类型参数化

## 函数模板

### 函数模板的定义

```c++
template <class T>//定义一个模板，模板的通用类型T, class和typename是一样的
//紧跟函数
void swap_temp(T &a, T &b)
{
    T tmp = a;
    a = b;
    b = tmp;
}
void test03()
{
    char a =1;
    char b = 2;
    int c = 3;
    int d = 4;
    swap_temp(a,b);//合法
    swap_temp<char>(a,b);//显示指定类型
    swap_temp(b,c);//错误， 自动类型推导的结果不一致
    swap_temp(c,d);//合法
}

```

### 练习

使用函数模板实现数组排序：

```c++
//函数模板用于实现数组排序
template <class T>
void array_sort(T *a, int n)
{
    for(int i = 0; i < n-1; ++i)
    {
        for(int j = 1; j < n; ++j)
        {
            if(a[i]>a[j])
            {
                T tmp = a[i];
                a[i] = a[j];
                a[j] = a[i];
            }
        }
    }
}
template <class T>
void print_array(T *p, int n)
{
    for(int i=0; i<n; ++i)
        cout<<p[i]<<" ";
    cout<<endl;
}
void test01()
{
    int a[]={1,6,4,3,77,22,13,456,1,123};
    array_sort(a, sizeof(a)/sizeof(a[0]));
    print_array(a,sizeof(a)/sizeof(a[0]))
}
void test02()
{
    char b[]={'w','t','c','a','q','m','y','0','9'};
    array_sort<char>(a, sizeof(a)/sizeof(a[0]));
    print_array(a,sizeof(a)/sizeof(a[0]))
}
```

### 函数模板和普通函数的区别

:large_orange_diamond:函数模板不允许自动类型转换

:large_orange_diamond:普通函数能够进行类型自动转换

:large_orange_diamond:调用普通函数不用推导

:large_orange_diamond:`Myadd<>(a,a)`指定模板函数调用

:large_orange_diamond: `Myadd<int>(a,a)`显示指定类型调用模板函数

### 函数模板和普通函数在一起调用的规则

:one: C++编译器优先考虑普通函数

:two: 可以通过空模板实例参数列表的语法:label:限定编译器:computer:只能通过函数模板匹配

:three:函数模板可以像 普通函数一样被重载

:four: 如果函数模板可以产生一个更好的匹配，那么选择模板

## 模板机制剖析

:thinking: 为什么模板函数可以和普通函数放在一起？C++编译器是如何实现函数模板机制的？

### 编译过程

`hello.cpp`程序是高级c语言程序，这种程序易于被人读懂。为了在系统上运行`hello.c`程序，每一条c语句都必须转化为低级的机器指令。然后将这些机器指令打包成可执行目标文件格式，并以二进制形式存储于磁盘中。预处理(`Pre-processing`):arrow_right:编译(`Compiling`):arrow_right:汇编(`Assembling`):arrow_right:链接(`Linking`)

[![Lri2He.png](https://s1.ax1x.com/2022/04/20/Lri2He.png)](https://imgtu.com/i/Lri2He)

:one:`hello..c`经过预处理器，将宏展开，生成的文件`hello.i`

:two:`hello.i`经过编译器，将文件编译成汇编语言，生成文件为`hello.s`

:three:`hello.s`经过汇编器，将文件编译成目标文件`hello.o`(win下为`hello.obj`)

:four:`hello.o`经过链接器，将文件编译成可执行文件

### 模板函数机制

:one: 编译器并不是把函数模板处理成能够处理任何类型的函数

:two: 函数模板通过具体类型产生不同的函数

:three:编译器会对函数模板进行两次编译，在声明的地方对模板代码本身进行编译，在调用的地方对参数替换后的代码进行编译。

### 模板函数的局限性

编写的模板函数很可能无法处理某些类型，另一方面，有时候通用化是有意义的，但C++语法不允许这样做。为了解决这种问题，可以提供模板的重载，为这些特定的类型提供具体化的模板。

函数模板具体化语法：`template<> void mySwap<Person>(Person &p1, Person&p2)`

## 类模板

### 类模板语法

```c++
template <class T1, class T2>
class Animal
{
public:
    Animal(T1 a, T2 b):age(a),data(b){}
    T1 age;
    T2 data;

};
void test()
{
    //类模板不能自动类型推导
    Animal<int,int> dog(10,10);//显示指定
    Aninmal<int,string> cat(4,"lili");
}
```

### 类模板作为函数参数

```c++
template <class T1, class T2>
class Animal
{
public:
    Animal(T1 a, T2 b):age(a),data(b){}
    T1 age;
    T2 data;

};
void show(Animal<int,int> &p)
{
    cout<<p.age<<" "<<p.data<<endl;
}
//函数模板
template <class T1, class T2>
void show(Animal<T1, T2> &p)
{
     cout<<p.age<<" "<<p.data<<endl;
}
template <class T1>
void show1(T1 &p)
{
    cout<<p.age<<" "<<p.data<<endl;
}
void test()
{
    //类模板不能自动类型推导
    Animal<int,int> dog(10,10);//显示指定
    show(dog);
    Aninmal<int,string> cat(4,"lili");
    show(cat);
    show1(cat);
}
```

### 类模板派生普通类

:large_orange_diamond: 类模板遇到继承，在继承时，继承的类必须是一个模板类

:large_orange_diamond: 类模板遇到继承，可以将子类写成类模板

```c++
template <class T>
class Base
{
public:
    Base(T a)
    {
        this->a = a;
    }
    T a;
};
//子类为普通类
class Son1: public Base<int>
{
public:
    Son1(int x1, int a):Base<int>(a),x(x1){}
    int x;
};
//子类为类模板
template <class T1, class T2>
class Son2: public Base<T2>
{
public:
    Son2(T1 x1, T2 a):Base<T2>(a),x(x1){}
    T1 x;
};
void test01()
{
    Son1 p(10,20);
    Son2 p1(10,"linker");
}

```

### 类模板成员函数的类内实现

```c++
template <class T1, class T2>
class Person
{
public:
    Person(T1 a, T2 b)
    {
        this->a = a;
        this->b = b;
    }
    void show()
    {
        cout<<a<<" "<<b<<endl;
    }
    T1 a;
    T2 b;
}
void test()
{
    Person <int, string> p(10, "lili");
    p.show();
}
```

### 类模板成员函数的类外实现

类模板成员函数的类外实现需要<u>写成函数模板</u>

```c++
template <class T1, class T2>
class Person
{
public:
    Person(T1 a, T2 b);
    void show();

    T1 a;
    T2 b;
}
//类外实现 需要写成函数模板
template <class T1, class T2>
Person<T1, T2>::Person(T1 a, T2 b)
{
    this->a = a;
    this->b = b;
}
template <class T1, class T2>
void Person<T1,T2>::show()
{
    cout<<this->a<<" "<<this->b<<endl;
}
void test()
{
    Person <int, string> p(10, "lili");
    p.show();
}
```

### 类模板成员函数的创建机制

类模板成员函数是在调用的时候创建的，没有调用编译器不会创建只有声明。

```c++
class A
{
public:
    void showA()
    {
        cout<<"class A"<<endl;
    }
};
class B
{
public:
    void showB()
    {
        cout<<"class B"<<endl;
    }
};
template <class T>
class C
{
public:
    void foo1()
    {
        obj.showA();
    }
    void foo2()
    {
        obj.showB();
    }
    T obj;
};
```

### 类模板头文件和源文件分离问题

:tonga: 类模板的文件，必须将函数的定义和类的声明写到一个文件

`Person.h`文件中

```c++
#pragma once
template <class T1, class T2>
class person
{
public:
    person(T1 a, T2 b);
    void show();
    T1 a;
    T2 b;
}
```

`Person.cpp`文件中

```c++
#include "Person.h"
template <class T1, class T2>
person<T1,T2>::person(T1 a, T2 b)
{
    this->a = a;
    this->b = b;
}
template <class T1, class T2>
void person<T1,T2>::show()
{
    cout<<this->a<<" "<<this->b<<endl;
}
```

`main.cpp`文件中

```c++
#include "person.h"
int main()
{
    //调用构造函数和show函数需要创建的时候，无法找到这写函数的定义
    person<int, int> p(10,20);
    p.show();//无法连接show函数定义
}
```

**正确用法**

用`.hpp`文件声明和定义类模板

在`Person.hpp`文件中

```c++
#pragma once
template <class T1, class T2>
class person
{
public:
    person(T1 a, T2 b);
    void show();
    T1 a;
    T2 b;
}
template <class T1, class T2>
person<T1,T2>::person(T1 a, T2 b)
{
    this->a = a;
    this->b = b;
}
template <class T1, class T2>
void person<T1,T2>::show()
{
    cout<<this->a<<" "<<this->b<<endl;
}
```

在`main.cpp`文件中

```c++
#include "Person.hpp"
int main()
{
    person<int, int> p(10,20);//合法
    p.show();//合法
}
```

### 类模板遇到友元

```c++
template <class T1, class T2>
void show_Person(Person<T1,T2>&p);

template <class T1, class T2>
class Person
{
    friend void show_Person<>(Person<T1,T2>&p);
    friend void show_Person1(Person<T1,T2>&p)
    {
        cout<<p.a<<" "<<p.b<<endl;
    }
public:
    Person(T1 a, T2 b)
    {
        this->a = a;
        this->b = b;
    }
private:
    T1 a;
    T2 b;
};
template <class T1, class T2>
void show_Person(Person<T1,T2>&p)
{
    cout<<p.a<<" "<<p.b<<endl;
    
}
void test01()
{
    
}
```



### 类模板的应用

设计一个数组模板类(MyArray)，完成对不同类型元素的管理

```c++
//用户接口
1. 根据指定的位置添加元素
2. 获取指定位置的元素
3. 尾插法插入数据 尾部删除数据
4. 获取数组长度
5. 重载[]操作符
6. 重写拷贝构造
template <typename T>
class Array
{
public:
    
private:
    int size;
    int capacity;
    T *ptr;
};
```

