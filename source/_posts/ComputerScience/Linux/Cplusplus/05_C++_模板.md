---
title: 05_C++_模板
date: 2022/4/18/ 10:00
categories:
  - 计算机科学
tags:
  - 嵌入式
  - C++语言
  - 笔记
sticky: true
valine:
  placeholder: "1. 提问前请先仔细阅读本文档⚡\n2. 页面显示问题💥，请提供控制台截图📸或者您的测试网址\n3. 其他任何报错💣，请提供详细描述和截图📸，祝食用愉快💪"
---



# C++模板

## 模板概论

c++提供了函数模板(function template.)。所谓**<u>函数模板，实际上是建立一个通用函数，其函数类型和形参类型不具体制定，用一个虚拟的类型来代表，这个通用函数就成为函数模板。</u>**凡是函数体相同的函数都可以用这个模板代替，不必定义多个函数，只需在模板中定义一次即可。在调用函数时系统会根据实参的类型来取代模板中的虚拟类型，从而实现不同函数的功能。

c++提供两种模板机制：函数模板和类模板

类属：类型参数化，又称参数模板

总结：

- :large_orange_diamond:模板把函数或类要处理的数据类型参数化，表现为参数的多态性，成为类属。
- :large_orange_diamond:模板用于表达逻辑结构相同，但具体数据元素类型不同的数据对象的通用行为。

 >C++模板最重要的技术：类型参数化

## 函数模板

### 函数模板的定义

```c++
template <class T>//定义一个模板，模板的通用类型T, class和typename是一样的
//紧跟函数
void swap_temp(T &a, T &b)
{
    T tmp = a;
    a = b;
    b = tmp;
}
void test03()
{
    char a =1;
    char b = 2;
    int c = 3;
    int d = 4;
    swap_temp(a,b);//合法
    swap_temp<char>(a,b);//显示指定类型
    swap_temp(b,c);//错误， 自动类型推导的结果不一致
    swap_temp(c,d);//合法
}

```

### 练习

使用函数模板实现数组排序：

```c++
//函数模板用于实现数组排序
template <class T>
void array_sort(T *a, int n)
{
    for(int i = 0; i < n-1; ++i)
    {
        for(int j = 1; j < n; ++j)
        {
            if(a[i]>a[j])
            {
                T tmp = a[i];
                a[i] = a[j];
                a[j] = a[i];
            }
        }
    }
}
template <class T>
void print_array(T *p, int n)
{
    for(int i=0; i<n; ++i)
        cout<<p[i]<<" ";
    cout<<endl;
}
void test01()
{
    int a[]={1,6,4,3,77,22,13,456,1,123};
    array_sort(a, sizeof(a)/sizeof(a[0]));
    print_array(a,sizeof(a)/sizeof(a[0]))
}
void test02()
{
    char b[]={'w','t','c','a','q','m','y','0','9'};
    array_sort<char>(a, sizeof(a)/sizeof(a[0]));
    print_array(a,sizeof(a)/sizeof(a[0]))
}
```

### 函数模板和普通函数的区别

:large_orange_diamond:函数模板不允许自动类型转换

:large_orange_diamond:普通函数能够进行类型自动转换

:large_orange_diamond:调用普通函数不用推导

:large_orange_diamond:`Myadd<>(a,a)`指定模板函数调用

:large_orange_diamond: `Myadd<int>(a,a)`显示指定类型调用模板函数

### 函数模板和普通函数在一起调用的规则

:one: C++编译器优先考虑普通函数

:two: 可以通过空模板实例参数列表的语法:label:限定编译器:computer:只能通过函数模板匹配

:three:函数模板可以像 普通函数一样被重载

:four: 如果函数模板可以产生一个更好的匹配，那么选择模板

## 模板机制剖析

:thinking: 为什么模板函数可以和普通函数放在一起？C++编译器是如何实现函数模板机制的？

### 编译过程

`hello.cpp`程序是高级c语言程序，这种程序易于被人读懂。为了在系统上运行`hello.c`程序，每一条c语句都必须转化为低级的机器指令。然后将这些机器指令打包成可执行目标文件格式，并以二进制形式存储于磁盘中。预处理(`Pre-processing`):arrow_right:编译(`Compiling`):arrow_right:汇编(`Assembling`):arrow_right:链接(`Linking`)

[![Lri2He.png](https://s1.ax1x.com/2022/04/20/Lri2He.png)](https://imgtu.com/i/Lri2He)

:one:`hello..c`经过预处理器，将宏展开，生成的文件`hello.i`

:two:`hello.i`经过编译器，将文件编译成汇编语言，生成文件为`hello.s`

:three:`hello.s`经过汇编器，将文件编译成目标文件`hello.o`(win下为`hello.obj`)

:four:`hello.o`经过链接器，将文件编译成可执行文件

### 模板函数机制

:one: 编译器并不是把函数模板处理成能够处理任何类型的函数

:two: 函数模板通过具体类型产生不同的函数

:three:编译器会对函数模板进行两次编译，在声明的地方对模板代码本身进行编译，在调用的地方对参数替换后的代码进行编译。

### 模板函数的局限性

编写的模板函数很可能无法处理某些类型，另一方面，有时候通用化是有意义的，但C++语法不允许这样做。为了解决这种问题，可以提供模板的重载，为这些特定的类型提供具体化的模板。

函数模板具体化语法：`template<> void mySwap<Person>(Person &p1, Person&p2)`

## 类模板

### 类模板语法

```c++
template <class T1, class T2>
class Animal
{
public:
    Animal(T1 a, T2 b):age(a),data(b){}
    T1 age;
    T2 data;

};
void test()
{
    //类模板不能自动类型推导
    Animal<int,int> dog(10,10);//显示指定
    Aninmal<int,string> cat(4,"lili");
}
```

### 类模板作为函数参数

```c++
template <class T1, class T2>
class Animal
{
public:
    Animal(T1 a, T2 b):age(a),data(b){}
    T1 age;
    T2 data;

};
void show(Animal<int,int> &p)
{
    cout<<p.age<<" "<<p.data<<endl;
}
//函数模板
template <class T1, class T2>
void show(Animal<T1, T2> &p)
{
     cout<<p.age<<" "<<p.data<<endl;
}
template <class T1>
void show1(T1 &p)
{
    cout<<p.age<<" "<<p.data<<endl;
}
void test()
{
    //类模板不能自动类型推导
    Animal<int,int> dog(10,10);//显示指定
    show(dog);
    Aninmal<int,string> cat(4,"lili");
    show(cat);
    show1(cat);
}
```

### 类模板派生普通类

:large_orange_diamond: 类模板遇到继承，在继承时，继承的类必须是一个模板类

:large_orange_diamond: 类模板遇到继承，可以将子类写成类模板

```c++
template <class T>
class Base
{
public:
    Base(T a)
    {
        this->a = a;
    }
    T a;
};
//子类为普通类
class Son1: public Base<int>
{
public:
    Son1(int x1, int a):Base<int>(a),x(x1){}
    int x;
};
//子类为类模板
template <class T1, class T2>
class Son2: public Base<T2>
{
public:
    Son2(T1 x1, T2 a):Base<T2>(a),x(x1){}
    T1 x;
};
void test01()
{
    Son1 p(10,20);
    Son2 p1(10,"linker");
}

```

### 类模板成员函数的类内实现

```c++
template <class T1, class T2>
class Person
{
public:
    Person(T1 a, T2 b)
    {
        this->a = a;
        this->b = b;
    }
    void show()
    {
        cout<<a<<" "<<b<<endl;
    }
    T1 a;
    T2 b;
}
void test()
{
    Person <int, string> p(10, "lili");
    p.show();
}
```

### 类模板成员函数的类外实现

类模板成员函数的类外实现需要<u>写成函数模板</u>

```c++
template <class T1, class T2>
class Person
{
public:
    Person(T1 a, T2 b);
    void show();

    T1 a;
    T2 b;
}
//类外实现 需要写成函数模板
template <class T1, class T2>
Person<T1, T2>::Person(T1 a, T2 b)
{
    this->a = a;
    this->b = b;
}
template <class T1, class T2>
void Person<T1,T2>::show()
{
    cout<<this->a<<" "<<this->b<<endl;
}
void test()
{
    Person <int, string> p(10, "lili");
    p.show();
}
```

### 类模板成员函数的创建机制

类模板成员函数是在调用的时候创建的，没有调用编译器不会创建只有声明。

```c++
class A
{
public:
    void showA()
    {
        cout<<"class A"<<endl;
    }
};
class B
{
public:
    void showB()
    {
        cout<<"class B"<<endl;
    }
};
template <class T>
class C
{
public:
    void foo1()
    {
        obj.showA();
    }
    void foo2()
    {
        obj.showB();
    }
    T obj;
};
```

### 类模板头文件和源文件分离问题

:tonga: 类模板的文件，必须将函数的定义和类的声明写到一个文件

`Person.h`文件中

```c++
#pragma once
template <class T1, class T2>
class person
{
public:
    person(T1 a, T2 b);
    void show();
    T1 a;
    T2 b;
}
```

`Person.cpp`文件中

```c++
#include "Person.h"
template <class T1, class T2>
person<T1,T2>::person(T1 a, T2 b)
{
    this->a = a;
    this->b = b;
}
template <class T1, class T2>
void person<T1,T2>::show()
{
    cout<<this->a<<" "<<this->b<<endl;
}
```

`main.cpp`文件中

```c++
#include "person.h"
int main()
{
    //调用构造函数和show函数需要创建的时候，无法找到这写函数的定义
    person<int, int> p(10,20);
    p.show();//无法连接show函数定义
}
```

**正确用法**

用`.hpp`文件声明和定义类模板

在`Person.hpp`文件中

```c++
#pragma once
template <class T1, class T2>
class person
{
public:
    person(T1 a, T2 b);
    void show();
    T1 a;
    T2 b;
}
template <class T1, class T2>
person<T1,T2>::person(T1 a, T2 b)
{
    this->a = a;
    this->b = b;
}
template <class T1, class T2>
void person<T1,T2>::show()
{
    cout<<this->a<<" "<<this->b<<endl;
}
```

在`main.cpp`文件中

```c++
#include "Person.hpp"
int main()
{
    person<int, int> p(10,20);//合法
    p.show();//合法
}
```

### 类模板遇到友元

```c++
//声明
template <class T1, class T2>
void show_Person(Person<T1,T2>&p);

template <class T1, class T2>
class Person
{
    //在类内定义
    friend void show_Person<>(Person<T1,T2>&p);
    //在类内定义并实现
    friend void show_Person1(Person<T1,T2>&p)
    {
        cout<<p.a<<" "<<p.b<<endl;
    }
public:
    Person(T1 a, T2 b)
    {
        this->a = a;
        this->b = b;
    }
private:
    T1 a;
    T2 b;
};
//在类外实现
template <class T1, class T2>
void show_Person(Person<T1,T2>&p)
{
    cout<<p.a<<" "<<p.b<<endl;
    
}
void test01()
{
    
}
```

### 虚基类模板

#### 虚函数的实现原理

拥有虚函数的每一个类的对象中都存在一个vfptr指针，vfptr指针指向本类虚函数入口的查找表vtable。指向子类对象的指针被上转义(upcasting)成指向父类的指针后，其指向虚函数表vtable的指针不会改变，即vtable的入口地址没有改变，从而保留了子类对象的类信息，从而使得指向父类的指针可以调用到子类的虚函数实现。

### 由虚函数启发虚基类模板

如果基类或模板类中保存有子类的类型信息，则在编译期也可以通过提取该类型信息而正确调用该类型的成员函数，实现编译期的多态。

### 虚基类模板

虚基类模板很简单，只需先为拥有共同概念的类型定义一个共同的基类模板，比如为矩阵类型定义一个基类模板：

```c++
template<typename T>
struct matrix_concept{
typedef T type;
}；
```




这样一个基类模板**除了将模板参数再定义外并无其他内容**，即<u>该模板只是将其模板实参类型T保存下来；然后在声明具体的合乎该概念的类型时，以该概念所对应的基类模板的实例为基类，实例的模板实参即为该类型本身。</u>

例如，两个符合矩阵概念的矩阵类dense_matrix和sparse_matrix,可以按照如下方式声明为matrix_concept模板实例的派生类。

```c++
class dense_matrix:public matrix_concept<dense_maxtrix>{}
class spare_matrix:public matrix_concept<sparse_maxtrix>{}
//根据基类可以知道，dense_maxtrix和spare_maxtrix都被重定义为type，即基类中有子类的类型信息了
```

通过将基类模板的实参设置为派生类自身类型，可以使基类中存子类的类型信息。

上述代码的写法相当于先前置声明子类，然后实现基类，再实现子类。

```c++
//矩阵类前置声明
class dense_maxtrix;
class sparse_maxtrix;

//生成模板实例类型
typedef matrix_concept<dense_matrix> dense_matrix_base;
typedef matrix_concept<sparse_matrix> sparse_matrix_base;

//矩阵类实现
class dense_matrix:public dense_matrix_base{};
class sparse_matrix:public sparse_matrix_base{};
```

由于在生成基类模板matrix concept的实例时，只有子类的前置声明而无实现，所以基类模板中的内容只要不涉及子类类型的具体实现时都是可以编译的。一旦其中涉及子类的具体实现，便会编译出错。下面的代码便演示了子类前置定义在基类模板中的几种可行与不可行的用法：

```c++
template<class T>
struct matrix concept{
typedef T type; //可行
typedef T*pointer type; //可行
typedef typename T::value value;//不可行
T a;//不可行。前置声明不是完全的类型声明，不能用于生成实例
};
```

#### 为模板类声明基类模板

```c++
template <typename T>
class dense_matrix:public matrix_concept<dense_matrix<T>>{};
template<typename T>
class sparse_matrix:public matrix_concept<sparse_matrix<T>>{};
```

通过这样一种机制，基类模板matrix_concept中已经存有子类类型信息。并且，只要约定：

​	I)`matrix concept<T>`必然是T的基类；

​	2)任何`matrix_concept<T>`的实例都是由**T的实例上转义而来的**。则任何`matrix_concept<T>`的实例都可以**安全下转义回T的实例**。

利用这一特点，可以用`matrix_concept<T>`和原理类似的向量概念类模板`vector_concept<T>`为函数参数类型编写算法，并在算法中将参数实例直接下转义成真正的矩阵和向量类型后再实现相应算法，从而以一个全覆盖的函数模板作为入口所带来的种种弊端就可以避免。按照这一思路，面向概念基类模板结构的矩阵×向量，以及向量×矩阵的算法模板的实现方式如下所示：

```c++
//矩阵x向量
template <typename T0, typename T1>
typename vector_concept<T0>::type 
operator*(matrix_concept<T0> const &mc, vector_concept<T1> const &vc)
{
    typedef typename matrix_concept<T0>::type matrix_type;
    typedef typename vector_concept<T1>::type vector_type;
    //将函数参数向下转义
    matrix_type const &m(*reinterpret_cast<const matrix_type*>(&mc));
    vector_type const &v(*reinterpret_cast<const vector_type*>(&vc));
    //具体实现略
}
//向量x矩阵
template <class T0, class T1>
typename vector_comcept<T1>::type
operator*(vector_concept<T0> const &vc, matrix_concept<T1> const &mc)
{
    typedef typename vector_concept<T0>::type vector_type;
    typedef typename matrix_concept<T1>::type matrix_type;
    
    //将函数参数向下转
    vector_type const &v(*reinterpret_cast<const vector_type*>(&vc));
    matrix_type const &m(*reinterpret_cast<const matrix_type*>(&mc));
}
```



没有标签与特性，也无须为确定函数返回类型而大费周章，只需根据算式左右操作数的类型选择合适的基类模板实例作为参数即可。

如果说虚函数是将子类的类型信息保存在每个子类实例中以达到运行期的多态，则上述**基类模板是将子类的类型信息保存在基类类型中以达到一种编译期的多态**。当然，之所以能如此实现，还有一个关键的假定，即**任何基类模板实例只能由其所保存的子类实例上转义而来，否则算法中所用的下转义操作将引发严重的内存访问错误。**

**为了防止大意而生成基类模板实例，可将基类模板的默认构造函数设为protected；**但尽管如此，还不能严格保证基类模板实例是由其所存子类实例上转义而来，只能在写代码
时更加谨慎严格地遵守约定。

**基类模板还可以相同方式再继承其他基类模板，从而可提供更多层次的概念操作支持。**
假如矩阵和向量概念都支持对其全部元素进行迭代的话（比如像标准容器那样提供begin(
和end0迭代器)，则两个概念相当于从另一个“序列”概念细化而来。相应地，基类模板
定义可以改为：

```c++
template<typename T>
struct sequence_concept
{
    typedef T type;
};
template<typename T>
struct matrix_concept: sequence_concept<T>{};
template<typename T>
struct vector_concept: sequence_concept<T>{};
```

有此继承关系后，我们可利用sequence_concept为矩阵和向量统一实现其与标量（即其元素类型)相乘的运算符重载：

```c++
//变量x矩阵或向量（即序列概念）
template <typename T>
typename sequence_concept<T>::type
operator*(typename sequence_concept<T>::type::value_type const &v, sequence_concept<T> const &sc)
{
    typedef typename sequence_concept<T>::type seqence_type;
    sequence_type const &s(*reinterpret_cast<const sequence_type*>(&sc));
    //用迭代器遍历矩阵或向量的每一个元素，将元素乘以v值后赋予新的矩阵或向量实例
    return s;
}
```

C++允许多重继承，可使某类型或者某个概念继承自多个独立概念基类模板。

活用基类模板，可为类模板提供严谨而详细的多层次概念抽象，使得在不同层次的概念为所属类模板统一实现算法更加轻松。但需要再次强调，这一方法必须严格遵守概念基类实例，必然由子类实例上转义而来的约定，否则将使算法中所用的下转义语句会成为严重的隐患。

### 类模板的应用

设计一个数组模板类(MyArray)，完成对不同类型元素的管理

```c++
//用户接口
1. 根据指定的位置添加元素
2. 获取指定位置的元素
3. 尾插法插入数据 尾部删除数据
4. 获取数组长度
5. 重载[]操作符
6. 重写拷贝构造
template <typename T>
class Array
{
public:
    
private:
    int size;
    int capacity;
    T *ptr;
};
```

#### 对象池

##### 对象池的好处

对于那些创建和销毁需要浪费大量资源的对象或者需要频繁创建和销毁的对象，我们可以使用对象池来管理这些对象，即可以减少对象创建和销毁时的系统开销，又便于管理对象。

##### 对象池的实现原理

对象池主要由三个部分组成对象池、对象管理器、各种对象。

首先，通过对象管理器，从对象池中获取一个对象，如果没有就创建一个，并返回对象引用；

其次，获得引用后，就可以直接使用对象的成员函数；

最后，当对象使用完毕后，只需要清空数据，不删除对象，将其重新放入到对象池中，等待下一次获取。

##### 对象池结构分析

由对象池的构成可以将对象池分成三个类，对象池类、对象管理类和对象类。根据应用要求，对象池和对象管理器都只能有且只有一个实例对象，因此对象池和对象管理器都可以用单例模式来实现，由于对象可以有很多个不同类型的对象，因此可以用工厂方法模式实现对象的创建。接下来我们需要讨论一下对象池的存储组织方式。使用数组，那么需要进行预配分，如果使用动态数组，那么需要进行指针管理。

##### 对象池类图

[![Lof8fI.png](https://s1.ax1x.com/2022/04/25/Lof8fI.png)](https://imgtu.com/i/Lof8fI)
