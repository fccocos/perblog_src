---
title: 06_C++_类型转换
date: 2022/4/18/ 13:00
categories:
  - 计算机科学
tags:
  - 嵌入式
  - C++语言
  - 笔记
sticky: true
valine:
  placeholder: "1. 提问前请先仔细阅读本文档⚡\n2. 页面显示问题💥，请提供控制台截图📸或者您的测试网址\n3. 其他任何报错💣，请提供详细描述和截图📸，祝食用愉快💪"
---



# C++类型转换

## 类型转换

类型转换(cs)是将一种数据类型转换成另一种数据类型。例如，如果将一个整型值赋给一个浮点类型的变量，编译器会暗地里将其转换成浮点类型。

转换是非常有用的，但是它也会带来一些问题，比如在转换指针时，我们很可能将其转换成一个比它更大的类型，但这可能会破坏其他的数据。

应该小心类型转换，因为转换也就相当于对编译器说：忘记类型检查，把它看做其他的类型。一般情况下，尽量少的去使用类型转换，除非用来解决非常特殊的问题。

无论什么原因，任何一个程序如果使用很多类型转换都值得怀疑

标准c++提供了一个显示的转换的语法，来替代旧的C风格的类型转换。
使用C风格的强制转换可以把想要的任何东西转换成我们需要的类型。那为什么还需要一个新的C+类型的强制转换呢？

新类型的强制转换可以提供更好的控制强制转换过程，允许控制各种不同种类的强制转换。C+风格的强制转换其他的好处是，它们能更清晰的表明它们要干什么。程序员只要扫一眼这样的代码，就能立即知道一个强制转换的目的。

### 静态转换`static_cast`

关键字：`static_cast<>()`

:1st_place_medal: `static_cast<>()`不能用于没有继承关系之间的类进行转换

:2nd_place_medal: 如果两个类之间有继承关系，`static_cast<>()`可以类型转换

:3rd_place_medal:`static_cast<>()`不会保证转换的安全性

:four: `static_cast<>()`不能转换内置类型的指针

:five:`static_cast<>()`可以转换内置类型，与C的强制类型转一样

:six: 父转子，即向上类型转换，是安全的

:seven: 子转父，即向下类型转换，是不安全的，可能会出现越界的问题 

```c++
class A{};
class B: public A{};

//具有继承关系类之间可以用static_cast<>()进行类型转换
void test01()
{
    A *p1 = new A;
    B *p2 = new B;
    p1 = static_cast<B*>(p2);//合法，且安全
    p2 = static_cast<A*>(p1);//合法，但不安全
}
//内置类型可以用
void tes02()
{
    int a;
    char b;
    double c;
    a = static_cast<int>(b);
    b = static_cast<char>(c);
}
//内置类型指针不可以用
void test03()
{
    int *a;
    char *b;
    a = static_cast<int*>(b);//非法的
}
```

### 动态转换`dynamic_cast`

:a: dynamic_cast主要用于具有继承关系的类层次间的上行转换和下行转换;

:b: 在类层次间进行上行转换时，dynamic_cast和static_cast的效果是一样的；

:cherries: 在进行下行转换时，dynamic_cast具有类型检查的功能，比static_cast更安全；

:eagle: 不能用于转化基本的数据类型

:dancer: 多态的时候，向上和向下类型转换都是安全的

### 常量转换`const_cast`

`const_cast`用于加`const`或去`const`

```c++
int *p1=NULL;
const int *p2 = NULL;
p1 = const_cast<int *>(p2);
p2 = const_cast<const int*>(p1);
```

### 重新解释转换(reinterpret_cast)

这是最不安全的一种转换机制，最有可能出问题。

主要用于将一种数据从一种类型转换为另一种类型。它可以将一个指针转换成一个整数，也可以将一个整数转换成一个指针。

```c++
int *p = NULL;
char* p1 = NULL;
p = reinterpret_cast<int *>(p1);
p1 = reinterpret_cast<char*>(p);
int c = reinterpret_cast<int>(p1);
p1 = reinterpret_cast<int*>(c);
```

### 总结

:orange: static_cast 一般用于转换内置的基本数据类型

:orange: dynamic_cast 一般用于转换具有继承关系之间的自定义数据类型

:orange: const_cast 一般用来转换加const和去const

:orange: reinterpret_cast 一般用于转指针