---
title: 04_C++_类和对象
date: 2022/4/18/ 8:00
categories:
  - 计算机科学
tags:
  - 嵌入式
  - C++语言
  - 笔记
sticky: true
valine:
  placeholder: "1. 提问前请先仔细阅读本文档⚡\n2. 页面显示问题💥，请提供控制台截图📸或者您的测试网址\n3. 其他任何报错💣，请提供详细描述和截图📸，祝食用愉快💪"
---



# 第四章  类和对象

## 类和对象的基本概念

### C和C++中struct的区别

C语言的结构体没有函数，C++中的`struct`可以放函数

### 类的封装

**将事物抽象成属性和行为，并封装在一起**

编写程序的目的是为了解决现实中的问题，而这些问题的构成都是由各种事物组成。我们在计算机中要解决这种问题，首先要做就是要将这个问题的参与者，事和物抽象到计算机程序中，也就是用程序语言表示现实的事物。

现在问题是如何用程序语言来表示现实事物？现实世界的事物所具有的共性就是每个事物都具有自身的属性，一些自身具有的行为，所以如果我们能够把事物的属性和行为表示出来，那么就可以抽象出来这个事物。

**封装：**对现实事物的属性和行为进行抽象，然后用程序语言实现

表示人这个对象，在C语言中，可以表示为：

```c
typedef struct _Person{
    char name[64];
    int age;
}Person;
typedef strutc _Animal{
    char name[64];
    int age;
    int type;
}Animal;
void PersonEat(Person* person){
    printf("%s 在吃人吃的饭\n", person->name);
}
void AnimalEat(Animal* animal){
    printf("%s 在吃动物吃的饭\n", animal->name);
}

void test01()
{
    Person* bob;
    strcpy(bob->name, "bob");
    PersonEat(bob); 
    
}

```

**C语言中表示事物存在的问题**

​	C语言中表示事物时，将属性和行为分离，可能出现调用出错

**在C++中对事物的封装 ，将属性和行为封装在一起**

```c++
struct Person{
    //属性
	int age;
    char name[23];
    void Eat()
    {
        printf("人在吃人的东西\n");
    }
};
struct Dog{
    int age;
    char name[23];
    int type;
    volid Eat(){
        printf("狗在吃狗吃的东西\n");
    }
};

int main()
{
    Person person;
    Dog dog;
    person.Eat();
    dog.Eat()
}
```

1. 类中所有的成员默认为私有的，但是可以修改成员的访问属性
2. C++结构体中的成员默认是公有的

### 成员设置权限

C++中的三种访问控制权限：`private` `public` `protect`

1. `public`: 公有的，类内和类外皆可访问
2. `private`：私有的，只有类内的成员可以访问，类外不可以访问，子类不可以访问
3. `protect`：保护的，类内的成员可以访问，以该类为基类公有继承的子类访问，类外不可以访问

**尽量将成员变量设置为private**

1. 将成员变量设置为公有的缺陷是 类外可以随时无控制地修改成员变量
2. 将成员变量设置为私有的优点在于
   - 对变量设置时的控制
   - 给变量设置只读权限
   - 给变量设置只写权限
   - 给变量设置读写权限

```c++
class AccessLevels{
public:
    //对只读属性进行只读访问
    int getReadOnly(){return readOnly;}
    //对读写属性进行读写访问
    int getReadWrite(){return readWrite;}
    void setReadWrite(int rw){ readWrite = rw;}
    //对只读属性进行只读访问
    void setWriteOnly(int wo){wirteOnly = wo;}
private:
    int readOnly; // 对外只读访问
    int noAccess; //外部不可访问
    int readWrite; //读写访问
    int writeOnly;//只读访问
}
```

## 面向对象程序设计案例

### 设计立方体类

设计立方体类，求出立方体的表面积和体积，分别用全局函数和成员函数判断两个类是否相等.

```c++
#include <iostream>
#include <cstdlib>

using namespace std;

class cube{
public:
    cube(int l, int w, int h)
    {
        len = l;
        width = w;
        high = h;
    }
    //设置只读属性
    int getL(){return len;}
    int getW(){return width;}
    int getH(){return high;}
    //设置可写属性
    void setL(int l){len=l;}
    void setW(int w){width = w;}
    void setH(int h){high = h;}
    
    //计算cube表面积
    int getCubeS(){return 2*(len*width + width*high + high*len);}
   
    //计算cube的体积
    int getCubeV(){return len*width*high;}
    
    //比较两个立方体是否相等
    int CubeCmp(int l, int w, int h){return (l==len&&w==width&&h==high);}
    
private:
    int len;
    int width;
    int high;
};

int CubeCmp(cube cu1, cube cu2)
{
    return (cu1.getL()==cu2.getL()&&cu1.getW()==cu2.getW()&&cu1.getH()==cu2.getH());
}

void test01()
{
    cube cu1(10,20,30),cu2(10,13,15);
    //用cube的成员函数进行比较
    int ret = cu1.CubeCmp(cu2.getL(),cu2.getW(),cu2.getH());
    if(ret) 
    {
        cout<<"cu1和cu2是同一个立方体。"<<endl;
        cout<<"cu1和cu2的长宽高分别为:"<<endl;
        cout<<"len="<<cu1.getL()<<" width="<<cu1.getW()<<" high="<<cu1.getH()<<endl;
        cout<<"cu1和cu2的表面积和体积分别为："<<endl;
        cout<<"S="<<cu1.getCubeS()<<" V="<<cu1.getCubeV()<<endl;
    }else{
        cout<<"cu1和cu2不是同一个立方体。"<<endl;
        cout<<"cu1的长宽高分别为:"<<endl;
        cout<<"len="<<cu1.getL()<<" width="<<cu1.getW()<<" high="<<cu1.getH()<<endl;
        cout<<"cu1的表面积和体积分别为："<<endl;
        cout<<"S="<<cu1.getCubeS()<<" V="<<cu1.getCubeV()<<endl;
        cout<<endl;
        cout<<"cu2的长宽高分别为:"<<endl;
        cout<<"len="<<cu2.getL()<<" width="<<cu2.getW()<<" high="<<cu2.getH()<<endl;
        cout<<"cu2的表面积和体积分别为："<<endl;
        cout<<"S="<<cu2.getCubeS()<<" V="<<cu2.getCubeV()<<endl;
    }

    //对cu2重新赋值
    cu2.setL(cu1.getL());
    cu2.setW(cu1.getW());
    cu2.setH(cu1.getH());

    //用全局函数CubeCmp进行比较

    cout<<"****************************************"<<endl;
    ret = CubeCmp(cu1, cu2);
    ret = cu1.CubeCmp(cu2.getL(),cu2.getW(),cu2.getH());
    if(ret) 
    {
        cout<<"cu1和cu2是同一个立方体。"<<endl;
        cout<<"cu1和cu2的长宽高分别为:"<<endl;
        cout<<"len="<<cu1.getL()<<" width="<<cu1.getW()<<" high="<<cu1.getH()<<endl;
        cout<<"cu1和cu2的表面积和体积分别为："<<endl;
        cout<<"S="<<cu1.getCubeS()<<" V="<<cu1.getCubeV()<<endl;
    }else{
        cout<<"cu1和cu2不是同一个立方体。"<<endl;
        cout<<"cu1的长宽高分别为:"<<endl;
        cout<<"len="<<cu1.getL()<<" width="<<cu1.getW()<<" high="<<cu1.getH()<<endl;
        cout<<"cu1的表面积和体积分别为："<<endl;
        cout<<endl;
        cout<<"S="<<cu1.getCubeS()<<" V="<<cu1.getCubeV()<<endl;
        cout<<"cu2的长宽高分别为:"<<endl;
        cout<<"len="<<cu2.getL()<<" width="<<cu2.getW()<<" high="<<cu2.getH()<<endl;
        cout<<"cu2的表面积和体积分别为："<<endl;
        cout<<"S="<<cu2.getCubeS()<<" V="<<cu2.getCubeV()<<endl;
    }

}
int main()
{
    test01();
}

```

程序运行结果

[![LNV4ot.png](https://s1.ax1x.com/2022/04/17/LNV4ot.png)](https://imgtu.com/i/LNV4ot)

### 点和圆的关系

设计一个圆形类(`AdvCircle`)，和一个点类（`Point`），计算点和圆的关系。

1. 定在圆上：$(x_1-x_0)^2+(y_1-y_0)^2 = R^2$
2. 点在圆内：$(x_1-x_0)^2+(y_1-y_0)^2 < R^2$
3. 点在圆外：$(x_1-x_0)^2+(y_1-y_0)^2 > R^2$

```c++
#include <iostream>
using namespace std;

//定义一点类
class Point{
public:
    Point(int x, int y):mX(x),mY(y){}
 	void setX(int x){mX = x;}
    void setY(int y){mY = y;}
    int getX(){return mX;}
    int getY(){return mY;}
private:
    int mX;
    int mY;
};

//定义圆形类
class AdvCircle{
public:
    AdvCircle(int x, int y, int r):O(x,y)
    {
        R = r;
    }
    void setO(int x, int y)
    {
        O.setX(x);
        O.setY(y);
    }
    void setR(int r){R = r;}
    Point& getO(){return O;}
    int getR(){return R;}
    int IsPointInCircle(Point& point)
    {
        int dis = (point.getX()-O.getX())*(point.getX()-O.getX()) + (point.getY()-O.getY())*(point.getY()-O.getY());
        int rad = R*R;
        if(dis < rad) return -1;
        if(dis==rad) return 0;
        if(dis>rad) return 1;
    }
private:
    Point O;
    int R;
};

void test01()
{
    Point p(10,20);
    AdvCircle cir(13,24,4);
    int ret = cir.IsPointInCircle(p);
    if(ret == -1)
        cout<<"点在圆内"<<endl;
    else if(ret == 0)
        cout<<"点在圆上"<<endl;
    else if(ret == 1)
        cout<<"点在圆外"<<endl;
    
}
int main()
{
    test01();
}
```

程序运算结果：

[![LNm1II.png](https://s1.ax1x.com/2022/04/17/LNm1II.png)](https://imgtu.com/i/LNm1II)

## 对象的构造和析构

### 初始化和清理

我们大家在购买一台电脑或者手机，或者其他的产品，这些产品都有一个初始设置，也就是这些产品对被创建的时候会有一个基础属性值。那么随着我们使用手机和电脑的时间越来越久，那么电脑和手机会慢慢被我们手动创建很多文件数据，某一天我们不用手机或电脑了，那么我们应该将电脑或手机中我们增加的数据删除掉，保护自己的信息数据。

从这样的过程中，我们体会一下，所有的事物在起初的时候都应该有个初始状态，当这个事物完成其使命时，应该及时清除外界作用于上面的一些信息数据。

那么我们c++中O0思想也是来源于现实，是对现实事物的象模拟，具体来说，当我们创建对象的时候，这个对象应该有一个初始状态，当对象销毁之前应该销毁自己创建的一些数据。

对象的初始化和清理也是两个非常重要的安全问题，一个对象或者变量没有初始时，对其使用后果是未知，同样的使用完一个变量，没有及时清理，也会造成一定的安全问题。c++为了给我们提供这种问题的解决方案，构造函数和析构函数，这两个函数将会被编译器自动调用，完成对象初始化和对象清理工作。

无论你是否喜欢，对象的初始化和清理工作是编译器强制我们要做的事情，即使你不提供初始化操作和清理操作，编译器也会给你增加默认的操作，只是这个默认初始化操作不会做任何事，所以编写类就应该顺便提供初始化函数。

为什么初始化操作是自动调用而不是手动调用？既然是必须操作，那么自动调用会更好，如果靠程序员自觉，那
么就会存在遗漏初始化的情况出现。

**构造：**创建对象时，对对象进行初始化工作

**析构：**销毁对象时，对对象进行清理工作

一般需要人为提供，如果不提供，那么编译器也会提供，只是编译器提供的构造和析构函数不会做任何操作

创建对象和释放对象时，构造函数和析构函数自动会调用，不需要人为的调用

### 构造函数和析构函数

构造函数主要作用在于创建对象时为对象的成员属性赋值，构造函数由编译器自动调用，无须手动调用。

析构函数主要用于对象的销毁，在销毁前系统自动调用析构函数，执行一些清理工作

构造函数语法：

构造函数的函数名和类型相同，没有返回值，不能由void，但可以有参数，能重载

```c
class A{
    A(){cout<<"调用的时无参构造函数"<<endl;}//无参构造函数
    A(int a, int b){cout<<"调用的是有参构造函数"}
    //当显示的定义一个构造函数，就不会调用默认的构造函数
    //当声明一个没有参数的对象时，如果显示的定义了一个无参构造函数，就优先使用无参构造函数对对象进行初始化，否则调用默认构造函数
}
```

构造函数在实例化对象的时候被创建，在内存开辟空间的时候被调用

析构函数的语法

析构函数的函数名为类名并在类名的前面加个一'~'，析构函数没有返回值，不能够由参数，不能发生函数重载

```c++
class A{
    ~A(){}
};
```

在对象销毁之前自动析构函数

#### 总结：

构造函数：

- 没有返回值
- 函数名和类名一致
- 可以重载
- 创建对象时自动调用

析构函数：

- 没有返回值
- 函数名：`~类名`
- 没有参数
- 不可以重载
- 销毁对象时自动调用

### 构造函数的分类及调用

无参构造函数：调用无参构造函数时，不能加括号

有参构造函数

默认构造函数

拷贝构造函数

默认的拷贝构造函数

拷贝构造函数的定义` person(const person& p){age = p.age name = name.p}`

拷贝构造函数的调用时机：旧对象初始化新对象

无参构造和有参构造

普通构造和拷贝构造

注意：

- 当自定义了一个拷贝构造函数后，不会调用默认的拷贝构造函数

- 当显示的定义一个构造函数，就不会调用默认的构造函数
- 拷贝构造函数只是做了简单的值拷贝
- 如果显示的定义了一个有参构造函数，则无法使用无参构造进行调用。除非还定义了一个无参构造函数

**匿名对象**：没有名字的对象 声明周期在定义行

```c
Person(10,"lucy");//调用了有参构造函数定义了一匿名对象
Person();//调用无参构造函数定义了一个匿名对象
Person p1(20,"zhangsan");
//Person (p1);//定义匿名对象不能调用拷贝构造函数
```

**显示法调用构造函数**

```c++
Person p1 = Person(10, "lucy");//显示调用有参构造函数
Person p2 = Person(p1);//显示调用拷贝构造函数
Person p3 = Person();//显示调用无参构造函数
```

**隐式法调用构造函数**

```c++
Person p1 = {10,"lucy"};//隐式调用有参构造函数
Person p2 = p1;//隐式调用拷贝构造函数
//无法隐式调用无参构造函数
//用关键字explicit屏蔽隐式法调用构造函数
explicit Person(int a, char* b){}
```





### 拷贝构造函数的调用时机

总结：

1. 旧对象创建新对象
2. 函数返回局部对象，返回对象的时候调用了拷贝构造函数
3. 函数形参是一个普通对象

### 构造函数调用规则

默认情况下C++为类创建至少三个函数：

1. 默认构造函数(无参，函数体为空)
2. 默认析构函数(无参，函数体为空)
3. 默认拷贝构造哈桑农户，对于类中非静态成员属性简单值拷贝

如果用户定义拷贝构造函数，C++不会再提供任何默认构造函数

如果用户定义了普通构造函数(非拷贝)，C++不再提供默认无参构造，但会提供默认拷贝构造函数。

### 深拷贝和浅拷贝

#### 浅拷贝（值拷贝）

同一类型的对象之间可以赋值，使得两个对象的成员变量的值相同，两个对象仍然是独立的两个对象，这种情况被称为浅拷贝。

一般情况下，浅拷贝没有任何副作用，但是当类中有指针，并且指针指向动态分配的内存空问，析构函数做了动态内存释放的处理，会导致内存问题。

```c++
class Person{
public:
    int age;
    char* name;
    Person(int a, char* n)
    {
        age = a;
        name = (char*)malloc(strlen(n)+1);
        strcpy(name, n);
    }
    void show()
    {
        cout<<age<<" "<<name<<endl;
    }
    ~Person()
    {
        if(name != NULL)
        {
            free(name);
            name = NULL;
        }
    }
};
void test()
{
    Person p(10,"bob");
    Person p1(p);//调用拷贝构造函数, 对象p1的析构函数会出错
}
```

[![LNdrzF.md.png](https://s1.ax1x.com/2022/04/17/LNdrzF.md.png)](https://imgtu.com/i/LNdrzF)

#### 深拷贝(完全拷贝)

```c++
class Person{
public:
    int age;
    char* name;
    Person(int a, char* n)
    {
        age = a;
        name = (char*)malloc(strlen(n)+1);
        strcpy(name, n);
    }
    Person(const Person &p)
    {
        age = p.age;
        name = (char*)malloc(strlen(p.name)+1);
        strcpy(name, p.name);
    }
    void show()
    {
        cout<<age<<" "<<name<<endl;
    }
    ~Person()
    {
        if(name != NULL)
        {
            free(name);
            name = NULL;
        }
    }
};
void test()
{
    Person p(10,"bob");
    Person p1(p);//调用拷贝构造函数, 成员变量name重新开辟空间
}
```

[![LNwuy4.md.png](https://s1.ax1x.com/2022/04/17/LNwuy4.md.png)](https://imgtu.com/i/LNwuy4)

### 多个对象构造和析构

#### 初始化列表

`person(int a, int b, int c):m_a(a),m_b(b),m_c(c)` 先声明后定义初始化，定义的顺序和声明的顺序一致

`person(int a, int b, int c){m_a=a;m_b=b;m_c=c;}` 先定义后初始化

#### 类对象作为成员

在类中定义的数据成员一般都是基本的数据类型。但是类中的成员也可以是对象，叫做对象成员。

C++中对对象的初始化是非常重要的操作，当创建一个对象的时候，C++编译器必须确保调用了所有子对象的构造函数。如果所有的子对象有默认构造函数，编译器可以自动调用他们。但是如果子对象没有默认的构造函数，或者想指定调用某个构造函数怎么办？

那么是否可以在类的构造函数直按调用子类的属性完成初始化呢？但是如果子类的成员属性是私有的，我们是没有办法访问并完成初始化的。

解决办法非常简单：对于子类调用构造函数，c++为此提供了专门的语法，即构造函数初始化列表。

当调用构造函数时，首先按各对象成员在类定义中的顺序（和参数列表的顺序无关）依次调用它们的构造函数，对这些对象初始化，最后再调用本身的函数体。也就是说，先调用对象成员的构造函数，再调用本身的构造函数。

析构函数和构造函数调用顺序相反，先构造，后析构。

在类中声明的对象的顺序就决定了对象的构造函数的调用顺序，从而决定析构函数的调用顺序。

- 当一个类中有多个对象成员的时候，先调用对象成员的构造函数再调用本类的构造函数
- 当一个类中有多个对象成员的时候，先调用本类的析构函数再调用对象成员的析构函数

```c++
#include <iostream>
#include <string>
using namespace std;

class game{
public:
    game(string a):g_name(a){cout<<"game的构造函数"<<endl;}
    string g_name;
    ~game(){cout<<"game的析构函数"<<endl;}
};
class phone{
public:
    phone(string a):ph_name(a){cout<<"phone的构造函数"<<endl;}
    string ph_name;
    ~phone(){cout<<"phone的析构函数"<<endl;}
};
class person{
public:
    person(string a, string b, string c):mpe(a),mg(b),mph(c){cout<<"person的构造函数"<<endl;}
    
    string mpe;
    game mg;
    phone mph;
    
    ~person(){cout<<"person的析构函数"<<endl;}
    
};

void test()
{
    person p("bob","LOL","xiaomi");
}
int main(){test();}

```

运行结果：

[![LUClzd.png](https://s1.ax1x.com/2022/04/17/LUClzd.png)](https://imgtu.com/i/LUClzd)

### explicit关键字

explicit用于修饰构造函数，防止隐式转化，是针对单个参数的构造函数（或者除了第一个参数外其余参数都是默认参数的多参构造函数）

```c++
class MyString{
public:
    explicit MyString(int n){cout<<"MyString(int n)!"<<endl;}
    MyString(const char* str){cout<<"MyString(const char* str)"<<endl;
};
int main()
{
    //MyString str1 = 1;//由于构造函数MyString(int n)被关键字explicit修饰，所以不能够隐式调用该构造函数
    MyString str2(10);
    
    MyString str3 = "abcd";
    MyString str4("abcd");
}
```



## 动态对象创建

当我们创建数组的时候，总是需要提前预定数组的长度，然后编译器分配预定长度的数组空间，在使用数组的时，会有这样的问题，数组也许空间太大了，浪费空间，也许空间不足，所以对于数组来讲，如果能根据需要来分配空间大小再好不过。所以动态的意思意味着不确定性。为了解决这个普遍的编程问题，在运行中可以创建和销毁对象是最基本的要求。当然c早就提供了动态内存分配(dynamic memory allocation).,函数malloc和free可以在运行时从堆中分配存储单元。然而这些函数在c++中不能很好的运行，因为它不能帮我们完成对象的初始化工作。

### 对象创建

当创建一个c++对象时会发生两件事：

1. 为对象分配内存
2. 调用构造函数来初始化那块内存
   第一步我们能保证实现，需要我们确保第二步一定能发生。c++强迫我们这么做是因为使用未初始化的对象是程序出错的一个重要原因。

#### C动态分配内存方法

为了在运行时动态分配内存，c在他的标准库中提供了一些函数，malloc以及它的变种calloc和realloc,释放内存的free,这些函数是有效的,但是原始的，需要程序员理解和小心使用。为了使用c的动态内存分配函数在
堆上创建一个类的实例，我们必须这样做：

```c++
class person{
public:
    int mAge;
    char* pName;
    person()
    {
        cout<<"person无参构造函数"<<endl;
        mAge = 20;
        pName = (char*)malloc(sizeof("john")+1);
        strcpy(pName, "john");
    }
    void Init()
    {
        cout<<"person的初始化函数"<<endl;
        mAge = 20;
        pName = (char*)malloc(sizeof("john")+1);
        strcpy(pName, "john");
    }
    void Clean()
    {
        cout<<"person的清理函数"
        mAge = 0;
        if(pName!=NULL)
        {
            free(pName);
            pName=NULL;
        }
    }
    ~person(){cout<<"person的析构函数"<<endl;}
}
int main()
{
    person *p = (person*)malloc(sizeof(person));//不会调用构造函数和析构函数
    //因此需要用另外的函数对p进行初始化和清理
    p.Init();//对p的成员变量进行初始化
    p.Clean();//对p的成员变量进行清理
    free(p);
}
```

用malloc和free函数去动态的申请对象和释放对象，不会调用构造函数

#### C++动态内存分配方法（new和delete）

`类型* 对象名/变量名 = new 匿名对象/基本类型`

1. 用new和delete申请和释放基本类型的空间 

​		`int * p = new int`      `delete p`

​		`char *p = new char`     `delete p`

​		`float *p = new float`    `delete p`

​		`long long *p = new long long`     `delete p`

​		`short *p =new short`     `delete p`

​		`long *p = new long`     `delete p`

​		`double *p = new double`    `delete p`

2. 用new和delete申请和释放对象的空间

​		无参构造函数 `person *p = new person`    `delete p`

​		有参构成函数 `person *p = new person("bob", 20)`     `delete p`

​		对象数组 `person *p = new person[10]`	 `delete []p`			

​		new对象数组时不能调用有参构造，只能调用无参构造

3. 用new和delete申请和释放数组空间

​		`int *p = new int[10]`  `delete []p`

4. `void*` 型的对象在`delete`的时候是不会调用对象的析构函数

### 使用new和delete采用相同形式

```c++
Person*person new Person[10];
delete person;
```

以上代码有什么问题吗？(s下直接中断、qt下析构函数调用一次)

使用了new也搭配使用了delete,问题在于Person有10个对象，那么其他9个对象可能没有调用析构函数，也就是说其他9个对象可能删除不完全，因为它们的析构函数没有被调用。

我们现在清楚使用new的时候发生了两件事：

一、分配内存；

二、调用构造函数

那么调用delete的时候也有两件事：

一、析构函数；

二、释放内存

那么刚才我们那段代码最大的问题在于：person指针指向的内存中到底有多少个对象，因为这个决定应该有多少个析构函数应该被调用。换句话说，person指针指向的是一个单一的对象还是一个数组对象，由于单一对象和数组对象的内存布局是不同的。更明确的说，数组所用的内存通常还包括“数组大小记录”，使得delete的时候知道应该调用几次析构函数。单一对象的话就没有这个记录。单一对象和数组对象的内存布局可理解为下图：

[![LUZ4qH.png](https://s1.ax1x.com/2022/04/17/LUZ4qH.png)](https://imgtu.com/i/LUZ4qH)

new单一对象时，使用delete释放单一的对象

new一个数组时，使用delete []释放这个数组

## 内嵌类

内嵌类有两种类型：内联（inner）类和静态内嵌（[static](https://so.csdn.net/so/search?q=static&spm=1001.2101.3001.7020) nested）类。

c++嵌套类等同于内部类的概念，定义嵌套类的目的是为了隐藏信息，提高代码的抽象能力，相当与在内部为外部类提供了一种新的类型。

查阅了相关资料，发现内嵌类有两种类型：内联（inner）类和静态内嵌（static nested）类。但是经过个人测试并没有太大差异，所以现将使用方法及注意要点作出总结如下。

**1. 内嵌类可以访问定义在外围类（enclosing class）中的静态实例变量。外围类不可以访问嵌套类的私有成员.**

**2. 不能从内嵌类中访问外部类的非静态成员.**

**3. 可以在外部通过作用域限定符调用.**

**4. 通过类+作用域限定符创建对象**

**5. 它具有附加的访问限制**

### 内嵌类的作用

1. **隐藏实现细节，即把不想公开的东西，通过声明私有的内嵌类来实现，不仅可以隐藏实现细节，而且可以屏蔽其他的人使用它**
2. **`std::list`或者`std::map`它们都包含隐藏的类（或者它们是吗？）。关键是它们可能存在或不存在，但是因为实现是私有的并且是隐藏的，所以STL的构建者能够在不影响您使用代码的方式的情况下更新代码，或者因为需要它们而在STL周围留下了很多旧包。**
3. **将不需要的内容放置到内嵌类中进行隐藏，使类保持向后兼容**
4. **不会污染给定的名称空间**

## 静态成员

在类定义中，它的成员（包括成员变量和成员函数），这些成员可以用关键字static声明为静态的，称为静态成员。不管这个类创建了多少个对象，静态成员只有一个拷贝，这个拷贝被所有属于这个类的对象共享。

### 静态成员变量

在一个类中，若将一个成员变量声明为static，这种成员称为静态成员变量。与一般的数据成员不同，无论建立了多少个对象，都只有一个静态数据的拷贝。

- 静态成员变量，属于某个类，所有对象共享静态变量，是在编译阶段就分配空问，对象还没有创建时，就己经分配空问。

- 静态成员变量必须在类中声明，在类外定义。

- 静态数据成员不属于某个对象，在为对象分配空间中不包括静态成员所占空间。

- 静态数据成员可以通过类名或者对象名来引用。

```c++
class person{
public:
    int a;
    //静态成员变量不能在类内初始化，类内只声明 定义在全局 声明的作用只是限制静态成员变量作用域
    static int b;//是一个静态成员变量 在编译阶段就分配好的内存
    
};
person::a =10;//类中静态成员变量的定义

void test()
{
    cout <<"person::b="<<person::b<<endl;
    person p1;
    p1.b = 100;
    person p2;
    cout <<"p1.b="<<p1.b <<endl;
    cout <<"p2.b="<<p2.b <<endl;
    cout <<"person::b="<<person::b<<endl;
    
}
void test02()
{
    //通过类的作用域访问类的静态成员变量
    cout<<person::b<<endl;
}
```



### 静态成员函数

在类定义中，前面有static说明的成员函数称为静态成员函数。静态成员函数使用方式和静态变量一样，同样在对象没有创建前，即可通过类名调用。静态成员函数主要为了访问静态变量，但是，不能访问普通成员变量。静态成员函数的意义，不在于信息共享，数据沟通，而在于管理静态数据成员，完成对静态数据成员的封装。

- 静态成员函数只能访问静态变量，不能访问普通成员变量

- 静态成员函数的使用和静态成员变量一样

- 静态成员函数也有访问权限

- 普通成员函数可访问静态成员变量、也可以访问非静态成员变量

```c++
class person{
public:
    int a;
    //静态成员变量不能在类内初始化，类内只声明 定义在全局 声明的作用只是限制静态成员变量作用域
    static int b;//是一个静态成员变量 在编译阶段就分配好的内存
    void show()
    {
        cout <<a<<" "<<b<<endl;//普通成员函数可以访问静态成员变量
    }
    static void static_show()
    {
        //cout<<a<<endl;//错误， 静态成员函数不可以访问普通成员变量
        cout<<b<<endl;//正确。静态成员函数只可以访问静态成员变量
    }
};
void test()
{
    //可以通过类名直接调用类的静态成员函数
    person::static_show();
    person p1;
    //可以通过对象调用静态成员函数
    p1.static_show();
}
```

### const静态成员变量

const修饰的静态成员变量是存放在常量区，不可修改，在内存中只有一份

const修饰的静态成员变量可以在类内定义和初始化

const修饰的静态成员变量可以通过类的作用域访问

const修饰的静态成员变量可以通过对象访问

静态成员函数可以访问const修饰的静态成员变量

```c++
class person{
public:
    int a;
    //静态成员变量不能在类内初始化，类内只声明 定义在全局 声明的作用只是限制静态成员变量作用域
    static int b;//是一个静态成员变量 在编译阶段就分配好的内存
    const static int c=1000;//const修饰的静态成员变量是存放在常量区，不可修改，在内存中只有一份
    void show()
    {
        cout <<a<<" "<<b<<endl;//普通成员函数可以访问静态成员变量
    }
    static void static_show()
    {
        //cout<<a<<endl;//错误， 静态成员函数不可以访问普通成员变量
        cout<<b<<endl;//正确。静态成员函数只可以访问静态成员变量
        cout<<c<<endl;//正确
    }
};
void test()
{
    cout<<person::c<<endl;
}
```

### 静态成员实现单例模式

单例模式是一种常用的软件设计模式。在它的核心结构中只包含一个被称为单例的特殊类。通过单例模式可以保证系统中一个类只有一个实例而且该实例易于外界访问，从而方便对实例个数的控制并节约系统资源。如果希望在系统中某个类的对象只能存在一个，单例模式是最好的解决方案。

Singleton(单例)：在单例类的内部实现只生成一个实例，同时它提供一个静态的getlnstance()工厂方法，让客户可以访问它的唯一实例；为了防止在外部对其实例化，将其默认构造函数和拷贝构造函数设计为私有；在单例类内部定义了一个Singleton类型的静态对象，作为外部共享的唯一实例。

实现的步骤：

1. 将无参构造私有化
2. 拷贝构造私有化
3. 定义一个静态的成员指针变量指向new出来的一个唯一对象
4. 将静态的成员指针私有化，提供获得唯一对象的地址的接口，该结构是一个静态的成员函数，通过类作用域来调用

```c++
class Feifei
{
public:
    int age;
    int yanzhi;
    static Feifei * instance(){return single}
private:
    static Feifei *single;
    Feifei(){}//无参构造私有化后，一个对象都创建不出来
    Feifei(const Feifei& p){}
};
Feifei * Feifei::single = new single;

void test03()
{
    Feifei * p = Feifei::instance();
    p->age = 10;
    p->yanzhi = 20;
    Feifei *p1 = Feifei::instance();
    cout<<p1->age<<" "<<p2->yanzhi<<endl;
}

void test02()
{
    Feifei::single->age = 100;
    Feifei::single->yanzhi = 100;
    Feifei p1(*Feifei::single);//调用拷贝构造实例化出一个对象
}
void test01()
{
    Feifei p1;//需要调用无参构造
    Feifei p2;
}
```



用单例模式，模拟公司员工使用打印机场景，打印机可以打印员工要输出的内容，并且可以累积打印机使用次数。

## C++对象模型初探

### 成员变量和函数的存储

在c语言中，“分开来声明的，也就是说，语言本身并没有支持“数据”和“函数”之间的关联性，我们把这种程序方法称为“程序性的”，由一组“分布在各个以功能为导航的函数中”的算法驱动，它们处理的是共同的外部数据。

c++实现了“封装”，那么数据（成员属性）和操作（成员函数）是什么样的呢？

“数据”和“处理数据的操作（函数）”是分开存储的。

c+中的非静态数据成员直接内含在类对象中，就像c struct一样。

成员函数(member function)虽然内含在class声明之内，却不出现在对象中。

每一个非内联成员函数(non-inline member function)只会诞生一份函数实例.

- 空类的大小为1，不是0

- 静态成员不存在类实例化的对象中

- 普通成员函数不存在类实例化的对象中
- 普通成员变量占用对象空间的大小

### this指针

#### this指针工作原理

通过上例我们知道，c++的数据和操作也是分开存储，并且每一个非内联成员函数(non-inline member function)只会诞生一份函数实例，也就是说多个同类型的对象会共用一块代码

那么问题是：这一块代码是如何区分那个对象调用自己的呢？

[![LUwFER.png](https://s1.ax1x.com/2022/04/17/LUwFER.png)](https://imgtu.com/i/LUwFER)

类的成员函数编译器默认都加了一个this指针指向调用的对象。

[![LUBB90.png](https://s1.ax1x.com/2022/04/17/LUBB90.png)](https://imgtu.com/i/LUBB90)

### this指针的使用

```C++
class person{
public:
    int a;
    int b;
    person(int a, int b)
    {
        this->a = a;
        this->b = b;
    }
    person person_add(person &p2)const
    {
    	person p(this->age+p2.age, this->name+p2.name);
    	return p;
    }
}
```



### const修饰的成员函数

- 在函数的后面加上const，这个是一个常函数
- 这个const修饰的是this指针`const type * const this`代表不能通过this指针去修改this指针指向对象的内容

```c++
/*
常函数 不能通过this指针修改this指针指向的内容
常量指针常量 const person* const this;
*/
person person_add(person &p2)const
{
    //this->age=200;//出错，此时的this指着是一个常量指针常量
    person p(this->age+p2.age, this->name+p2.name);
    return p;
}
```

this指针本身是一个指针常量

## 友元

类的主要特点之一是数据隐藏，即类的私有成员无法在类的外部（作用域之外）访问。但是，有时候需要在类的外部访问类的私有成员，怎么办？

解决方法是使用友元函数，友元函数是一种特权函数，c++允许这个特权函数访问私有成员。

这一点从现实生活中也可以很好的理解：

比如你的家，有客厅，有你的卧室，那么你的客厅是Pubc的，所有来的客人都可以进去，但是你的卧室是私有的，也就是说只有你能进去，但是呢，你也可以允许你的闺蜜好基友进去。

程序员可以把这个全局函数、某个类中的成员函数和类声明为友元

### 友元语法

- friend关键字只出现在声明处。

- 其他类、类成员函数、全局函数都可声明为友元

- 友元函数不是类的成员，不带this指针

- 友元函数可访问对象任意成员属性，包括私有属性

```c++
class Building;
//友元类
class MyFriend{
public:
    //友元成员函数
    void LookAtBedRoom(Building& building);
    void PlayInBeadRoom(Building& building);
};
class Building{
    //全局函数做友元函数
    friend void CleanBedRoom(Building& building);
#if 0
    //成员函数做友元函数
    friend void MyFriend::LookAtBedRoom(Building& building);
    friend void MyFriend::PlayInBedRoom(Building& building);
#else 
    //友元类
    friend class MyFriend;
#endif
};
```



### 全局函数成为类的友元

```c++
class Building
{
    friend void print_Building(Building &b);
public:
    Building(string hall, string bedroom)
    {
        this->badroom = bedroom;
        this->hall = hall;
    }
    string hall;
private:
    string bedroom;
}
void print_Building(Building &b)
{
    cout<<b.hall<<" "<<b.bedroom<<endl;
}
void test01()
{
    Building b("凌霄殿","闺房");
}
```

### 课堂练习

请编写电视机类，电视有开机和关机状态，有音量，有频道，提供音量操作的方法，频道操作的方法。由于电视机只能逐一调整频道，不能指定频道，指定遥控器类，遥控器除了拥有电视已有的功能，再添加根据输入调台功能。

提示：遥控器可以作为一个友元类

```c++
class Remote;
class Televison
{
    friend class Remote;
public:
    enum{off, on};//电视机状态
    enum{minVol, maxVol=100};//音量0-100
    enum{minChannel=0, maxChannel=255;} //频道0-255
    Televvison()
    {
        mState = off;
        mVol = minVol;
        mChannel = maxVol;
    }
    //打开或关闭电视
    void OnOrOff()
    {
        this->mState = (this->mState==on)?off:on;
    }
    //加音量
    void AddVol()
    {
        this->mVol = (this->mVol==maxVol)?maxVol:(this->mVol+1);
    }
    //减音量
    void SubVol()
    {
        this->mVol = (this->mVol==minVol)?minVol:(this->mVol-1);
    }
    //加频道
    void AddChannel()
    {
        this->mChannel = (this->mChannel+1)%maxChannel;
    }
    //减频道
    void SubChannel()
    {
       this->mChannel = (this->mChannel==minChannel)?maxChannel:(this->mChannel-1);
    }
private:
    int mState;
    int mVol;
    int mChannel;
};
class Romote
{
public:
    //打开或关闭电视
    void Romote_OnOrOff(Televison &tel)
    {
        tel.OnOrOff();
    }
    //加音量
    void Romote_AddVol(Televison &tel)
    {
        tel.AddVol();
    }
    //减音量
    void Romote_SubVol(Televison &tel)
    {
        tel.SubVol();
    }
    //加频道
    void Romote_AddChannel(Televison &tel)
    {
        tel.AddChannel();
    }
    //减频道
    void Romote_SubChannel(Televison &tel)
    {
       tel.SubChannel();
    }
    
    void SetChannel(Televison &tel, int channel)
    {
        tel.mChannel = channel; 
    }
}
```

## 数组封装

```c++
//用户接口
1. 根据指定的位置添加元素
2. 获取指定位置的元素
3. 尾插法插入数据
4. 获取数组长度
//属性
1. 数组的容量 capacity
2. 数组的大小 size
3. 指向数组的指针 pAddress
```

## 运算符重载

### 运算符重载基本概念

运算符重载，就是对已有的运算符重新进行定义，赋予其另一种功能，以适应不同的数据类型。

运算符重载(operator overloading)只是一种"语法上的方便”，也就是它只是另一种函数调用的方式。

在c++中，可以定义一个处理类的新运算符。这种定义很像一个普通的函数定义，只是函数的名字由关键字operator及其紧跟的运算符组成。差别仅此而己。它像任何其他函数一样也是一个函数，当编译器遇到适当的模式时，就会调用这个函数。

语法：

定义重载的运算符就像定义函数，只是该函数的名字是operator(@,这里的@代表了被重载的运算符。函数的参数中参数个数取决于两个因素。

运算符是一元（一个参数）的还是二元（两个参数）；

运算符被定义为全局函数（对于一元是一个参数，对于二元是两个参数）还是成员函数（对于一元没有参数，对于二元是一个参数-此时该类的对象用作左耳参数)

[两个极端]

有些人很容易滥用运算符重载。它确实是一个有趣的工具。但是应该注意，它仅仅是一种语法上的方便而己，是另外一种函数调用的方式。从这个角度来看，只有在能使涉及类的代码更易写，尤其是更易读时（请记住，读代码的机会比我们写代码多多了)才有理由重载运算符。如果不是这样，就改用其他更易用，更易读的方式。

对于运算符重载，另外一个常见的反应是恐慌：突然之间，C运算符的含义变得不同寻常了，一切都变了，所有C代码的功能都要改变！并非如此，对于内置的数据类型的表达式的运算符是不可能改变的。（例如想重载it类型数据的+号)

练习1：重载加号运算符

练习2：重载左移运算符

### 运算符重载遇到友元

当需要对象直接使用类的私有成员参与运算，可以将重载运算符函数声明为该类的友元

```c++
class person
{
    friend ostream& operator<<(ostream &cout, person &p);
public:
    person(int age){this->age  = age;}
private:
    int age;    
}
ostream& operator<<(ostream &cout, person &p)
{
    cout<<p.age;
    return cout;
}
void test
```

### 可重载的运算符

`+`    `-`    `*`    `/`     `%`    `^`    `&`     `|`     `~`      `!`     `=`     `<`     `>`     `+=`     `-=`     `*=`     `/=`    `%=`    `^=`  `&=` `|=`     `<<`    `>>`  `<<=`    `>>=`    `==`    `!=`    `<=`    `>=`    `&&`     `||`      `++`     `--`     `->*`     `'`         `->`    `[]`    `()`    `new `     `delete`   `new[]`     `delete[]`

### 不可重载的运算符

`.`    `::`   `.*`    `?:`    `sizeof`

### 重载自加自减运算符

`++a`先加后使用

`a++`先使用后加

- 前置自增返回的是引用
- 后置自增返回的是对象
- 前置自增调用`type& operator++()`
- 后置自增调用`type operator++(int)`

重载自加运算符

```c++
class person
{
   friend ostream& operator<<(ostream& pout,person &p)
public:
    person(int age){this->age = age;}
    person& operator++()
    {
        this->age +=1;
        return *this;
    }
    person operator++(int)
    {
        person tmp = *this;
        // 做自增操作
        this->age+=1;
        
        return tmp;
    }
private:
    int age;
}

ostream& operator<<(ostream& pout,person &p)
{
    pout<<p.age;
    return pout;
}
void test01()
{
    person p(10);
    pout<<p<<endl;
    ++p;
    cout<<p<<endl;
    cout<<p++<endl;
    cout<<p<<endl;
}
```

### 指针运算符(*、->)重载

#### 智能指针

我们经常new一个对象，忘记释放，所以我们使用只能指针来维护

智能指针实质是一个局部对象，这个局部对象维护了new出来的对象的地址，在局部对象的析构函数中，会帮助释放new出来的对象。

对于智能指针我们重载了`->`和`*`让智能指针和普通指针一样使用。

```c++
class person
{
public:
    person(int age)
    {
        this->age = age;
    }
    int age;
};
class Smartpointer
{
 public:
    Smartpointer(person *p)
    {
        this->p = p;
    }
    ~Smartpointer()
    {
        delete p;
        cout<<"释放了p"<<endl;
    }
    person* operator->()
    {
        return p;
    }
    person operator()
    {
        return *p;
    }
    person *p;
};
void test01()
{
    //局部对象在释放之前可以帮忙释放p
    person *p = new person(10);
    Smartpointer sp(p);
    cout<<p->age<<endl;
    cout<<sp->age<<endl;// sp.operator->()
    cout<<(*sp).age<<endl;// sp.operator*()
    //忘记释放p指向申请的对象
}
```

### 赋值运算符的重载

编译器默认给每一个类加上了4个函数

- 默认无参构造函数
- 默认拷贝构造函数
- 析构函数
- operator=()

```c++
class person
{
    public:
    person(){}
    person(int age, char* name)
    {
        this->age =age;
        this->name = new char[strlen(name)+1];
        strcpy(this->name, name);
    }
    ~person()
    {
        delete []name;
    }
    //默认的operator=()只做了浅拷贝
   /*
    person& operator=(person& p)
    {
        this->age = p.age;
        this->name = p.name;
        return *this;
    }
    */
    
    //修改默认的operator=()让其做深拷贝
    person& operator=(person& p)
    {
        this->age = p.age;
        this->name = new char[strlen(p.name)+1];
        strcpy(this->name, p.name);
       return *this;
    }
    
    int age;
    char* name;
};

voide test01()
{
    person p1(20, "bob");
    person p2;
    p2 = p1;//有一个等号赋值重载函数p2.operator=(p1)
    cout<<p2.age<<" "<<p2.name<<endl;
}
```

### 重载等于和不等于符号

```c++
class person
{
public:
    person(){}
    person(int age, string name)
    {
        this->age = age;
        this->name = name;
    }
    bool operator==(person &p)
    {
        return (this->age==p.age&&this->name==p.name)
    }
    bool operator!=(person &p)
    {
        return this->age!=p.age||this->age!=p.name
    }
    int age;
    string name;
}

void test01()
{
    person p1(10,"lucy");
    person p2(10,"bob");
    
}
```

### 函数对象(重载()运算符)

```c++
class Myadd
{
public:
    int add(int a, int b)
    {
        return a+nb;
    }
    int operator()(int x, int y)
    {
        return x+y;
    }
};
void test()
{
    //Myadd::add(3,5);//出错
    Myadd p;
    cout<<p.add(3,5)<<endl;
    //p()  可以像函数一个调用的对象 函数对象
    cout<<p(3,5)<<endl;//重载小括号p.operator(3,5)
    cout<<Myadd()(3,5)<<endl;//Myadd()是一个匿名对象 Myadd().operator()(3,5)
}
```

### 不要重载&&、||

不能重载operator&&和operator‖的原因是，无法在这两种情况下实现内置操作符的完整语义。说得更具体些，内置版本版本特殊之处在于：内置版本的&&和首先计算左边的表达式，如果这完全能够决定结果，就无需计算右边的表达式了-而且能够保证不需要。我们都已经习惯这种方便的特性了。

我们说操作符重载其实是另一种形式的函数调用而己，对于函数调用总是在函数执行之前对所有参数进行求值。

```c++
class Complex
{
public:
    Complex(int flag)
    {
        this->flag = flag;
    }
    Complex& operator+=(Complex& complex)
    {
        this->flag+=complex.flag;
        return *this;
    }
    bool operator&&(Complex& complex)
    {
        return this->flag&&complex.flag;
    }
    int flag;
}

void test()
{
    Complex com1(0);
    Complex com2(1);
    //com1.operator&&(com1.operator+=(com2))
    if(com1&&(com1+=com2))//按照内置的逻辑运算，此结果应该为0，而按照自定重载运算，此结果为1
    {
        cout<<"真"<<endl;
    }else cout<<"假"<<endl;
}
```

### 符号重载总结

=，[]，()和->操作符智能通过成员函数进行重载

<<和>>只能通过全局函数配合友元函数进行重载

不要重载&&和||操作符，因为无法是实现短路规则

| 运算符                                | 建议使用                 |
| ------------------------------------- | ------------------------ |
| 所有的一元运算符                      | 最好用成员函数进行重载   |
| = () [] -> ->*                        | 必须用成员函数进行重载   |
| += -= /= *= ^= &= \|= != %=  >>=  <<= | 最好用成员函数进行重载   |
| 其他二元运算符                        | 最好用非成员函数进行重载 |

### 字符串类的封装

在头文件MyString.h中

```c++
class MyString
{
    friend ostream& operator<<(ostream& cout, MyString& str);
    friend istream& operator>>(istream& cin, MyString& str);
public:
    MyString(const char*);
    MyString(const MyString&);
    ~MyString();
    
    char& operator[])(int index);//[]重载
    //赋值号重载
    MyString& operator=(const char* str);
    MyString& operator=(const MyString& str);
    //字符串拼接 重载+号
    MyString operator+(const char* str);
    MyString operator+(const MyString& str);
    //字符串比较
    bool operator==(const char* str);
    bool operator==(const MyString& str);
private:
    char* pString;//指向堆空间
    int m_Size;//字符串长度 不算'\0'
    
}
```

在源文件MyString.cpp中

```c++
#include "MyString.h"
#include <iostream>
#include <cstring>
using namespace std;

ostream& operator<<(ostream& cout, MyString& str)
{
    cout<<str.pString;
    return cout;
}
istream& operator>>(istream& cin, MyString& str)
{
    if(str.pString!=NULL)
    {
        delete []str.pString;
        str.pString = NULL;
    }
    char buf[1024];
    cin>>buf;
    str.pString = new char[strlen(buf)+1];
    strcpy(str.pString, buf);
    str.m_size = strlen(buf);
    return cin;
}

MyString::MyString(const char* str)
{
    this->pString = new char [strlen(str)+1];
    strcpy(this->pString, str);
    this->m_Size = strlen(str);
}
MyString::MyString(const MyString& str)
{
    this->pString = new char[str.m_Size+1];
    strcpy(this->pString, str.pString);
    this->m_Size = str.m_Size;
}
~MyString::MyString()
{
    if(this->pString!=NULL)
    {
        delete []this->pString;
    }
}
char& MyString::operator[])(int index)//[]重载
{
    return this->pString[index];
}
//赋值号重载
MyString& MyString::operator=(const char* str)
{
    if(this->pString!=NULL)
    {
        delete []this->pString;
        this->pString = NULL;
    }
    this->pString = new char [strlen(str)+1];
    strcpy(this->pString, str);
    this->m_Size = strlen(str);
    return *this;
}
MyString& MyString::operator=(const MyString& str)
{
    if(this->pString!=NULL)
    {
        delete []this->pString;
        this->pString = NULL;
    }
    this->pString = new char [str.m_Size+1];
    strcpy(this->pString, str.pString);
    this->m_Size = str.m_Size;
    return *this;
}
//字符串拼接 重载+号
MyString MyString::operator+(const char* str)
{
    int newSize = this->m_Size + strlen(str)+1;
    char *tmp = new char[newSize];
    memset(tmp,0,newSize);
    strcat(tmp, this->pString);
    strcat(tmp, str);
    Mystring newString(tmp);
    delete []temp;
    return newString;
}
MyString MyString::operator+(const MyString& str)
{
    int newSize = this->m_Size + str.m_Size + 1;
    char *tmp = new char[newSize];
    memset(tmp,0,newSize);
    strcat(tmp, this->pString);
    strcat(tmp, str.pString);
    Mystring newString(tmp);
    delete []temp;
    return newString;
}
//字符串比较
bool MyString::operator==(const char* str)
{
    return (strcmp(this->pString, str)==0&&this->m_Size==strlen(str))?true:false;
}
bool MyString::operator==(const MyString& str)
{
    return (strcmp(this->pString, str.pString)==0&&this->m_Size==str.m_Size)?true:false;
}
```

## 继承（拷贝）

### 继承的基本概念

c+最重要的特征是代码重用，通过继承机制可以利用已有的数据类型来定义新的数据类型，新的类不仅拥有旧类的成员，还拥有新定义的成员。一个B类继承于A类，或称从类A派生类B。这样的话，类A成为基类（父类），类B成为派生类（子类）。

派生类中的成员，包含两大部分：一类是从基类继承过来的，一类是自己增加的成员。从基类继承过过来的表现其共性，而新增的成员体现了其个性。

### 派生类的定义

```c++
class 派生类: 继承方式 基类名{};
继承方式：共有继承(public) 保护继承(protect) 私有继承(private)
//基类
class Animal{
public:
    int age;
    void print()
    {
        cout<<age<<endl;
    }
};
class Dog: public Animal{
public:
    int tail_len;
};

void test01()
{
    Dog g;
}
```

### 派生类访问控制

派生类继承基类，派生类拥有基类中全部成员变量和成员方法（除了构造和析构之外的成员方法），但是在派生类中，继承的成员并不一定能直接访问，不同的继承方式会导致不同的访问权限。

派生类的访问权限规则如下：

- 公有继承 基类中的成员是什么控制权限，继承到子类后还是什么控制权限。
- 保护继承 将父类的公有权限变成保护权限，其他权限不变。
- 私有继承 将父类的公有权限和保护权限变成私有权限。



```c++
class Base
{
public: 
    int a;
protected:
    int b;
private:
    int c;
};
//公有继承 基类中的成员是什么控制权限，继承到子类后还是什么控制权限
class A: public Base
{
public:
    int d;
    void show()
    {
        cout<<a<<endl;//子类可以访问父类的公有成员
        cout<<b<<endl;//子类可以访问父类的保护成员
        cout<<c<<endl;//子类不可以访问父类的私有成员
    }
};
//保护继承 将父类的公有权限变成保护权限
class B: protected Base
{
public:
    int d;
    void show()
    {
        cout<<a<<endl;//保护继承 将父类的公有权限变成保护权限, 子类仍然可以访问
        cout<<b<<endl;//子类可以访问父类的保护成员
        cout<<c<<endl;//子类不可以访问父类的私有成员
    }
}
//私有继承 将父类的公有权限和保护权限变成私有权限
class C:private Base
{
public:
    int d;
    void show()
    {
        cout<<a<<endl;//私有继承 将父类的公有权限变成私有权限, 子类不可以访问
        cout<<b<<endl;//私有继承 将父类的保护权限变成私有权限, 子类不可以访问
        cout<<c<<endl;//子类不可以访问父类的私有成员
    }
    
}
void test01()
{
    A a;
    a.a;//公有的 可以访问
    a.b;//保护的 不可以访问
    a.c;//私有的 不可以访问
}
void test02()
{
    B b;
    // 保护继承 将父类的公有权限变成保护权限
    b.a;//保护成员 不可以访问
    b.b;//保护成员 不可以访问
    b.c;//私有成员 不可以访问
}
void test02()
{
    B c;
    // 私有继承 将父类的公有权限和保护权限变成私有权限
    c.a;//私有成员 不可以访问
    c.b;//私有成员 不可以访问
    c.c;//私有成员 不可以访问
}
```

### 继承中的对象模型

在C++编译器的内部可以理解为结构体，子类是是由父类成员叠加子类新成员而成：

[![L0SFLn.png](https://s1.ax1x.com/2022/04/19/L0SFLn.png)](https://imgtu.com/i/L0SFLn)

### 对象构造和析构的调用原则

继承中的构造和析构

- 子类对象在创建时会首先调用父类的构造函数

- 父类构造函数执行完毕后，才会调用子类的构造函数

- 当父类构造函数有参数时，需要在子类初始化列表（参数列表）中显示调用父类构造函数

- 析构函数调用顺序和构造函数相反

### 继承中同名成员的处理方法

- 当子类成员和父类成员同名时，子类依然从父类继承同名成员

- 如果子类有成员和父类同名，子类访问其成员默认访问子类的成员（本作用域，就近原则）

- 在子类通过作用域::进行同名成员区分（在派生类中使用基类的同名成员，显示使用类名限定符）

```c++
class Parent
{
public:
    int a,b;
    Parent(int a, int b)
    {
        this->a = a;
        this->b = b;
        cout<<"父类的构造函数"<<endl;
    }
    ~Parent(){cout<<"父类的析构函数"<<endl;}
    void show()
    {
        cout<<"这是父类的show函数"<<endl;
    }
    void parent_show()
    {
       // 在子类通过作用域::进行同名成员区分（在派生类中使用基类的同名成员，显示使用类名限定符）
        parent::show();
    }
}
class Son:public Parent
{
public:
    int a,c;
    Son(int a1, int a2, int a3, int a4):Parent(a1,a2)
    {
        a = a3;
        a = a4;
    }
    ~Son(){}
    //当子类成员和父类成员同名时，子类依然从父类继承同名成员
    void show()
    {
        cout<<"这是子类的show函数"<<endl;
    }
}
void test()
{
    //声明一个子类对象
    Son son(1,2,3,4);
    //如果子类有成员和父类同名，子类访问其成员默认访问子类的成员
    son.show();//输出  这是子类的show函数
    son.Parent::show();//输出 这是父类的show函数
    son.parent_show();//输出  这是父类的show函数
}
输出结果：
    父类的构造函数
    子类的构造函数
    这是子类的show函数
    这是父类的show函数
    这是父类的show函数
    这是子类的析构函数
    这是父类的析构函数
```

### 非自动继承的函数

不是所有的函数都能自动从基类继承到派生类中。构造函数和析构函数用来处理对象的创建和析构操作，构造和析构函数只知道对它们的特定层次的对象做什么，也就是说**构造函数和析构函数不能被继承**，**必须为每一个特定的派生类分别创建**。

另外**operator=也不能被继承**，**因为它完成类似构造函数的行为**。也就是说尽管我们知道如何由=右边的对象如何初始化=左边的对象的所有成员，但是这个并不意味着对其派生类依然有效。

在继承的过程中，如果没有创建这些函数，编译器会自动生成它们

### 多继承

#### 多继承概念

我们可以从一个类继承，我们也可以能同时从多个类继承，这就是多继承。

但是由于多继承是非常受争议的，从多个类继承可能会导致函数、变量等同名导致较多的歧义。

定义：`class C: public A, public B{};`

```c++
class A{public: int a;};
class B{public: int b;};
class C: public A, public B{public: int c;};

void test01()
{
    C p;
    cout<<a<<" "<<b<<" "<<c<<endl;
}
```

#### 菱形继承和虚继承

菱形继承

[![L0AIiR.png](https://s1.ax1x.com/2022/04/19/L0AIiR.png)](https://imgtu.com/i/L0AIiR)

虚继承

```c++
class Animal
{
public:
    int age;
};
class Sheep:virtual public Animal
{
public:
    int id;
}
class Camel:virtual public Animal
{
public:
    int camel_num;
}
class Alpaca:public Sheep, public Camel
{
public:
    int a;
}

void test()
{
    Alpaca p;
    p.age=0;
}
```

#### 虚继承的实现原理

vs中查看类的内存分配情况

```
1. 打开vs的工具：命令提示符for vs
2. 对文件进行编译
3. 跳转到文件所在目录
4.  cl /d1 reportSingleClassLayoutAnimal main.cpp
```

[![L00FwF.png](https://s1.ax1x.com/2022/04/19/L00FwF.png)](https://imgtu.com/i/L00FwF)

## 多态

### 多态的继承概念

多态是面向对象程序设计语言中数据抽象和继承之外的第三个基本特征。

多态性(polymorphism)提供接口与具体实现之间的另一层隔离，从而将”what"和"how分离开来。多态性改善了代码的可读性和组织性，同时也使创建的程序具有可扩展性，项目不仅在最初创建时期可以扩展，而且当项目在需要有新的功能时也能扩展。

C++支持编译时多态（静态多态）和运行时多态（动态多态），运算符重载和函数重载就是编译时多态，而派生类和虚函数实现运行时多态。

静态多态和动态多态的区别就是函数地址是早绑定（静态联编）还是晚绑定（动态联编）。如果函数的调用，在编译阶段就可以确定函数的调用地址，并产生代码，就是静态多态（编译时多态），就是说地址是早绑定的。而如果函数的调用地址不能编译不能在编译期间确定，而需要在运行时才能决定，这这就属于晚绑定（动态多态，运行时多态）。

```c++
class Animal
{
public:
   virtual void speak(){cout<<"动物在讲话"<<endl;}
};
class Dog:public Animal
{
public:
    void speak(){cout<<"狗在讲话"<<endl;}
};
void do_work(Animal &obj)
{
    obj.speak();
}
void test01()
{
    Animal p1;
    do_work(p1);
    
    Dog p2;
    do_work(p2);
}
```

发生多态的四个条件：

- 父类有虚函数
- 必须发生继承
- 子类重写虚函数（函数的返回值 参数 函数名一样）
- 父类的指针或引用指向了子类的对象

### 多态实现计算器

```c++
#include <iostream>
using namespace std;
class Calc
{
public:
    virtual int mycalc(int a, int b)
    {
        return 0;
    }
};

class Add:public Calc
{
public:
    int mycalc(int a, int b)
    {
        return a+b;
    }
};

class Sub:public Calc
{
public:
    int mycalc(int a, int b)
    {
        return a-b;
    }
};

class Mul:public Calc
{
public:
    int mycalc(int a, int b)
    {
        return a*b;
    }
};

int do_work(int a, int b, Calc& obj)
{
    return obj.mycalc(a,b);
}

void test02()
{
    Add p;
    do_work(2,3,p);
    Sub p1;
    do_work(2,3,p1);
}
```

### C++如何实现动态绑定

动态绑定什么时候发生？所有的工作都是由编译器在幕后完成。当我们告诉通过创建一个tu函数来告诉编译器要进行动态绑定，那么编译器就会根据动态绑定机制来实现我们的要求，不会再执行早绑定。

问题：C++的动态捆绑机制是怎么样的？

首先，我们看看编译器如何处理虚函数。当编译器发现我们的类中有虚函数的时候，编译器会创建一张虚函数表把虚函数的函数入口地址放到虚函数表中，并且在类中秘密增加一个指针，这个指针就是pointer(缩写yptr),这个指针是指向对象的虚函数表。在多态调用的时候，根据r指针，找到虚函数表来实现动态绑定。

```c++
class Animal
{
public:
   virtual void speak(){cout<<"动物在讲话"<<endl;}
};
class Dog:public Animal
{
public:
    void speak(){cout<<"狗在讲话"<<endl;}
};
void do_work(Animal &obj)
{
    obj.speak();
}
void test01()
{
    Animal p1;
    do_work(p1);
    
    Dog p2;
    do_work(p2);
}
```

[![LBlWtK.png](https://s1.ax1x.com/2022/04/19/LBlWtK.png)](https://imgtu.com/i/LBlWtK)

### 抽象基类和纯虚函数(pure virtual function)

在设计时，常常希望基类仅仅作为其派生类的一个接口。这就是说，仅想对基类进行向上类型转换，使用它的接口，而不希望用户实际的创建一个基类的对象。同时创建一个纯虚函数允许接口中放置成员原函数，而不一定要提供一段可能对这个函数毫无意义的代码。

做到这点，可以在基类中加入至少一个纯虚函数(pure virtual function),使得基类成为抽象类(abstract class).

- 纯虚函数使用关键字virtual,并在其后面加上=0。如果试图去实例化一个抽象类，编译器则会阻止这种操作。

- 当继承一个抽象类的时候，必须实现所有的纯虚函数，否则由抽象类派生的类也是一个抽象类。

- Virtual void fun()=0;告诉编译器在vftable中为函数保留一个位置，但在这个特定位置不放地址。

建立公共接口目的是为了将子类公共的操作抽象出来，可以通过一个公共接口来操纵一组类，且这个公共接口不需要事先（或者不需要)完全实现，可以创建一个公共类。

>- 纯虚函数就是虚函数等于0，其本质是将虚函数表中的入口函数地址置为NULL
>- 有纯虚函数的类叫做抽象类
>- 抽象类不可实例化
>- 子类继承抽象类，如果不实现所有的纯虚函数，否则该子类仍然是一个抽象类

### 纯虚函数和多继承

多继承带来了一些争议，但是接口继承可以说一种毫无争议的运用了。

绝大数面向对象语言都不支持多继承，但是绝大数面向对象对象语言都支持接口的概念，c++中没有接口的概念，但是可以通过纯虚函数实现接口。

接口类中只有函数原型定义，没有任何数据定义。

多重继承接口不会带来二义性和复杂性问题。接口类只是一个功能声明，并不是功能实现，子类需要根据功能说
明定义功能实现。

注意：在抽象类中，除了析构函数外，其他声明都是纯虚函数。

### 虚析构函数

为了解决基类的指针指向派生类对象，并用基类的指针删除派生类对象

在调用基类的析构函数之前先调用子类的析构函数

### 纯虚析构函数

虚析构函数等于0

纯虚析构函数在c++中是合法的，但是在使用的时候有一个额外的限制：必须为纯虚析构函数提供一个函数体。

那么问题是：如果给纯虚虚析构函数提供函数体了，那怎么还能称作纯虚析构函数吗？

纯虚析构函数和非纯析构函数之间唯一的不同之处在于纯虚析构函数使得基类是抽象类，不能创建基类的对象。

### 重写 重载 重定义

**重载**，同一作用域的同名函数

1. 同一个作用域

2. 参数个数，参数顺序，参数类型不同

3. 和函数返回值，没有关系

4. const也可以作为重载条件/do(const Teacher&t)0do(Teacher&t

**重定义（隐藏）**

1. 有继承

2. 子类（派生类）**重新定义**父类（基类）的同名成员（非virtual函数）

**重写（覆盖）**

1. 有继承

2. 子类（派生类）**重写**父类（基类）的virtual函数

3. 函数返回值，函数名字，函数参数，必须和基类中的虚函数一致
