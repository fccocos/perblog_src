---
title: 07_C++_异常
date: 2022/4/18/ 14:00
categories:
  - 计算机科学
tags:
  - 嵌入式
  - C++语言
  - 笔记
sticky: true
valine:
  placeholder: "1. 提问前请先仔细阅读本文档⚡\n2. 页面显示问题💥，请提供控制台截图📸或者您的测试网址\n3. 其他任何报错💣，请提供详细描述和截图📸，祝食用愉快💪"
---



# C++异常

## 异常的基本概念

Bjarne Stroustrup说：提供异常的基本目的就是为了处理上面的问题。基本思想是：**<u>让一个函数在发现了自己无法处理的错误时抛出(throw)一个异常，然后它的（直接或者间接）调用者能够处理这个问题。</u>**也就是《c+primer》中说的：将问题检测和问题处理相分离。

一种思想：在所有支持异常处理的编程语言中（例如java),要认识到的一个思想：在异常处理过程中，由问题检测代码可以抛出一个对象给问题处理代码，通过这个对象的类型和内容，实际上完成了两个部分的通信，通信的内容是“出现了什么错误”。当然，各种语言对异常的具体实现有着或多或少的区别，但是这个通信的思想是不变的。

## 异常的基本语法

```c++
int mydiv(int a, int b)
{
    if(b == 0)
        throw 'a';//抛出异常 抛出一个类型
    return a+b
}
void test01()
{
    //尝试捕获异常
    try
    {
        mydiv(2,0);
    }
    catch(char)//如果没有捕获抛出的异常 程序会终止
    {
        cout<<"捕获了一个char类型的异常";
        throw 'a';
    }
}
int main()
{
    try
    {
        test01();
    }
    catch(char)
    {
        cout<<"test01有一个char类型的异常"<<endl;
    }
}
```

## 异常类型严格匹配

```c++
int mydiv(int a, int b)
{
    string str="ddd";
    if(b == 0)
        throw str;//抛出异常 抛出一个类型
    return a+b
}
void test01()
{
    //尝试捕获异常
    try
    {
        mydiv(2,0);
    }
    catch(char)//如果没有捕获抛出的异常 程序会终止
    {
        cout<<"捕获了一个char类型的异常";
    }
    catch(int)
    {
        cout<<"捕获了一个int类型的异常";
    }
    catch(double)
    {
        cout<<"捕获了一个double类型的异常";
    }
    catch(...)
    {
        cout<<"捕获了一个其他类型的异常";
    }
}
int main()
{

        test01();

}
```

## 栈解旋

异常被抛出后，从进入try块起，到异常被抛掷前，这期间在栈上构造的所有对象，都会被自动析构。析构的顺序与构造的顺序相反，这一过程称为栈的解旋(unwinding).

## 异常接口

为了加强程序的可读性，可以在函数声明中列出可能抛出异常的所有类型，例如：void func()throw(A,B,C); 这个函数func能够且只能抛出类型A,B,C及其子类型的异常。

如果在函数声明中没有包含异常接口声明，则此函数可以抛任何类型的异常，例如：void func()一个不抛任何类型异常的函数可声明为：void func()throw()如果一个函数抛出了它的异常接口声明所不允许抛出的异常，unexcepted函数会被调用，该函数默认行为调用terminate函数中断程序。

```c++
//抛出所有异常
void TestFunc01()
{
    throw 10;
}

//只抛出int char char*类型异常
void TestFunc02() throw(int,char,char*)
{
    string exception = "error";
    throw exception;
}

//不抛出任何异常
void TestFunc03() throw()
{
    throw 10;
}

void test()
{
    try
    {
        TestFunc01();
        TestFunc02();
        TestFunc03();
    }
    catch(...)
    {
        cout<<"有异常"<<endl;
    }
    system("pause");
    
}


```

## 异常变量的生命周期

throw的异常是有类型的，可以是数字、字符串、类对象。

throw的异常是有类型的，catch需严格匹配异常类型。

最好用匿名对象抛出， 他的生命周期在catch里面

```c++
class exception
{
public:
    exception(){cout<<"构造"<<endl;}
    ~exception(){cout<<"析构"<<endl;}
    void error(){cout<<"error"<<endl;}
}
void fun01()
{
    exception e;
    throw e;
}
void fun02()
{
    throw exception();
}

//情况一
void test01()
{
    cout<<"情况一"<<endl;
    try
    {
        fun01();
    }
    catch(exception &e)
    {
        e.error();
    }
}
//情况二
void test02()
{
     cout<<"情况二"<<endl;
    try
    {
        fun02();
    }
    catch(exception &e)
    {
        e.error();
    }
}
//情况三
void test03()
{
     cout<<"情况三"<<endl;
    try
    {
        fun01();
    }
    catch(exception e)
    {
        e.error();
    }
}
//情况四
void test04()
{
     cout<<"情况四"<<endl;
    try
    {
        fun02();
    }
    catch(exception e)
    {
        e.error();
    }
}
```



## 异常的多态使用

```c++
class exception
{
public:
    virtual viod error()=0;
};
class Out_of_range
{
public:
    virtual void error()
    {
        cout<<"out of range"<<endl;
    }
};
class Bad_cast
{
public:
    virtual void error()
    {
        cout<<"out of range"<<endl;
    }
};

void fun01()
{
    throw Out_of_range();
}
void fun02()
{
    throw Bad_cast();
}
void test01()
{
   try
   {
       fun01();
       
   }
    catch(exception &p)
    {
        p.error();
    }
}
void test02()
{
   try
   {
       fun02();
       
   }
    catch(exception &p)
    {
        p.error();
    }
}
```

## C++标准异常库

### 标准库介绍

标准库中提供了很多的异常类，他们是通过类继承组织起来的。异常继承层级结构图

[![LsuepD.jpg](https://s1.ax1x.com/2022/04/20/LsuepD.jpg)](https://imgtu.com/i/LsuepD)

- 在上述继承体系中，每个类都提供了构造函数，拷贝构造函数，析构函数和赋值运算符的重载。

- logic_error类以及其子类、runtime_error类以及其子类，他们的构造函数接收一个string类型的参数，用于异常信息的描述。

- 所有的异常都有一个what方法，返回  const char* 类型的值，描述异常信息。

**exception的直接派生类：**

| 异常名称          | 描述                                                         |
| ----------------- | ------------------------------------------------------------ |
| exception         | 所有标准类的父类                                             |
| bad_alloc         | 当operator new 和operator new[] 请求内存分配失败时。         |
| bad_exception     | 这是个特殊的异常，如果函数的异常列表里声明了 bad_exception 异常，当函数内部抛出了异常列表中没有的异常时，如果调用的 unexpected() 函数中抛出了异常，不论什么类型，都会被替换为 bad_exception 类型。 |
| bad_typeid        | 使用 typeid 操作一个 NULL 指针，而且该指针是带有虚函数的类，这时抛出 bad_typeid 异常。 |
| bad_cast          | 使用 dynamic_cast 转换失败时抛出的异常。                     |
| ios_base::failure | io 过程中出现的异常。                                        |
| logic_error       | 逻辑错误，可以在运行前检测的错误                             |
| runtime_error     | 运行时错误，只在运行时才可以检测的错误                       |

**logic_error的派生类：**

| 异常名称         | 描述                                                         |
| ---------------- | ------------------------------------------------------------ |
| range_error      | 计算结果超出了有意义的值域范围。                             |
| overflow_error   | 算术计算上溢。                                               |
| underflow_error  | 算术计算下溢。                                               |
| invalid_argument | 参数不合适。在标准库中，当利用string对象构造bitset时，而string中的字符不是'o或'1'的时候，抛出该异常 |

我们以`out_of_range`异常为例，来看一下它具体的使用方法，需要包含头文件`<stdexcept>`

### 自己编写异常类

```c++
#include <expection>
#include <iostream>
#include <stdexcept>
#include <string>

using namespace std;
class Longlongerror:public exception
{
public:
    Longlongerror(string data)
    {
        this->data = data;
    }
    Longlongerror(char* data)
    {
        this->data = data;
    }
    const char* what()const
    {
        return data.c_str();
    }
    string data;    
}

void fun()
{
    throw Longlongerr("longlongerror");
}
void test01()
{
    try
    {
        fun()
    }
    catch(exception &e)
    {
        e.what
    }
}

```

