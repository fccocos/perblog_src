---
title: 03_C++_对C的扩展
date: 2022/4/17/ 8:00
categories:
  - 计算机科学
tags:
  - 嵌入式
  - C++语言
  - 笔记
sticky: true
valine:
  placeholder: "1. 提问前请先仔细阅读本文档⚡\n2. 页面显示问题💥，请提供控制台截图📸或者您的测试网址\n3. 其他任何报错💣，请提供详细描述和截图📸，祝食用愉快💪"
---



# 第三章  C++对C的扩展

## `::`作用域运算符

`::`作用域运算符是一个作用域，如果`::`之前没有加东西，表示全局作用域

```c++
#include <iostream>
using namespace std;
int a = 100;//定义一个全局变量
void test01()
{
    int a=10;//全局变量
    cout<<a<<endl;//根据向上就近原则，打印 10
    cout<<::a<<endl;//"::"之前没有加任何东西，表示为全局作用域
    	            //因此会打印 100
}
```

## 名字控制

C++允许我们对名字的产生和名字的可见性进行控制

在C++中将通过一种通过命名空间来控制名字的访问

### C++命名空间(namespace)

标准C++引入关键字`namespace`可以更好地控制标识符的作用域，最大程度地避免命名冲突。

`namespace`的本质就是一个作用域

### c++命名空间的使用

1. 命名空间的定义 ，必须定义在全局范围
2. 命名空间中可以存放 变量、类、 结构体、 函数、 类等
3. 命名空间可以重名，重名的命名空间相当于做合并操作
4. 命名空间可以嵌套
5. 在命名空间中声明的函数，在命名空间外定义时，需要添加命名空间和作用域运算符
6. 无名命名空间中的标识符只能够在本文本内访问，相当于给这些在无名空间中的标识符加上了static，使得其可以作为内部链接
7. 命名空间取别名 `namespace newname = oldname;`

```c++
#include <iostream>
using namespace std;
//只能在全局区定义命名空间
namespace A
{
    int a=10;
}
namespace B
{
    //命名空间中可以存放 变量、类、 结构体、 函数、 类等
    int a=20;
    int b=20;
    void fun(){cout<<"this is namespace B"<<endl;}
    struct std{};
    class s{};
    //命名空间可以嵌套
    namespace C
    {
        int a = 100;
    }
}
//命名空间可以重名，重名的命名空间相当于做合并操作
namespace A
{
    int a=20;
    int b=30;
    int c=40;
}
void test01()
{
    cout<<"A::a = "<<A::a<<endl;// 20
    cout<<"B::a = "<<B::a<<endl;// 20 
    cout<<"B::b = "<<B::b<<endl;// 20；
    cout<<"B::C::a = "<<B::C::a<<endl;// 100
    B::fun();//打印 "this is namespace B"
}
int main()
{
    
}
```

### using的声明

using可以使得指定命名空间的标识符可用

注意：当using声明的标识符和其他标识符有作用域的冲突时，会产生二义性

```c++
#include <iostream>
using namespace std;

namespace nameA
{
    itn a = 10;
    void foo()
    {
        cout<<"hello using"<<endl;
    }
}

void test01()
{
    cout << nameA::a<<endl;
 using nameA::a;
    cout<<a<<endl;
 using nameA::foo;
    foo();
}
int main()
{
    
}
```

### using的编译指令

using的编译指令使整个命名空间可用

使用using的编译指令的标识符与其他的同名标识符不会产生二义性，它会遵循就近原则

```c++
#include <iostream>
using namespace std;

namespace nameA
{
    int a =100;
    void fun(){cout << "hello using" <<endl; }
}

void test()
{
    //using的编译指令使整个命名空间可用
    using namespace nameA;
    cout<<"nameA::a = "<<a<<endl;
    //使用using的编译指令的标识符与其他的同名标识符不会产生二义性，它会遵循就近原则
    int a = 1000;
    cout <<"a = "<<a<<endl;
}
```

### 命名空间的使用注意事项

当标识符之间有二义性（冲突）的时候，直接使用`命名空将+::+标识符`

## c++中全局变量检查

C++的编译器对于全局变量的声明和定义有严格的区分，检测会增强，而C语言下的全局变量的声明和定义没有区分

C语言下的全局变量的声明和定义

```c
//全局变量
int a;//定义
int a;//声明
int a;//声明
```

C++语言中的全局变量的声明和定义

```c++
//全局变量
int a;
extern int a;
extern int a;
```

C++语言下的全局变量的声明和定义，如果写成以下形式，编译器百编译不会通过

```c++
//全局变量
int a;
int a;
int a;
```

## C++所有的变量和函数都必须有类型

C++中形参必须有类型，返回值和形参个数会做检测

C语言中的函数的形参可以不写，没有返回值可以返回值，实参的个数不会检测

```c
void fun(x,y){return 100;}//c语言中合法的

int main()
{
    //合法
    fun(1);
    fun(1,2);
    fun(1,2,3);      
}
```

C++语言中函数的形参类型必须写，没有返回值不可以返回，实参的个数做检查

```c++
void fun(x,y)//编译器报错，形参没有类型
{
    return 100;//编译器报错，没有返回值，但是返回了
}
int main()
{
    fun(1);//实参个数与形参个数不一致
    fun(1,2);
    fun(1,2,3); //实参个数与形参个数不一致
}
```

## c++有更严格的类型转换

在C++中，不同类型的变量一般是不能直接赋值的，需要相应的强转

在C语言中

```c
#include <stdlib.h>
#include <stdio.h>
void test(){char *p = malloc(100);}//编译通过
```

在C++语言中

```c++
void test(){char *p = malloc(100);}//在c++中编译不通过，需要进行强制转换
//void test(){char *p=(char*)malloc(100);}
```

## C++对struct类型增强

在C++中使用结构体类型定义变量时，可以不写struct关键字

在C语言中：

```c
struct stu{
    int a;
}

struct stu xiaoming;
```

在C++中

```c++
struct stu{
    int a;
};
stu xiaoming ;
```



## C++中新增bool类型

在C语言中，以下代码需要包含`stdbool.h`头文件, 但是在C++中可以直接使用bool类型

```c
void test(){ bool flag = true;}
```

## C++三目运算符增强

在C++中三目运算符返回的是一个变量，在C语言中三目运算符返回的是一个常量

```c
(a<b?a:b)=100//在C语言中是不合法的，在C++是合法的。
```



## C/C++中的`const`

### `const`概述

`const`单词字面意思为常数，不变的。它是C/C++中的一个关键字，是一个限定符，它用来限定一个变量不允许改变，他将一个对象转换成一个常量

### C中的`const`

在C语言中`const`修饰的变量应该是一个只读变量，既然是变量就应该给`const`修饰的变量分配内存，并且在C中`const`是一个全局只读变量，C语言中`const`修饰的只读变量是外部连接的。

```c
const int arrSize =100;
int arr[arrSize];
```

以上代码看似合理，但是这里有一个致命的错误。因为`arrSize`在C语言中是一个变量，是变量就得占用某一块内存，所以C编译器不知道在编译的时候其值是多少

在C语言中，

`const`修饰的局部变量存放在栈区，虽然不可以直接通变量名去修改该变量的值，但是可以通过指针来修改该变量的值；

`const`修饰的全局变量存放在常量区，不可以修改该全局变量的值（通过指针也不行）；

`const`修饰的全局变量，如果外部文件想用，可直接用关键字`extern`将其声明为外部可用变量。

### C++中的`const`

1. `const`修饰的局部变量赋值常量时，局部变量保存在**符号表**中，是一个常量，不可修改
2. `const`修饰的全局变量保存在常量区，不可以修改
3. `const`修饰的全局变量默认是内部链接属性，只能被本文本使用，如果想要其他文本使用该全局变量，就必须把该变量的内部链接属性改为外部连接属性，即在变量前面加extern关键字进行修饰

```c++
//const修饰的全局变量默认是内部链接属性，只能被本文本使用
/*情况一*/const int num = 100;//此全局变量在另一个文件当中
//如果想要其他文本使用该全局变量，就必须把该变量的内部链接属性改为外部连接属性，即在变量前面加extern关键字进行修饰
/*情况二*/extern int num =100;
```



```c++
#include <isotream>
using namespace std;
const int b = 1;
void test03()
{
    extern const int num;//情况一会报错，情况二编译通过
}

void test02()
{
    //const修饰的全局变量存在于常量区
    int *p = (int*)&b;
    *p=100;//错误的
    
}
//c++中const修饰的局部变量
void test01()
{
    //在c++中const修饰的局部变量存在符号表中
    const int a = 100;
    int *p  = &a; //报错，类型不匹配 int* const int* 不匹配
    int *p = (int*)&a;//对const修饰的局部变量取地址 编译器会产生一个临时变量来保存a的地址 int temp = a; int *p =&tmp;
    *p = 100;
}
```

### C和C++中的`const`的异同

**相同点**：

C和C++中的`const`修饰的局部变量都是保存在常量区，不能修改

**不同点**：

C语言中`const`修饰的局部变量赋值为常量，局部变量保存在栈区，可以被指针修改

C++中，`const`修饰的局部变量赋值为常量时，局部变量保存在符号表中，不能被修改

C语言中`const`修饰的全局变量默认时外部连接属性

C++中从上图修饰的局部变量默认是内部来链接属性

### C++中`const`修饰的变量分配内存的情况

1. `const`修饰的全局变量在常量区分配了内存
2. `const`修饰的局部变量赋值为常量时，没有分配内存，存在于符号表当中
3. 对`const`修饰的局部变量为常量的变量取地址 会分配一个临时的空间 `int tmp = a; *p = &tmp;`
4. `const`修饰的局部变量赋值为变量时，局部变量存在栈区，可以通过指针来修改该变量的值
5. `const`修饰的局部变量为自定义的变量存放在栈区。

## 引用

### 引用的基本用法

引用的本质就是取别名

`原类型名 &别名 = 旧名`

```c++
#include <iostream>
using namespace std;

void test01()
{
    int a=10;
    //引用一旦初始化之后不能改变引用的标识
    int &b = a;
    b = 100;
    cout <<"a = "<<a<<endl;
    cout<<"b = "<< b <<endl;
    int c = 1;
    b = c;//代表把c的值赋给b，不是取别名
}
//给数组取别名
void test02()
{
    int a[5]={1,2,3,4,5}
    int (&arr)[5] = a;
    for(int i = 0; i < 5; ++i)
        cout<<"arr["<<i<<"] = "<<arr[i]<<endl;
}

int main()
{
    
}
```

**注意事项:**

1. &在引用中不是取地址符，而是起标识作用，标识当前变量是一个引用
2. 类型标识符是指目标变量的类型
3. 必须在声明引用变量时进行初始化
4. 引用初始化之后不能改变
5. 不能有NULL的引用。必须确保引用是和一块合法的存储单元关联。
6. 可以建立对数组的引用

**给数组取别名**

```c
int a[5];
int (&b)[5] = a;
```

### 函数中的引用

1. 引用可以作为函数的形参
2. 不能返回局部变量的引用

```c++
void swap(int *x, int *y)
{
    int tmp = *x;
    *x = *y;
    *y = tmp;
}
void swap_ref(int &x, int &y)
{
    int tmp = x;
    x = y;
    y = tmp;
}
void test01()
{
    int a = 10;
    int b = 20;
    swap(&a, &b);
    cout << "a="<<a<<" b="<<b<<endl;
}
void test01_ref()
{
    int a = 10;
    int b = 20;
    swap_ref(a, b);
    cout << "a="<<a<<" b="<<b<<endl;
}

void get_mem(int **q)
{
    *q = (int*)malloc(10*sizeof(int));
}
void get_mem_ref(int* &q)
{
    q = (int*)malloc(10*sizeof(int));
}
void test03()
{
    int *p = NULL;
    get_mem(&p);
    get_mem_ref(p);
}
int &test04()
{
    //能不能返回一个变量的引用 看这个变量的空间是否被释放了
    static int b = 100;
    int a = 10;
    //return a;//err 不能返回局部变量的引用
    return b;//可以返回静态变量的引用
}

```

### 引用的本质--指针常量

引用的本质在C++内部实现是一个指针常量，指针常量不能改变指针变量的指向，但能够修改指针指向的内容。

`Type &ref = val ` 等价于 `Type* const ref = &val`

```c++
#include <iostream>
using namespace std;
void test01()
{
    int a = 0;
    int &b = a;//编译优化  int* const b = &a
    //指针常量不能改变指针变量的指向
    
}

void fun(int* &q)//编译优化 int* &q ==>int* const  q = &q;
void test02()
{
    int *p = NULL;
    func(p);
}
```

### 指针的引用

`type * &q = p` 等价于 `type * * const q = &q`

const int * q //常指针，该指针指向的内容不可修改，即只读

### 常量引用

`const type & ref = val`

注意：字面量不能赋值给引用，但可以赋值给const引用，const修饰的引用不能修改。

const修饰的引用的时引用& 不能通过引用去修改引用的这块空间的内容

`const int &a = 1//是合法的`

## 内联函数

### 内联函数的引出

内联函数为了继承宏函数的效率，没有函数调用时的开销，然后又可以像普通函数那样，可以直接进行参数，返回值类型的安全检查，又可以作为成员函数

### 预处理宏的缺陷

预处理器宏存在问题的关键时我们可能认为预处理器的行为和编译器的行为一样的。当然也是由于宏函数调用和函数调用在外表看起来是一样的，因此也容易被混淆，但是其中也有一些微妙的问题出现

宏函数的替换是发生在预处理阶段

内联函数的替换发生在编译阶段

宏函数容易出错，内联函数不容易出错

内联函数和宏函数一样，都省去了函数调用的开销

### 内联函数的概念

在普通函数（非成员函数）前面加上关键字`inline`使该函数成为了内联函数，但是必须注意的是函数体和声明必须结合在一起，否则编译将它作为普通函数来对待。

`inline void func(int a);`

上述写法没有任何效果，仅仅是声明函数，应该如下方式来做

`inline int func(int a) {return ++a;}`

注意：编译器会检查函数的参数列表和返回值。这些事情预处理器无法实现。内联函数的确占用空间，但是内联函数相对于普通函数来说的优势在于省去了函数调用时的压栈、跳转、返回的开销，即用空间换时间

### 类内部的内联函数

类内部的成员函数编译器默认编译成内联函数

### 内联函数和编译器

对于任何类型的函数，编译器会将函数类型（包括函数名字，参数类型，返回值类型）放入到符号表中。

同样，但编译器看到内联函数的时候，并且对内联函数进行分析没有发现错误时，也会将内联函数放到符号表。

当调用一个内联函数的时候，编译器首先确保传入参数类型时正确匹配的，或者如果类型不完全匹配，但是可以将其转换为正确类型，并且返回值在目标表达式里匹配正确类型，或者可以转换为目标类型，内联函数就会直接替换函数调用，这就消除了函数调用的开销。

假如内联函数是成员函数，对象this指针也会被放入合适的位置。

类型检查和类型转换、包括在合适位置放入对象this指针等这些操作预处理器是不能完成的。

但是C++内联编译会有一些限制，以下情况编译器可能考虑不会将函数进行内联编译：

1. 不能存在任何形式的循环语句
2. 不能存在过多的条件判断语句
3. 函数体不能过于庞大
4. 不能对函数进行取地址操作

内联仅仅只是给编译器一种建议，编译器不一定会接受这种建议，如果没有将函数声明为内联函数，那么百年一起也可能将此函数内联编译，一个好的编译器会将内联小的、简单的函数。

## C++的默认参数

C++在声明函数原型的时候可为一个或多个参数指定默认（缺省）的参数值，当函数调用的时候如果没有指定值，编译器会自动用默认值替换

设置默认参数的时候，如果只有一个参数设置了默认参数，则后面的所有的参数都要设置默认参数

默认参数在设置时，只能在函数声明和函数定义中的任意一处设置默认参数

## C++函数中的占位参数

C++在声明函数时，可以设置占位参数。占位参数只有参数类型声明，而没有参数名声明，在函数体内部无法使用占位参数。

操作符重载的后置++就会用到占位参数。

```c++
void TestFun01(int a,int b, int)
{
    //函数内部无法使用占位参数
    cout << "a + b = " <<a+b<<endl;
}
//占位参数可以设置默认值
void TestFun02(int a, int b, int =20)
{
    //函数内部依然无法使用占位参数
    cout << "a + b = " <<a+b<<endl;
}

int main()
{
    //错误调用，占位参数必须传参
    //TestFun01(10,20);
    
    //正确调用
    TestFun01(10,20,30);
    TestFun02(10,20);
    TestFun02(10,20,30);
}
```

## C++的函数重载

### 函数重载概述

函数名相同，函数参数类型或函数参数个数不同的两个以上的函数，称为函数重载

### 函数重载基本语法

实现函数重载的条件：

1. 同一个作用域
2. 参数个数不同
3. 参数类型不同
4. 参数顺序不同
5. 返回值不能作为函数的重载条件
6. 引用、默认参数作为函数重载的条件需要注意二义性

```c++
//1. 函数重载的条件
namespace A{
    void MyFunc(){cout<<"无参数"<<endl;}
    void MyFunc(int a){cout<<"a = "<<a<<endl;}
    void MyFunc(string b){cout << "b="<<endl;}
    void MyFunc(int a, string b){cout<<"a="<<a<<" b="<<b<<endl;} 
    void MyFunc(string b, int a){cout<<"b="<<b<<" a="<<a<<endl;}
}
```



### 函数重载的本质

编译器为了实现函数重载，也是默认为我们做了一些幕后的工作，编译器用不同的参数类型来修饰不同的函数名，比如`void func()`编译器可能会将函数名修饰成`func`；当编译器碰到`void func(int x)`，编译器可能将函数名修饰为`funcint`；当编译器碰到`void func(int x, char c)`，编译器可能将函数名修饰为`funcintchar`；使用"可能"这个字眼是因为便起义如何修饰重载函数名称并没有一个统一的标准，所以不同的编译器可能产生不同的内部名。

```c
void func(){}
void func(int x){}
void func(int x, char c){}
```

以上三个函数在linux下编译之后的函数名为:

```c
_Z4funcv//v表示void,无参数
_Z4funci//i表示参数为int类型
_Z4funcic//i标识第一个参数为int类型，第二个参数为char类型
```

## extern "C"浅析

由于C和C++的编译器在编译函数后，生成的函数名是不同的，这是C++种调用一个C语言编写的函数，那么C++就会根据C++的名称修饰方式查找并链接该函数，此时会发生链接错误，因此为了是实现C++代码能够调用C编写的代码，就出现了`extern "C"`。加上`extern "C"`后，这部分代码编译器按照C语言的方式进行编译和链接，而不是按C++的方式。

方法一：

```c
extern "C" int MyFunc(int a, int b);
```

方法二：

```c
#if _cplusplus
extern "C"{
#endif
    int MyFunc(int a, int b);
#if _cplusplus
}
#endif
```

