# 可视化建模基础

## 建模的目的

☑建模的根本目的是为了更好地理解待开发的系统

​	◆模型有助于按照所需的样式**可视化(Visualize)**目标系统

​	◆模型能够**描述(Specify)**系统的结构和行为

​	◆模型提供**构造(Construct)**系统的模板

​	◆模型可以**文档化(Document)**设计决策

## 建模的基本原则

☑建模过程需要遵循的原侧

◆选择合适的模型：所创建的模型对解决方案的形成具有重要的
影响

◆模型具有不同的精确程度：面向不同的用户提供不同抽象层次
的模型

◆好的模型是与现实相联系的：简化不能掩盖掉任何重要的细节

◆单一的模型是不够的：需要从多个视角创建不同的模型

## 统一建模语言(UML)概述

Unified Modeling Language(统一建模语言)是对象管理组织(OMG)制定的一个**通用的**、**可视化**的**建模语言**标准，可以用来<u>可视化(visualize)</u>、<u>描述(specify)</u>、<u>构造(construct)</u>和<u>文档化(document)</u>软件密集型系统的各种工件(artifacts,又译制品)

☑UML一You Must Learn
☑UML一Unified Modeling Language
☑UML是一种标准的图形化建模语言，是面向对象分析与设
计的标准表示，它：
	◆不是一种程序设计语言，而是一种可视化的**建模语言**（用于分析
设计)
	◆不是工具或知识库的规格说明，而是一种建模语言规格说明，
是一种模型表示的**标准**
	◆不是过程，也不是方法，但允许任何一种过程和方法使用它

### 选择UML

☑很多情况下，推荐使用UML:

◆1)**OO方法**是项目决定采用的方法论，是整个项目或产品成功的关键

◆2)开发人员感觉用源码说明不了真正的问题，希望**提高交流效率**

◆3)系统的规模和设计都**比较复杂**，需要用图形抽象地表达复杂概念，
降低开发风险

◆4)组织希望**记录**已成功项目、产品的设计方案，在开发新项目时可
以参考、复用过去的设计

◆5)有必要采用一套**通用**的图形语言和符号体系描述组织的业务流程
和软件需求，促进业务人员、开发人员之间一致、高效的交流

### 不选择UML

☑UML不是万能，有些场合并不适合

◆1)传统的做法已**完全适用**，对面向对象技术的要求也不高，项
目非常成功，无任何改进的必要

◆2)开发的**系统比较简单**，直接用源码配上少量的文字就能解决
问题，软件开发文档也无需添加图形来辅助说明

◆3)开发的系统本身**不属于**OO方法、UML适用的范围

## UML组成结构和概念

### UML组成结构

☑从UML2开始，整个UML规范被划分成基础结构和上层结构
两个相对独立的部分

​	◆基础结构(Infrastructure)是UML的元模型，它定义了构造UML
​		模型的各种基本元素

​	◆上层结构(Superstructure)则定义了面向建模用户的各种UML
​		模型的语法、语义和表示

☑从UML2.5开始，为了消除冗余并简化UML规范，基础结构
	部分不再作为UML规范的一部分，UML元类在UML规范相
	应的章节中被完整地定义

### UML语法结构

☑UML的抽象语法使用UML元模型来定义

​	◆这个元模型本身也是用UML来定义（准确来说是一个受限的UML
​		子集，这个子集符合OMG的MOF规范)

​	◆在UML规范中，主要采用UML类图来描述各元素的抽象语法，采
​		用约束机制和自然语言（文本）来描述模型语义

### UML语义结构

☑UML自身的语义与被建模系统的UML模型上所声明的标准含义有关，	这有时被称为UML运行时语义

☑UML模型划分为两类语义域。

​	◆结构语义：定义了在建模域中关于个体的UML结构化模型元素的
​		含义，也称为静态语义

​	◆行为语义：定义了在建模域中关于个体如何随着时间变化而做
​		出不同行为的UML行为模型元素，也称为动态语义。

### UML语义域

![image-20220421202108043](.\pic\2_UML语义域.png)

### UML概念模型

![image-20220421202326711](.\pic\1_UML概念模型.png)

#### 构造块

☑构造块(building blocks)

​	◆事物(things)

​		 :large_orange_diamond:结构行为、分组、注释

​	◆关系(relationships)

​		:large_orange_diamond:依赖、关联、泛化、实现

​	◆图(diagram)

​		:large_orange_diamond:静态(7种)：类图、对象图、构件图、部署图、包图、组合结构图、外廓图

​		:large_orange_diamond:动态(7种)：顺序图、通信图、时间图、交互纵览图、活动图、状态机图、用例图

#### 事物(things)

☑结构(structural)事物：UML模型中的名词

​	◆模型的静态部分

​	◆用于描述概念元素或物理元素

​	◆常见的结构事物

​		:large_orange_diamond:类、接口

​		:large_orange_diamond:用例、协作

​		:large_orange_diamond:构件、工件、节点

☑行为(behavioral)事物：UML模型中的动词，表示跨越时间和空间的行为

​	◆交互、状态机、活动

☑分组(grouping)事物：用于将模型元素组织在一起

​	◆包(、框架、模型、子系统)

☑注释(annotational)事物：用来描述、说明或标注模型中的任何元素



![image-20220421203138184](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220421203138184.png)



![image-20220421203248063](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220421203248063.png)

#### 通用机制

☑规格说明(Specifications)

​	◆文本维度的模型描述

☑修饰(Adornments)

​	◆描述建模元素的细节信息

☑通用划分(Common Divisions)

​	◆建模时对事物的划分方法

☑扩展机制(Extensibility Mechanisms)

​	◆构造型、约束、标记值

##### 规格说明(Specifications)

☑UML模型至少具有两种维度：

​	◆图形维度：使用图和图标可视化模型

​	◆文本维度：各种建模元素的规格说明

☑规格说明

​	◆模型元素的特征和语义的文本描述

​	◆形成了承载模型的语义背板(semantic backplane),赋予模型意义，各		种图仅仅是该背板的视图或者可视化投影

​	◆death by diagram(由于图形而死亡)

##### 修饰(adornments)

☑UML表示法中的每一个元素都有一个基本符号，可以把各种修饰细节添加到这些符号上

​	◆只有在修饰增强了图的整体清晰性和可读性或者突出模型的某
​		些重要特征时，才应该表示那些修饰

##### 通用划分

☑类元(classifier)和实例的划分

​	◆类元表示一种抽象

​	◆实例则是这种抽象的一个具体表现

​		:large_orange_diamond:例：类对象、用例/场景、构件/构件实例.…

☑接口和实现的分离

​	◆接口声明行为的契约（做什么）

​	◆实现表示对该契约的具体实现细节（如何做）

​		:large_orange_diamond:例：接口/子系统、用例/用例实现、操作/方法…

☑类型和角色的分离(UML2新增) 

​	◆任何作为其它实体结构的一部分实体（如属性）都具有两个方面的		特性：

​		:large_orange_diamond:从固有类型派生出来的含义

​		:large_orange_diamond:在语境中的角色派生出来的含义

​	◆类型声明了实体的种类（如对象、属性、参数）

​	◆角色描述了实体在语境（如类、构件、协作、组合结构）中的含义

##### 扩展机制

☑构造型(stereotypes)

​	◆基于已有的建模元素引入新的建模元素

☑标记值(tagged value)

​	◆扩展UM构造型的特性，可以用来创建构造型的详述信息

☑约束(constraint)

​	◆扩展UML构造块的语义，可以用来增加新的规则或修改现有的规
​		则

☑外廓(profile)

​	◆提供了一组预定义的构造型、标记值、约束和基类，以用于特
​		定领域的建模

##### 构造型(stereotypes)

☑构造型(stereotypes,衍型)

​	◆根据已有的模型元素定义一个新元素

​	◆建立在UML已定义的模型元素基础上

​	◆可以用于所有的UML模型元素，如类、关联、用例、构件等

​	◆UML规范提供了一些预定义的构造型

##### 外廓(Profile)

☑外廓

​	◆基于UML元素的子集为特定领域定义了UML的一个特定版本，即
​		定义了一组对UML已有模型的扩展和限定机制，以用于某个特定领		域

​	◆这些扩展和限定机制包括：预定义的构造型、标记值、约束和基类

​	◆建立在普通的UML元素基础上，并不代表一种新的语言

###### OMG提供的Profile

☑OMG基于Profile机制扩展UML应用

​	◆MARTE (UML Profile for Modeling and Analysis of Real-time
​		and Embedded Systems)

​	◆UML Testing Profile

​	◆UML Profile for System on a Chip (SoC)

​	◆SoaML (Service oriented architecture Modeling Language)

​	◆SysML (OMG Systems Modeling Language)

​	◆EAI (UML Profile for Enterprise Application Integration)

​	◆......

###### 外廓图(Profile Diagram)

☑UML2.3新增的Profile Diagrami专门用于可视化描述外廓以
	及构造型、标记值、约束等

☑主要概念

​	◆Profile:一个包，代表一个外廓

​	◆Stereotype:定义一种针对元类的扩展

​	◆Metaclass::可被扩展的元素

​	◆Extension:构造型和元类之间的关系

​	◆ProfileApplication:Profile和应用模型之间的关系

###### 应用Profile DIagram

[![LgWeYQ.png](https://s1.ax1x.com/2022/04/22/LgWeYQ.png)](https://imgtu.com/i/LgWeYQ)

##### 架构：4+1视图

[![LgWuSs.png](https://s1.ax1x.com/2022/04/22/LgWuSs.png)](https://imgtu.com/i/LgWuSs)

##### 按照开发阶段组织模型架构

[![LgWmWj.png](https://s1.ax1x.com/2022/04/22/LgWmWj.png)](https://imgtu.com/i/LgWmWj)



# 使用EA进行UML建模实践

## 视图创建

1. 业务模型---用例图
   - 主视图---包图
2. 需求模型---用例图
   - 主视图---包图
3. 分析模型---类图
   - 主视图---类图
4. 设计模型---类图
   - 主视图--类图
5. 实现模型---组件图
   - 主视图--组件图
6. 部署模型---部署图
   - 主视图--部署图

## 示例：图书馆管理系统

☑某图书馆管理系统

​	◆是一个基于Web的计算机应用系统

​	◆读者可以查询图书信息以及借阅信息

​	◆读者可以通过系统预约所需的图书

​	◆图书馆工作人员利用该系统完成读者的借书、还书业务

​	◆图书馆工作人员可以对图书信息、读者信息等进行维护

​	◆对于到期的图书，系统会自动向读者发送催还信息

​	◆管理员会定期进行系统维护

​	◆......

### 用例图

☑用例图(Use Case Diagram)是被称为参与者(Actor)的外部用户所能观察到的系统功能的模型图

​	◆列出系统中的用例和参与者

​	◆显示哪个参与者参与了哪个用例的执行

☑核心概念

​	◆用例：，系统中的一个功能单元，可以被描述为参与者与系统之间的一次交互作用

​	◆参与者、参与者泛化

​	◆用例与参与者之间的关系：关联

​	◆用例之间关系：扩展、包括、泛化

☑推荐使用场合

​	◆业务建模、需求获取、定义

#### 用例图原语





[![LgyalV.png](https://s1.ax1x.com/2022/04/22/LgyalV.png)](https://imgtu.com/i/LgyalV)

#### 图书管理系统用例图

[![LgytWq.png](https://s1.ax1x.com/2022/04/22/LgytWq.png)](https://imgtu.com/i/LgytWq)

#### “借书”用例文档

UC01:“借书”用例文档

■用例名称：借书

■用例标识：UC01

■涉及的参与者：工作人员

■涉及的用例：无

■描述：工作人员利用该用例为读者完成借书过程

■前置条件：工作人员必须登录到当前系统

■涉众利益：

​	读者：能够方便的找到并借出所需的图书
​	工作人员：能够快速并准确的完成借书工作

■基本事件流：工作人员帮助读者借阅图书

​	1.用例起始于读者带着所要借的图书来到借阅前台：

​	2.工作人员录入读者信息：

​	3.工作人员逐一录入所有的图书信息：

​		*3.1工作人员录入一本图书信息：

​		*3.2系统确认该读者可以借阅当前图书；

​	4.工作人员确认本次借阅信息：

​	5.系统记录本次借阅情况。

■后置条件：系统将读者借阅信息正确地记录到数据库中

■备选事件流

​	2a.读者身份不合法

​	2b.读者存在欠费信息，不允许借书

​	3.2a.该读者不允许借阅当前图书

### 活动图

☑活动图(Activity Diagram)

​	◆通过动作来组织，主要用于描述某一方法、机制或用例的内部行为

☑核心概念

​	◆状态、活动、组合活动、对象

​	◆转移、分支

​	◆并发、同步

​	◆泳道

☑推荐使用场合

​	◆业务建模、需求、类设计

#### 活动图原语

[![LgyEod.png](https://s1.ax1x.com/2022/04/22/LgyEod.png)](https://imgtu.com/i/LgyEod)

#### 借书业务活动图

[![LgymWt.png](https://s1.ax1x.com/2022/04/22/LgymWt.png)](https://imgtu.com/i/LgymWt)

### 静态结构图

☑类图(Class Diagram)

◆是软件的蓝图，，详细描述了系统内各个对象的相关的类，以及这些类之间的静态关系

☑对象图(Object Diagram)

◆表示在某一时刻类的对象静态结构和行为

☑包图(Package Diagram)

◆展现有模型本身分解而成的组织单元（包）以及它们的依赖关系

☑组合结构图(Composite Structure Diagram)

◆描述系统中某一部分（组合结构）的内部结构，包括该部分与系统其它部分的交互点

#### 类图、对象图、包图原语

[![LgyQOS.png](https://s1.ax1x.com/2022/04/22/LgyQOS.png)](https://imgtu.com/i/LgyQOS)

#### 组合结构原语

[![LgywOU.png](https://s1.ax1x.com/2022/04/22/LgywOU.png)](https://imgtu.com/i/LgywOU)

#### 包图展示系统分层结构

[![LgsxiR.png](https://s1.ax1x.com/2022/04/22/LgsxiR.png)](https://imgtu.com/i/LgsxiR)

#### 类图展示实体类的静态关系

[![Lgy1eg.png](https://s1.ax1x.com/2022/04/22/Lgy1eg.png)](https://imgtu.com/i/Lgy1eg)

#### 对象图展示当前借书情况

[![Lgypz6.png](https://s1.ax1x.com/2022/04/22/Lgypz6.png)](https://imgtu.com/i/Lgypz6)

#### 组合结构展示借书内部结构

[![LgyBmF.png](https://s1.ax1x.com/2022/04/22/LgyBmF.png)](https://imgtu.com/i/LgyBmF)

#### 借书用例实现的用例图

[![LgyKQf.png](https://s1.ax1x.com/2022/04/22/LgyKQf.png)](https://imgtu.com/i/LgyKQf)

#### 借书用例实现的用例图2

[![LgyMy8.png](https://s1.ax1x.com/2022/04/22/LgyMy8.png)](https://imgtu.com/i/LgyMy8)

### 交互纵览图

☑交互纵览图(Interaction Overview Diagram)

​	◆活动图和顺序图的混合物

​	◆直观地表达一组相关顺序图之间的流转逻辑

☑核心概念

​	◆交互帧

​	◆分支、转移

☑推荐使用场合

​	◆用例分析、用例设计

#### 交互纵览图原语

[![LgyZFA.png](https://s1.ax1x.com/2022/04/22/LgyZFA.png)](https://imgtu.com/i/LgyZFA)

#### 交互纵览图组织多个顺序图

[![LgyeJI.png](https://s1.ax1x.com/2022/04/22/LgyeJI.png)](https://imgtu.com/i/LgyeJI)

### 通信图

☑通信图(Communication Diagram)
◆UML1.x中称为协作图
(Collaboration Diagram)
◆表示一组对象间关系以及交互活动
☑核心概念
◆对象、协作角色
◆协作、交互、消息
☑推荐使用场合
◆用例分析、用例设计

#### 通信图原语

[![LgyYYn.png](https://s1.ax1x.com/2022/04/22/LgyYYn.png)](https://imgtu.com/i/LgyYYn)

#### 借书用例实现的通信图

[![LgyuSP.png](https://s1.ax1x.com/2022/04/22/LgyuSP.png)](https://imgtu.com/i/LgyuSP)

### 时间图

☑时间图(Timing Diagram)
◆一种交互图，展现消息跨越不同对象或角色
的实际时间信息
,具体描述单个或多个对象状态变化的时间点以及
维持特定状态的时间段
,顺序图是表示交互的主要手段，可以在顺序图中
增加时间约束来表明对象状态变化的时间点以及
维持特定状态的时间段
☑核心概念
◆时间约束、持续时间约束、生命线
◆状态、条件、事件

#### 时间图原语

[![LgyJFs.png](https://s1.ax1x.com/2022/04/22/LgyJFs.png)](https://imgtu.com/i/LgyJFs)

#### 打电话顺序图的时间约束

[![LgszJ1.png](https://s1.ax1x.com/2022/04/22/LgszJ1.png)](https://imgtu.com/i/LgszJ1)

#### 利用时间图描述时间约束2

[![Lgy8oj.png](https://s1.ax1x.com/2022/04/22/Lgy8oj.png)](https://imgtu.com/i/Lgy8oj)

### 状态机图

☑状态机图(State Machine Diagram)
◆UML1.x为状态图(Statechart Diagram)
◆利用状态和事件描述对象本身的行为
☑主要概念
◆状态、初态、终态、复合状态
◆事件、转移、动作
◆并发
☑推荐使用场合
◆类设计

#### 状态机图原语

[![LgydyT.png](https://s1.ax1x.com/2022/04/22/LgydyT.png)](https://imgtu.com/i/LgydyT)

#### 图书类的状态机图

[![LgyUS0.png](https://s1.ax1x.com/2022/04/22/LgyUS0.png)](https://imgtu.com/i/LgyUS0)

### 构件图

☑构件图(Component Diagram)

​	◆封装类为构件

​	◆描述在系统实现环境中的软件构件和之间的关系

☑主要概念

​	◆构件、工件、接口（所供接口、所需接口）

​	◆依赖、实现

☑推荐使用场合

​	◆系统设计、实现、部署

#### 构件图原语

[![LgyAdH.png](https://s1.ax1x.com/2022/04/22/LgyAdH.png)](https://imgtu.com/i/LgyAdH)

#### 构件图描述类的实现环境

[![Lgykee.png](https://s1.ax1x.com/2022/04/22/Lgykee.png)](https://imgtu.com/i/Lgykee)

#### 构件图-UML2新特性

[![LgyiLD.png](https://s1.ax1x.com/2022/04/22/LgyiLD.png)](https://imgtu.com/i/LgyiLD)

### 部署图

☑部署图(Deployment Diagram)
◆描述系统所需的硬件构件的物理部署
☑主要概念
◆节点、构件、位置
◆连接、依赖
☑推荐使用场合
◆系统设计、实施、部署

#### 部署图原语

[![LgySRx.png](https://s1.ax1x.com/2022/04/22/LgySRx.png)](https://imgtu.com/i/LgySRx)

#### 部署图描述系统部署情况

[![LgyCQK.png](https://s1.ax1x.com/2022/04/22/LgyCQK.png)](https://imgtu.com/i/LgyCQK)

# 业务建模

## 分析设计过程简介

### UML是标准的符号

1.用UML画图很容易                摆脱符号烦恼
   但知道要画什么是困难的！全心面对问题

2.UML仅仅是一种表达形式

​	用好UML首先需要掌握OOAD的基本原则和方法并在一定的软件开发	过程（如统一过程、敏捷过程等)的指导下进行有取舍的运用

### UML分析设计过程解析

☑<u>业务建模</u>

​	◆采用软件建模方法**分析和理解待开发的业务**，描述业务流程

☑<u>需求</u>：用例建模

​	◆采用UML用例技术**描述软件需求**

☑<u>需求分析</u>：用例分析

​	◆采用UML用例**分析技术分析软件需求**，建立软件系统的分析模型

☑<u>架构设计</u>

​	◆在系统的全局范围内，以分析模型为基础，设计系统的架构

☑<u>构件设计</u>

​	◆根据架构设计的成果，将分析模型细化，设计系统构件的实现细节

☑<u>代码实现</u>

​	◆将系统构件映射到目标语言上

### 结合过程应用UML

☑UML2提供的5类14种图

☑各类软件过程模型提供了不同的开发活动和工作流

​	◆过程是一种“战术”，而UL则是基本的"作战技能”

​	◆是一种多对多的关系，没有严格的对应，但有些最佳实践

​	◆过程只是一个模板，每个团队都有自己的特点，根据这个模板定义		自己的过程

### 根据团队情况分步改进

☆用例文档（需求）→老方法

☆用例文档→类图（静态分析）→老方法

☆用例文档→类图→顺序图（动态分析）

## 业务模型基础

### 业务

☑业务是**指某个组织或者组织单元，可看作一种包含了人、机器、资源的“系统“**

☑<u>利用软件思想（用例思想、对象思想）描述业务的过程</u>，就
是**业务建模**

​	◆业务建模是一种建模方法的集合，目的是对现有业务进行分析
​		和理解，从而建立相应的业务模型

​	◆这一过程不仅有助于开发人员理解业务本质，而且这些模型将
​		作为后续软件系统模型的输入

### 业务建模

☑业务建模的目标

​	◆理解将要实施系统的组织结构和动态特性

​	◆理解当前目标组织中的问题，并明确改进的潜力

​	◆确保客户、最终用户和开发人员对目标组织有统一的理解

​	◆获取用于支持目标组织的系统需求

☑业务建模与软件开发过程际题

​	◆业务建模是软件开发过程的辅助环节，可以描述业务现状，从而帮		助发现软件需求，指導系统设计

### 需要业务建模的情况

​	☑不熟悉业务机构

​	☑机构准备进行业务过程重组

​	☑机构最近进行了一些业务过程重组

​	☑建立机构主要部分使用的软件

​	☑机构中大型复杂工作流的文档不足

### 业务建模方法

☑研究对象

​	◆软件要改进的**业务单元**

☑研究目标

​	◆定义业务本质

☑研究方法

​	◆**用例观点**：把业务看成对外提供价值的**价值流**

## :star:业务用例模型

### 业务建模流程

☑0.建立**业务用例模型**

​	◆1.识别业务参与者

​	◆2.识别业务用例

​	◆3.详述业务用例

☑4.建立**业务对象模型**

### 1.业务参与者(Business Actor)

☑识别业务参与者

​	◆在**业务之外**，与业务进行**交互**的人或组织

![image-20220422150847376](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220422150847376.png)*业务参与者*

#### 识别业务参与者思路

☑客户
☑供应商
☑合作伙伴
☑潜在客户
☑政府
☑组织中未建模部分
☑......

### 2.业务用例(Business Use Case)

☑识别业务用例
	◆业务为业务参与者提供的**价值**
	◆体现企业业务本质，是**有意义**的目标

![image-20220422151316006](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220422151316006.png)*业务用例*

#### 识别业务用例的方法

☑直接获得：从业务参与者的角度，从外部推导出来

☑拼装：从里面往外面看，内部业务流程的目标是什么

#### 从业务流程拼装业务用例

☑业务流程
	◆1.收款人在支票背后签名，写上身份证件号码，把支票和身份
		证件交给营业员
	◆2.营业员核对印章正确且证件有效
	◆3.营业员操作营业受理系统，理支票兑现手续
	◆4.营业员把现金和证件交给交款人

#### 识别业务用例-支持性事件

☑不要遗漏支撑性业务流程背后的业务用例
☑支撑性事件
	◆内部人员的发展与维护
	◆业务内部T的开发与维护
	◆办公室的设立与维护
	◆安全性
	◆法律活动
	◆其他管理特征的流程

### 3.详述业务用例

☑业务用例是对业务流程的封装，在业务建模过程中需要逐
	一描述其内部细节，即详述业务用例

☑目的

​	◆详细说明业务用例的工作流程

​	◆说明业务用例的工作流程，以便于客户、用户和涉众理解

#### 三种可选技术：文档、活动图、顺序图

#### 选择合适的技术

☑只有文字

​	◆不生动，不便于和客户交流

☑只有活动图

​	◆难以表达所有细节

☑业务用例文档中插入活动图

☑:star:活动图中插入文字(+注释+基本路径)

☑顺序图（需要涉及到业务对象模型）

#### 活动图

☑活动图(Activity Diagram)

​	◆一种行为模型，描述活动或动作之间的流程，强调行为的执行
​		序列和条件

☑活动建模的主要用途

​	◆描述业务用例或系统用例，实现对业务流程、工作流和系统处
​		理流程的建模

​	◆描述算法，实现对系统内部类方法建模

​	◆对复杂信息系统建模，以确定系统处理信息的层次关系和流程

#### 活动和活动图

☑活动是一种参数化的行为规范，这种行为包含了一组动作
的执行序列
	◆活动的每次执行都包含了一系列内部动作的执行，其中每个动
		作可能执行0到多次，并按照一定的次序执行，通过控制流或对
		象流来协调其内部行为的执行
☑活动图由一组活动节点通过一系列活动边连接起来
	◆活动节点（ActivityNode)
	◆活动边(ActivityEdge)

#### 活动节点和活动边

☑活动节点
	◆动作节点：可执行算术计算、调用操作、管理对象内部数据等动作
	◆控制节点：如起点和终点、决策和合并、分叉和汇合等控制逻辑
	◆对象节点：表示活动中所处理的一个或一组对象
☑活动边：一种有向边，可以说明条件、权重等内容
	◆控制流：连接可执行节点和控制节点的边
	◆对象流：连接对象节点的边

##### 动作节点

☑动作节点(action node)是活动图中最基本的元素
	◆一个动作表示一个原子的操作，是最小的行为单位，是一种可执行节点
	◆从一个活动来看，其中所有的动作都是原子性的、不可再分解
	◆当动作节点所有的对象流和控制流的前提条件都满足时，才创建动作的一次执行
☑动作的执行步骤
	◆创建、启动、操作、完成、清理

##### 动作的类别

☑活动中可以包含不同种类的动作
	◆基本功能：如算术运算等原子动作
	◆行为调用：如调用另一个活动或操作
	◆通信动作：如发送一个信号，或等待接收某个信号、等待某个时间点
	◆对象处理：如对属性值或关联值的读写

##### 控制节点：决策和合并

☑控制节点(control node)是一种特殊的活动节点，用于在动作节点或对象节点之间协调流
☑决策和合并用来对条件分支进行建模
☑决策节点(decision node)
	◆有一个输入流和多个输出流，在多个输出流上设置不同的条件，按照特定条件进行选择输出流
☑合并节点(merge node)
	◆与决策节点对应
	◆将多个可选流合并起来，有多个输入流一个输出流

##### 控制节点：分叉和汇合

☑分叉和汇合用来对并发执行和同步控制的行为进行建模
☑分叉节点(fork node)
	◆一个输入流多个输出流，从而把一个流分为多个并发的流
☑汇合节点(join node)
	◆多个输入流一个输出流，用于同步多个流

##### 控制节点：起点、终点、流终止

☑起点(initial node)和终点(activity final node)
	◆活动的一种特殊形式
	◆起点：只有离开的控制流，同一层次只有一个
	◆终点：只有进入的控制流，可能有多个
	◆存在从起点出发，到达终点的路径
☑流终止(flow final node)
	◆某个流结束，不影响当前活动中其他并行流

##### 对象节点：一般对象节点

☑对象节点(object node)是一种特殊的活动节点，用于定义对象流
	◆本质上是一个实例或一组同类型的实例，可以指定对象名称和类型
	◆可以说明对象所处的状态
	◆可以说明一个上界，以限制节点允许驻留实例的最大数量
	◆可以说明实例的排序方法
		:large_orange_diamond:FIFO、LIFO、Unordered、Ordered

##### 对象节点：引脚

☑引脚(pi)是一种特殊的对象节点，连接在动作上，表示该动作的输入（输入引脚）或输出的值（输出引脚）

​	◆对于调用动作，可定义多个引脚表示调用实参，引脚数目和类型应与被调用的活动或操作的形参一致

​	◆一个动作的输出引脚连接到另一个动作的同名输入引脚，表示了一个输出引脚、一个输入引脚和一个对象流

☑引脚的状态：在引脚名字下方可用方括号说明其状态

☑流式(stream)引脚：该动作执行过程中会有多次输入或输出

##### 活动边

☑活动边是一种有向连接，从一个源节点指向一个目标节点，包括控制流和对象流

◆可以设定一个守卫条件(guard condition),只有守卫条件为真时才能进	入下一个节点

◆可以关联动作(action)，发生转移时执行该动作

◆可以设定权重(weight),规定了转移发生时输入对象的最小数目（常量
     或表达式)，缺省为all

##### 控制流和对象流

☑控制流(control flow)，连接两个动作/控制节点，前一个节点完成后启动下一个

◆控制流不传递对象和数据，只传递控制令牌，源节点所有令牌都将传递给目标节点

☑对象流(object flow)连接一个动作节点和一个对象节点（或连接两个引脚)
	◆用来传递对象或数据，表示由源动作“生产”对象，或油目标动作“消费”对象

##### 活动分区

☑活动图一般不关注节点所属的类元

☑对于复杂的活动图，往往需要明确由什么角色或机构来负责执行这些动作和控制

☑活动分区(partition)用于识别具有相同特性的一组动作，这些动作被放入相同的区间。如何分区没有严格的规范，参考的分区规则

​	◆业务模型中，往往按照组织机构的单位或角色进行分区，一个单位或角色负责分区中各节点的行为

​	◆设计模型中，可以按照不同的类进行分区，一个类负责执行该区中的节点的行为

![image-20220422155220030](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220422155220030.png)

## 业务对象模型

☑业务对象模型(Business Object Model)

​	◆勾勒出实现业务关系中的人、事物、设备、资源以及它们之间的关系；即业务工人和业务实体之间的静态关系

​	◆另一个视角描述业务，使用UML类图

​		人们在组织中扮演的角色表示为**业务工人(Business Worker)**

​		组织管理或制造的“东西”表示为**业务实体(Business Entity)**

#### 区分业务参与者和业务工人

☑业务参与者在业务外面
☑业务工人在业务里面

![image-20220422155913332](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220422155913332.png)业务工人![image-20220422155954006](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220422155954006.png)业务实体

## 业务建模实现

### 建模指南：使用构造型

☑业务用例模型是在UL的用例模型（用例图)基础上添加构造型来实现的

☑业务对象模型是在UL的对象模型（类图）基础上添加构造型来实现的

​	◆利用已有元素添加构造型

​	◆EA提供了业务建模扩展支持

### 业务建模实践：实例分析

☑研究对象：某旅店

☑业务现状：
	◆某旅店可对外开放50个双人间和20个单人间，房间费用视情况按季节调整，但周一到周五提供平价（周宋全价）折扣旅客可以直接入住房间（如果有空房），也可提前预订；入住和预订都需要登记个人信息

​	◆旅客提前预订房间时，需提交一定的订金：入往时间24小时之外的旅客可以取消预订，并退回所有订金，24小时以内则不退还订金

​	◆退房时缴纳全部的住宿费用

​	◆服务员每月为经理提供房间的预订情况和入住情况的详细信息



#### 实例分析：业务用例模型

![image-20220422170035226](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220422170035226.png)

#### 实例分析：旅客业务流程--活动图



#### 实例分析：检查用例模型

1. 业务用例模型是否体现整个旅馆的业务需求

2. 如何考虑这项业务：服务员每月为经理提供房间的预订情况和入住情况的详细信息？

   ​	◆经理是什么，如何体现在业务建模过程中？
   ​	◆是业务参与者还是业务工人？体现怎样的业务本质的差异？

#### 实例分析：业务对象模型



#### 实例分析：完善业务用例模型和业务流程







![image-20220422161243221](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220422161243221.png)

![image-20220422161611672](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220422161611672.png)

![image-20220422161733508](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220422161733508.png)

用类图替代业务对象模型



## 从业务模型到系统模型

# 用例建模



☑理解需求
☑需求获取
☑用例建模流程
	◆获取原始需求
	◆构建初始用例模型
	◆编写用例文档
	◆重构用例模型
☑其他问题

## 理解需求

**需求--建造“正确”的系统**

☑需求：客户可接受的、系统必须满足的条件或具备的能力
☑RUP中的FURPS+软件质量准则
	◆功能性(Functionality)
	◆使用性(Usability)
	◆可靠性(Reliability)                                                非功能性需求
	◆性能(Performance)
	◆可支持性(Supportability）
	◆+

**需求工程的主要活动**

☑定义需求
	◆理解用户的需要，建立用户可理解的系统**需求模型**（第四章)
☑分析需求
	◆根据需求模型，建立开发者无二义性解释的**分析模型**（第五章）
☑需求管理

**需求难在：**难捕获，易改变

**需求也需要开发**

![image-20220423052700091](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220423052700091.png)

**需求问题：对策**

难捕获--》从用户角度看问题

易变--》合理稳定的结构

以用例为中心组织需求：功能需求、非功能需求（性能、可靠、可用、可支持）、数据需求、设计约束 ...

## 需求获取

☑有业务模型：从业务模型获取需求
	◆从业务用例模型中寻找系统改进点
	◆结合项目远景，获取系统用例来表达需求
☑无业务模型：采用需求启发技术，从涉众获得

**从业务模型获取需求**

☑从业务用例模型中获取系统需求，来构建系统用例模型
	◆1.寻找业务改进点
	◆2.定义项目远景
	◆3.导出系统需求

**1.业务改进点**

☑业务模型描述业务现状，这些现状：
	◆有些可能一直运转的很好，不需要改进，也就没有必要作为软件需求来由系统实现
	◆而另外可能更多的业务在运转过程中存在这样或那样的问题，这些问题就成为业务待改进的改进点，也就很可能作为软件需求而存在

☑从业务流程中获取改进点的思路

​	◆流程控制
​	◆复杂业务逻辑
​	◆使用作业务对象
​	◆自动化业务
​	◆......

**2.远景(Vision)**

☑系统改进点不等同于软件需求用户根据自身的工作特点和支付能力决定哪些应该改进，哪些不需要改进

◆这就是用户的远景，它表明用户改进的目标，这也将成为项目的目标

☑务模型描述了“现实是什么”，远景则描述“希望的改进

◆远景表达了“为什么要开发这个系统”
◆在业务现状（业务模型）下，开发系统是为了达到什么目标？

**定义项目远景**

☑远景包含了对待开发系统的目标和约束
◆代表了项目涉及的所有人之间达成的第一个共识
◆是项目核心需求的概览
◆为更详细的技术需求提供了契约性的依据
◆指导团队实现具体的业务目标

☑远景的作用
◆最初，根据项目的远景目标来决定项目是否值得继续
◆在项目批准后，团队根据项目远景来指导后续的需求和设计

**远景说明**

☑远景可以作为一个单独的文档存在，而这其中最重要的部分就是关于远景目标的说明，它建立了一个项目涉及的所有人的共同目标
☑远景说明应该是精确、清晰和激励性的描述，以便激励所有的团队成员为达成该远景而努力。一个好的远景应该具有以下五个特点
(SMART):
◆具体的(Specific)
◆可测量的(Measurable)
◆可实现的(Achievable)
◆相关的(Relevant)
◆基于时间的(Time-based)

**3.导出系统需求**

☑从业务改进点入手，结合项目远景，导出系统需求：
◆对于每一个业务改进点，明确是否是为了达到远景目标的需要
◆如果是则作为软件需求而存在，并把相应地模型作为系统模型
◆如果不是则不作为需求而存在，可能作为一项潜在的需求考虑，也可能直接抛弃

**实例分析：旅店系统开发背景**

☑随着旅店声誉日益提高，住宿人员越来越多，旅客为了能够获得好的房间，均提前预订房间
☑然而，随着预订的增多、预订周期的拉长，前台服务员工作压力也白益增大，还经常出现工作的失误，使得已经预订好房间的旅客也不能按期入住，这给旅店的声誉带来不好的影响
☑为此，旅店老板想到了计算机，希望能够通过计算机来自动管理这些预订业务，不过由于自前资金的问题，目前只开发一个单机版的,不稳供网上显务，省店方面的具影企务套不考虑信息化问题
☑旅店老板委托某计算机公司开发该系统，并承诺如果系统运转良好的话，将会考虑进一步合作事宜

**远景：旅店预订系统**

☑A很荣幸地，成为项目经理并被要求在两个月之内发布该系统的第一个版本，同时还被要求要为后续的开发提供必备的接口
☑结合现状和老板的要求，考虑到的项目可扩展的要求，A首先进行了简单的业务建模
☑之后，A初步定义了项目的远景
	◆提前准确地为旅客预订所需的房间
	◆旅客可以在规定的时间内方便地取消预订的房间
	◆旅店老板能够定期的获取预订的信息，根据这些信息可以及时调整房间的价格
	◆及时、快速地计算房间费用、预订费用、取消预订后退款金额等信息
	◆预留接口：可以为以后的网络版，以及其它业务系统的开发提供支持

**结合远景获取系统需求**

## 建立用例模型

### 用例建模流程

☑1.获取原始需求
☑②.开发一个可以理解的需求
	◆2.1识别参与者
	◆2.2识别用例
	◆2.3绘制用例图
☑3详细、完整地描述需求
	◆编写用例文档
☑4重构用例模型
	◆4.1识别用例间的关系
	◆4.2对用例进行分包和分级

**1.需求从何而来**

☑需求只能来自涉众
	◆最终用户、客户
	◆政府、法律、文化
	◆开发人员、管理人员

​	◆竞争对手

​	◆......

☑但并不是直接从涉众中来
◆你们的需求是什么？

**涉众无法直接提供需求**

☑用户不可能直接提供系统的最终需求
◆用户描述的只是现状，对于未来软件的工作模式，用户不可能
描述清楚的
☑用户提供的只是个人或组织的需要(Need)或想法
☑需求获取：系统分析师必须能够透过这些原始的需要来获
取软件的最终需求

**需求获取技术**

☑系统分析师借助于不同的需求获取方式，从涉众中获取需求
◆收集资料
◆现场观察
◆访谈
◆开会
◆原型
◆问卷调查
◆...

**需求获取技术对比**
![image-20220423055657369](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220423055657369.png)

### 开发一个可以理解的需求

#### 识别参与者

☑识别参与者
◆关键词：边界
◆参与者：在**系统之外**，透过**系统边界**与系统进行**有意义交互**的**任何事物**

**参与者要点分析**

☑系统外
◆参与者不是系统的一部分，处于系统的外部
☑系统边界
◆参与者透过系统边界直接与系统交互，参与者的确定代表系统边界的确定
☑系统角色
◆参与者与使用系统的物理人和职务没有关系
◆需要从参与系统的角色（作用）来寻找参与者
☑与系统交互
◆系统需要处理其交互过程，即系统职责
☑任何事物
◆人、外系统、外部因素、时间

**要点：与系统进行信息交互、任何事物**

#### 参与者和系统边界

**识别参与者的思路**

☑可以从以下要点来识别参与者
	◆系统在哪些部门使用
	◆谁向系统提供信息、使用和删除信息。
	◆谁与系统的需求有关联
	◆谁对系统进行维护
	◆与外部系统是否有关联
	◆时间参与者：一种习惯用法，用于激活那些系统定期的、自动执行的用例

**参与者的命名**

☑对参与者赋予能更好地表达其角色（作用）
的名称
◆不好的参与者命名的例子：用职务名称和个人姓名来命名
	例如，张三、老李、校长、科长

​	若使用系统的人（职务名称）变化的话，就不是参与者了
◆好的参与者命名的例子：用能知道其角色的名称来命名
​	例如，学生、订单管理员、维护部门…
​	即使使用系统的人改变，从系统来看，使用者的角色（作用）是相同的。

参与者之间的关系：泛化
☑参与者可以通过泛化关系来定义，在这种泛化关系中，一个参与者的抽象描述可以雇员被一个或多个具体的
参与者所共享

◆如系统中经理可以参加雇员的所有用例

**参与者地位**

☑识别用例之前一重要
	◆有助于识别用例，宁多勿少
☑开始书写用例文档以后一不重要
	◆涉及的参与者太多
☑测试和部署阶段一重要
	◆需要从参与者的角度考虑

**文档化参与者**

☑参与者的文档没有固定的格式，但至少应该包含如下信息
◆描述：为每一个参与者提供一个简要的描述，准确地描述该参与者的所扮演的角色和职责
◆基本特征：针对参与者的职责范围、物理环境、使用习惯、用户数量和类型使用系统的频率等特性进行说明
◆相关的涉众和典型用户

### 识别用例

☑关键词：价值
☑简洁定义：参与者使用系统达到某个耳标
☑定义
◆用例实例是系统执行的一系列动作，这些动作将生成特定参与者可观测的结果值
◆一个用例定义一组用例实例（场景)

**用例要点**

☑可观测→用例止于系统边界
☑结果值→用例是有意义的目标
☑系统执行→结果值由系统生成
☑由参与者观测→业务语言、用户观点

要点：用例止于系统边界、有意义的目标、结果值由系统生成、业务语言而非技术语言、用户观点而非系统观点。

用例---用户观点

功能--系统观点

### 确定用例

☑从参与者的角度入手，通过分析参与者使用系统达成的目标来识别用例
◆参与者的日常工作是什么
◆参与者在业务中承担什么样的作用
◆参与者是否生成、使用或删除系统相关信息
◆参与者是否需要把外部变更通知系统
◆系统是否需要把内部事情通知参与者，通知参与者过程就是系统用例的行为
◆是否存在进行系统维护的用例
☑用例数量的参考基准
◆1个系统中存在十几个用例（或更少）
◆1个用例中有多个用例实例（场景）

**用例命名**

☑参与者视角：
	◆(状语)动词+（定语+)宾语

**用例粒度**

☑用例是一组用例实例的抽象；其内部要有路径，路径要有步骤
☑最常犯错误：粒度过细，陷入功能分解
	◆通过执行用例，参与者完成想做的事情(最终的目的)，并为参与者产生所需要的价值
	◆过细的粒度，一般都会导致技术语言的描述，而不再是业务语言

**用例粒度：四轮马车**

☑四轮马车CRUD: C(Create)、R(Read)、U(Update)、D(Delete)
	◆所有业务最终对会成为CRUD?
	◆CRUD能为Actor提供价值？
	◆CRUD掩盖业务，锐变成关系数据库的建模
		“系统就是数据的增删改查”
		关心数据的存储和维护，反而忽略了用户的目的

☑如果确实是CRUD
	◆如果CRUD不涉及复杂的交互，一个用例“管理义X"即可
	◆不管是C、R、U、D,都是为了完成“管理”目标
	◆甚至很多种的基本数据管理都可以用一个用例表示

☑灵活处理CRUD

**用例是一个完整的交互**

**用例之间没有顺序关系**

### 关联关系：参与者和用例

☑参与者和用例之间的关联关系：参与者参
与用例的执行
◆箭头（关联的方向）并不代表数据流或业务流的方向
◆箭头代表通信的发起方
	箭头由通信的主动方指向被动方，或者说不带箭头的一方会受到带箭头一方的影响

​	不带箭头意味着没有考虑这种影响的方向

### “旅游业务申请系统”问题陈述

>  	文档说明：本案例根据作者经历和相关培训课程资科虚构而成，专门用以面向对原分析设计课程案例数学，请勿用于商业用途。

​		奥游(A0You)旅行社是北京地区一家专门提供组团旅行的旅游公司。目前有关旅游业务的申请过程都是手工完成，考虑到旅游业务的迅猛发展，公司决定开发一个旅游业务申请信息系统。使用新系统后，奥游旅行社的业务流程如下所示：
​		在奥游旅行社，前台招待顾客的员工同顾客洽谈旅游的各项事宜，并帮助旅客办理相关申请手续等。申请手续办理过程是这样的：首先调查顾客所要求的旅行状况，根据顾客的要求查询相关的旅游团的详细信息，满足以下条件旅游团，就可以办理申请手续。
◆所申请旅游团在裁止日期之前
◆所申请旅游团的人数限额未满。
​		所参加的旅游团不同，其截止日期也会不同。在所申请旅游团能办理的情况下，员工将向系统录入申请责任人的姓名、电话号码、参加旅游团的大人和孩子的人数，从而算出订金。参加者每个人所对应的订金是由到出发日期的天数所决定的，其关系如表4-2所示:

![image-20220423112559109](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220423112559109.png)

​		办理完这些手线后，旅行社员工需要向项客收取相应的订金，并在本系统中记录订金支付情况之后，旅行社的员工还向顾客提供订金的收据和一份申请责任人用的旅游申请书，并委托顾客将所申请的其他参加者用的旅游申请书发给他们，所有的旅游申请书集中起来一周以内邮寄到旅行社，有其他问2的话可以再次向旅行社提出。旅游申请书的各项内容对干申请责任人和参加者来说都是一样的。
​		接到顾客邮寄回来的旅游申请书后，员工通过旅游团代码、出发日期和申请负责人等信息查询出该顾客所申请的信息，将相关的参加者信息录入到系统中，录入工作也由这些按待顾客的员工在空闲时间完成，所有的参加者信息录入系统后，一次申请即完成。旅游申请书的格式如表4-3所示:

![image-20220423112822678](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220423112822678.png)

​		申请手续办理完成后，旅行社需要把旅游确认书、余额交款单部寄给申请责任人·每天负责催款的员工要通过系统打印前一天己完成申请的旅游确认书、余额交款单。申请时旅费已全款支付的

阅读上述材料，完成如下任务：

- 识别系统参与者
- 识别系统用例
- 绘制用例图

### 编写用例文档

☑用例文档：描述用例与外界交互的规格说明书
	◆需求的核心内容，而用例图作为用例文档的索引图
	◆进一步的精度：**有层次的**文档
	◆文档中每一句话都有其价值
用例图是骨架，而用例文档则是其内在的肉

#### 有层次的需求组织形式

☑用例（取款）

◆路径（正常取款）
	:large_orange_diamond:步骤（系统验证取款金额合法）
		√补充约束（取款金额必须为50元的倍数）
低精度，稳定:arrow_right:高精度，不稳定

#### 用例文档的组成

☑用例名、简要描述
☑参与者与涉众
☑相关用例
☑前置条件、后置条件
☑事件流
	◆基本路径
	◆备选路径
☑补充约束
	◆字段列表、业务规则
	◆非功能需求、设计约束
☑待解决问题
☑相关图（用例图、活动图、类图）

![image-20220423113828671](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220423113828671.png)

![image-20220423114142833](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220423114142833.png)

**从涉众角度定义用例**

☑Cockburn:用例是涉众之间达成的契约，以参与者为达成特定目标和系统交互的方式演绎

**用例平衡涉众之间的利益**

☑用例平衡涉众之间的利益
☑涉众是受系统影响的，有自己主张的人或组织，可能的涉众有：
◆最终用户、客户、政府、法律
◆开发人员、管理人员、竞争对手、…
☑对于用户在AT取钱的用例
◆用户：希望方便
◆银行：希望安全
◆法律：保护财产

**涉众利益的冲突**

☑用例相当于参与者在台上表演，而最重要的是台下的观众（涉众）的利益
☑编写用例文档的过程就是描述如何满足涉众之间的利益，达到涉众利益的平衡
☑涉众有轻重缓急

**寻找涉众的思路**

☑区分涉众与参与者
◆涉众是与当前用例存在利益关系的人或组织
◆参与者是启动或参与用例执行过程的人或外部事物
☑可能的涉众有：
◆当事人
◆上游下游
◆操作对象的主人

**前置条件和后置条件**

☑前置条件约束在用例开始前系统的状态
◆作为用例的入口限制，它阻止参与者触发该用例，直到满足所有条件
◆说明在用例触发之前什么必须为真
☑后置条件约束用例执行后系统的状态
◆用例执行后什么必须为真
◆对于存在各种分支事件流的用例，则可以指定多个后置条件
☑只有在用例的使用者将这些条件视为附加价值是才使用
☑条件必须是系统可以感知的
☑前置条件必须是在用例执行前就可以感知

☑前置和后置条件是用例的可选特征，如果系统状态对用例
如何启动和如何终止不重要，则可以省略这些条件
☑某些用例依赖于其他用例
	◆例如：“登录”和“管理系统”
☑有助于识别漏掉的用例
	◆例如：“管理订单”却没有“登录”用例

**事件流--用例交互四部曲**

![image-20220423115407181](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220423115407181.png)

**事件流描述要点**

☑事件流描述要使用户和开发人员互相理解用例的功能，要
注意以下几点：
	◆使用业务语言：使用用户平时所使用的语言进行描述重点描述参与者与系统交互的信息
	◆不使用“例如”、"等”不清晰的表达
	◆不要过多的考虑界面细节
	◆不要描述系统内部改处理细节，要描述从系统外部所看到的活动

​	◆要明确描述用例的开始和结束
​	◆不仅需要描述基本事件流，还需要考虑备选事件流


**例1：使用自然语言**
☑技术语言：无法与用户沟通
◆系统通过ADO建立数据库连接，传送SQL查询语句，从“商品表"
查询商品的详细信息.…
☑自然语言（用户语言）
◆系统按照查询条件搜索商品的详细信息

**例2：描述参与者与系统交互过程**
☑以参与者或系统作为主语描述
	◆参与者…
	◆系统…
☑示例
	◆出纳员接收顾客的付款一顾客的付款数可能高于商品总额
	◆出纳员录入顾客所付的现金总额
	◆系统显示出应找还给顾客的余额，打印付款收据

**例3：不细化GU1**
☑过细的GUI描述
◆会员从下拉框中选择类别
◆会员在相应文本框中输入查询条件
◆会员点击“确定”按钮
☑可结合系统界面原型适当描述GUI
◆如果需求阶段已经制作了系统原型，可以考虑结合原型在需求
中适当地说明一些关键界面元素，界面原型也可作为用例的一
部分附加在用例文档中

**例4：分支和循环的描述**
☑分支：放到备选路径中
◆参与者的选择
◆另一条成功线路
系统进行验证
☑循环：直接描述

**两种类型的事件流**
☑基本事件流
◆用例的主路径、愉快路径(Happy Path)
◆通常用来描述一个理想世界，即没有任何错误发生的情况
◆复杂的基本流可以分解成多个子流
☑备选事件流
◆基本事件流中的分支或异常情况
◆注意如何与基本流衔接

**用例文档中的补充约束**
☑用例重点在于描述功能需求，而其它方面的补充约束：
◆与特定用例相关的补充约束，作为该用例文档中一部分来描述
◆一些全局性的补充约束，单独形成一份独立的文档，如“补充
需求规约”文档
☑补充约束
◆数据需求
◆业务规则
◆非功能需求
◆设计约束

**补充约束：数据需求**
☑描述与用例相关的数据需求
◆不同于数据模型一只是一部分，但可以用E/图或业务对象图作
为辅助说明
◆不等于数据字典一容易过早把时间花在细节上，早期只关注数据
本身，不关注实现细节
☑示例（可按数据字典语法，也可简单描述）
◆注册信息=用户名+密码+email-+{电话}*
◆房间的状态可能有：空闲、已预订、占用

**补充约束：业务规则**
☑描述业务逻辑和操作规侧则
◆事实：设备是资产的一种
◆推理：如果过了计划中的交互日期，货物还没有送到，即为
“未按时送货”
◆约：合同总金额不能超出买方的信用额度
☑表达业务规则
◆文字说明
◆决策表
◆OCL(对象约束语言)

**补充约束：非功能需求**
☑一开始，功能需求决胜；类似产品多了，非功能需求决胜
☑四类非功能需求
◆可用性
◆可靠性
◆性能
◆可支持性
◆十

**补充约束：设计约束**
☑本质上不是需求，只是从商业、行政、技术上的约束
◆用Oracle数据库平台，用.Net开发.
◆软件必须符合IS0×××标准
◆。。。。

### 实战编写用例文档

☑旅行申请系统用例文档
,"UC01-申请旅游团”用例文档
“UC02-管理参加人”用例文档

## 重构用例模型


☑利用用例建模高级技术重构用例模型
◆用例关系
通过用例关系将复杂的用例进行适当的分解，以便于提高需求的复用性和可扩展性等，从而使用例模型的结构更合理
◆用例分级

可以根据用例的重要程度进行分级，以便后续迭代计划的制定，高级别的用例优先考虑
◆用例分包
将相关的用例打包，通过分包的方式可以将用例图分层表示，以用于大规模系统的用例建模

☑利用用例建模高级技术重构用例模型
	◆用例关系
		通过用例关系将复杂的用例进行适当的分解，以便于提高需求的复用性和可扩展性等，从而使用例模型的结构更合理
	◆用例分级
		可以根据用例的重要程度进行分级，以便后续迭代计划的制定，高级别的用例优先考虑
	◆用例分包
		将相关的用例打包，通过分包的方式可以将用例图分层表示，以用于大规模系统的用例建模

![image-20220423122138809](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220423122138809.png)

**通过关系整理文档**
☑Include(包含)
◆基用例中复用被包含用例的行为
◆提取公共步骤，便于复用
☑Extend(扩展)
◆通过扩展用例对基用例增加附加的行为
☑Generalization(泛化)
◆派生用例继承泛化用例的行为并添加新行为

**用例关系：包含**
☑包含：表示某个用例中包含了其他用例的行为
◆从两个或多个用例行为中提取公共部分的能力，主要用于支持用例行为的复用

**用例关系：扩展**
☑扩展：某个用例在特定情况下，包含其他用例（扩展用例）的行为，表示功能被扩展
◆为了将基用例的一些特殊情况分离出来，在保持基用例本身相对完整的情况下处理这些特殊行为
◆即不改变基用例，对基用例的行为进行扩展

**提炼扩展用例的主要思路**
☑当基用例的行为非常复杂时，针对一些特殊的处理可以提炼为扩展用例
◆对用例基本行为的可选择特征的描述
◆复杂的异常处理行为的描述
◆面向特定用户的特定需求
◆范围管理和版本管理

**扩展vs包含**

扩展是对某一用例的扩展，即遇到某种情况的时候需要用到扩展的用例

包含是一个用例包含在另一个用例中，是另一个用例的一部分

![image-20220423123001500](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220423123001500.png)

**用例关系：泛化**
☑泛化：表示子用例继承了父用例
◆用例间的泛化关系表明子用例继承父用例中定义的所有属性、行为序列和扩展点，并且参与父用例中所有的关系

慎重用例之间的泛化关系，使用抽象用例

将泛化转换为扩展

**用例分包：组织模型**
☑对于大规模系统，当用例数量很多时，难以在一个层次上一次性描述所有用例
☑用例分包
◆让系统的用例图能够更为清晰的表现出系统的业务逻辑关系和层次
◆对系统进行模块的分割，这种分割将影响到系统今后的开发、系统的最终表现形式

**分包策略**
☑常见的分包方式
◆基于业务主题的分包
按照参与者分包
◆基于开发团队的分包
◆基于发布情况的分包

利用分包机制组织用例模型

![image-20220423133607482](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220423133607482.png)

![image-20220423133657705](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220423133657705.png)

**为什么要对用例进行分级**
☑用例和迭代开发
◆迭代开发中开发周期的定义是围绕用例来组织的
◆一个迭代周期要被指派一个到多个用例，如果完全版本的用例在一个迭代周期中处理起来太复杂的话，那就采用简化版本的用例

**用例分级实施策略-1**
☑可以使用一个简单的但是有些不精确的分类方法，如将用例划分成高、中、低三个等级

**用例分级原则**
☑用例分级的一个基本原则
	◆高级别用例是那些对系统核心架构影响最大的用例
☑提高用例级别的特性：
	◆(1)对架构设计有重要影响的用例，如在领域层中增加多个类的用例或者需要持久化的用例
	◆(2)体现系统核心业务流程的用例
	◆(3)存在开发风险的用例
	◆(4)涉及新技术或需要创新的用例
	◆（⑤）能够尽快投入使用并带来直接经济效益的用例

**用例分级实施策略-2**
☑依照上述的影响用例级别的特性给用例打分（特性也可能
带有权值)

![image-20220423134117000](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220423134117000.png)

**用例建模中的常见问题**
☑用例不是功能分解
	◆用例使用过程中最容易出现的问题
	◆用例是“因”，功能是“果”
	◆用例是目标，不是过程；按照价值分解，而不是功能模块、过程的分解
☑用例图的误区
	◆仅展现所有的参与者、用例以及它们之间的关系
	◆每个用例产生相对独立，向参与者提供价值
☑用例关系的使用

**用例与需求规约**
☑用例模型由用例图、参与者文档和用例文档组成，通过这三部分来表示系统需求
☑补充规约文档
◆需求规约中还应该包含对数据要求、非功能需求、设计约束、用户界面、验收标准等内容的约定
☑数据规约文档

**用例建模的适用场合**
☑用例是从参与者角度捕获系统功能，当系统只有一个或没有参与者时，显然不是非常有效的
☑用例捕获功能需求，因此对于系统的非功能需求不是有效
◆当遇到下述情况时，用例是需求捕获的最好选择
	系统由功能需求所主导
	系统具有很多类型的用户，
	系统对他们提供不同的功能
	系统具有很多接口
◆当遇到下述情况时，用例是一个糟糕的选择：
	系统由非功能需求所主导（如：google)
	系统具有很少的用户
	系统具有很少的接口（非内部功能）
	如：嵌入式系统、算法复杂但接口少的系统等

**用例与项目管理**
☑用例可作为项目估算的依据
	◆从基于功能点的估算，到基于用例的估算方法
☑用例可作为制定后续开发计划和迭代计划的基础
	◆用例驱动的迭代开发
☑用例提供了项目的可追踪性

用例与用户故事
☑用户故事(Use Story)
◆一种轻量级的、有效的用户需求描述方式
☑都是从用户角度描述需求，但不同点：
◆用例：规范化、系统化，包含不同的用例场景
◆用户故事：以用例场景为基础，轻量级的需求描述方式，是敏捷方法中主流的需求建模技术
☑用户故事的描述方式
◆作为`***`（角色，Wh0),希望通过系统`**`（解决方案、功能要求，What),以便达成`**`业务目的、要解决的业务问题(Why)

# 用例分析

## 理解分析

### 分析

☑分析
◆为了满足需求模型中所描述的功能，系统内部应该有什么样的业务核心机制（做什么？）
☑分析的目标开发一系列模型，↓以描述软件核心成分，从而满足客户定义的需求：分析模型
◆包括两个层次：架构分析和用例分析
◆包括两类模型：静态结构（包图、**类图**）和动态交互（**顺序图**、通信图)
◆模型元素按照架构来组织，各类视图按照**用例实现**（协作）来组织

![image-20220423135438867](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220423135438867.png)

### 分析与需求的关系

☑分析是建立在需求收集的基础上
◆分析模型建立在用例模型的基础上
◆用例模型确定了分析模型的结构（通过用例实现（协作）来组织分析模型)
◆用户视角理解用户问题过渡到开发团队视角分析用户问题
	与需求一样，它还是在问题域中
	从用户视角跨入开发团队视角
◆分析与需求捕获在很大程度上重叠，这两个活动常常相辅相成，为了澄清和找出任何遗漏或歪曲的需求，常常需要在需求之上作一些分析

### 分析的"度”

☑面向对象分析是以对象的视角去理解业务问题
◆不同于以自然语言描述的需求
◆也不同于以技术语言去表示的设计
☑如何把握这种介于业务和技术之间的分析活动的“度”是非常关键的
◆过渡的分析会陷入设计误区，从而难以有效的达到分析的目标
◆不够深入的分析则容易遗漏那些重要的信息，从而无法及早发现并处理需求中的问题

### 把握分析的“度”

☑把整个分析活动限制在业务问题域词汇，而不考虑任何技术领域的实现策略
◆保持对系统结构和行为的精确和简单陈述
◆所有与实现相关内容都留给设计和实现阶段来考虑
☑些具体的分析原则：
◆分析模型使用业务语言
◆分析类和关系等应该是业务中明确存在的
◆分析是对需求模型的重新表述，是以理想化的方式来实现用例行为，不考虑技术实现
◆分析侧重于系统主要部公，关注核心的业务场景；对支撑性行为、非功能需求等不做深入的分析

![image-20220423135952871](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220423135952871.png)

### 从用例开始分析迭代

☑迭代开发是现代软件开发的主流，而迭代的基础就是用例
☑从用例开始分析基本思路
◆用例分级：根据风险、重要性以及项目组的能力确定用例以及用例相关路径的优先级
☑早期迭代关注的重点（架构）
◆核心业务的主要部分
◆系统架构有重要影响
◆影响系统性能等其他关键非功能需求的部分
◆存在高风险的部分，如新技术、新产品

![image-20220423140127634](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220423140127634.png)



![image-20220423140158982](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220423140158982.png)

### 分析阶段的用例一用例实现

☑用例实现(UML2协作，Collaboration)是设计（分析）模型中系统用例的表达式
	◆使用构造型<<use-case realization>>,EA中直接使用协作(Collaboration)来表示
	◆描述了对象间的协作以完成用例目标
	◆将用例模型中的用例和设计（分析）模型中的类和关系连接在一起
	◆说明了每个用例必须用那些类来实现
☑用例实现提供了从分析和设计到需求的可跟踪性

![image-20220423140514856](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220423140514856.png)

## 架构分析

☑架构分析的过程就是定义系统高层组织结构和核心架构机制的过程
◆1.定义系统高层组织结构一备选架构
◆2.确定系统通用架构机制一分析机制
◆3.提取系统的关键抽象以揭示系统必须能够处理的核心概念一关键抽象
◆4.创建用例实现来启动用例分析一用例实现

### 构造用例实现

#### 1.定义备选架构

☑定义备选架构
◆架构的初始草图
◆初步定义系统的分层与组织
◆初步定义一组在架构方面具有重要意义的元素，以作为分析的基础
◆初步定义一组分析机制
◆定义要在当前迭代中处理的用例实现

#### 备选架构模式

☑架构模式表示了对软件系统的一个基础结构组织形式。它提供了一套预定义子系统，详细说明它们的职责，并且包括组织它们之间的规则和指南
◆层
◆模型-视图-控制器(M-V-C)
◆管道和过滤器
◆黑板

#### 分层架构动机

☑将应用逻辑作为单独的构件从系统中分离出来，以便这些构件在其他系统中能得到重用
☑将各个层次分配到各个不同的物理计算节点，或者分配给不同的进程。这样可以改善系统性能、更好地支持客户和服务器系统中的信息共享和协调
☑将不同层的开发任务在开发者之间适当地分配，这可以有效地利用开发人员的专长和开发技巧，并且能够提高兼行涯发熊丸

![image-20220423145658105](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220423145658105.png)

#### B-C-E三层架构解析

☑以构造型<<ayer>>表示系统不同层次
☑以B-C-E三层划分系统三类处理逻辑
◆边界层(Boundary)负责系统与参与者之间的交互
◆控制层(Control)处理系统的控制逻辑
◆实体层(Entity)管理系统使用的信息
☑层之间建立依赖关系

#### 2.架构机制

☑架构机制是对通用问题的决策、方针和实践
◆架构机制描述了针对一个经常发生的问题的一种通用解决方案
◆作为系统架构的一部分，架构机制常常集中和定位在系统的非功能需求上
☑三类架构机制
◆分析机制（概念）
◆设计机制（具体)
◆实现机制（实际)

#### 常见的分析机制

☑持久性(Persistency)
☑分布(Distribution)
☑安全性(Security)
☑遗留接口(Legacy Interface)
☑事务管理(Transaction Management)
☑进程控制和同步(Process Control and
Synchronization)
☑通信(Communication)
☑

#### 3.关键抽象

☑关键抽象是一个通常在需求上被揭示的概念，系统必须能够对其处理
◆来源于业务，体现了业务的核心价值，即业务需要处理哪些信息；这些信息所构成的实体即可作为初步的实体分析类
◆领域专家建立系统的初始关键抽象候选集合
◆再结合业务对象模型、需求和词汇表等业务文档资料进行补充和完善
◆通过一个或多个类图来展示关键抽象，并为其编写简要的说明

#### 4.创建用例实现

☑用例实现(UML2协作，Collaboration)是设计（分析）模型中系统用例的表达式
◆使用构造型<<use-case realization>>,EA中直接使用协作(Collaboration)来表示
◆描述了对象间的协作以完成用例目标
◆将用例模型中的用例和设计（分析）模型中的类和关系连接在一起
◆说明了每个用例必须用那些类来实现
☑用例实现提供了从分析和设计到需求的可跟踪性

#### 构造用例实现

☑构造用例实现是分析最核心的工作
◆获得实现用例行为所必须的分析类
◆利用这些分析类来描述其实现逻辑
☑针对每一个用例实现：
◆1.完善用例文档
◆2.识别分析类
,边界类、控制类和实体类
◆3.分析交互
,将用例行为分配给类
◆4.完成参与类类图
,参与用例实现的类的类图
◆5.处理用例关系

##### 1.完善用例文档

☑需求阶段的用例文档是从用户角度看待用户问题，侧重描述交互的1、4步
☑分析阶段则需要从系统角度看待用户问题重点关注交互的2、3步：即系统如何响应用户请求；此时可以对需求阶段用例文
档中系统的处理流程进一步细化
◆获取理解系统必要的内部行为所需的其他信息：从“黑盒”到“白盒”的过渡
◆有些情况下，可能找到一些不正确或不易理解的需求；此时，原始的用例事件流也需要进行更新

##### 2.从用例行为中识别分析类

☑在对象技术中，一个用例的全部行为
都是由相应的类来完成的
☑这些行为必须被分配到类中
◆分析阶段就是对这个过程的第一次尝试
◆这是一个从“无”到“有”的跨越

**分析类**

☑分析类代表了“系统中必须具备职责和行为的事物”的早期概念模型
☑分析类处理主要的功能需求，模型化问题域对象
☑根据备选架构定义三类分析类
◆边界类：系统及其参与者的边界
◆控制类：系统的控制逻辑
◆实体类：系统使用的信息

##### 边界类

☑边界类表示系统与参与者之间的边界
◆代表系统与环境的交互
◆是接口和外部事物的中间体
◆构造型<<boundary>>
☑两类边界类
◆用户界面类
◆系统和设备接口类

每对参与者/用例定义一个边界类

##### 控制类

☑控制类表示系统的控制逻辑
◆系统行为的协调器
◆构造型<<control>>
☑识别控制类
◆在系统开发早期，为一个用例定义一个控制类，负责该用例的控制逻辑
◆针对复杂用例，可为备选路径分别定义不同控制类

☑通常，每个用例定义一个控制类
◆随着分析的继续，一个复杂用例的控制类可以发展为多个

##### 实体类

☑实体代表了待开发系统的核心概念
☑实体类提供了另一个理解系统的观点
◆显示了系统的逻辑数据结构
◆传统的面向对象方法就是从这个角度进
行分析和设计
☑使用构造型<<entity>>
☑可以从以下中找到实体类
◆用例事件流（需求）、业务模型（业务建
模)、词汇表（需求）

**识别实体类**
☑分析用例事件流中的名词、名词短语找出系统所需的实体对象，这些名词可能是：
◆对象、对象的特征和状态
◆参与者、描述信息、系统之外的
☑从这些名词、名词短语中进行筛选，抽取出系统对象，并抽象成类
◆综合考虑在系统中的意义、作用和职责
☑对于所识别的类进行命

**指南：名词筛选法识别实体类**
☑名词筛选法识别实体类的基本思路：将用例事件流作为输入，找出名词或名词性短语，形成了实体类的初始候选列表
◆合并那些含义相同的名词
◆删除那些系统不需要处理的名词
◆删除作为参与者的名词
◆删除与实现相关的名词
◆删除那些作为其他实体类属性的名词
◆对剩余的名词，综合考虑它在当前用例以及
整个系统中的含义、作用以及职责，并基于此确定合适的名字，作为初始实体类存在

**识别实体类**
☑在实际应用中，依赖于类似项目的经验和对业务及系统的理解（或领域专家意见），来获取系统关键抽象，作为初始的实体类，再辅以名词筛选法补充完善实体类
☑此外，还有其他实体类的来源
◆系统原始需求书/问题描述
◆该领域相关文献、专家意见或个人知识
◆过去的类似系统
☑后续职责分配中可能识别一些新的实体类
☑实体类的命名要用该领域中最经常使用的名称

#### 3.将用例行为分配给类

☑面向对象系统是通过对象间的协作实现需求的
◆需求阶段通过自然语言描述
◆分析设计阶段采用图形化方式描述协作过程
◆利用交互图将用例行为分配给分析类

**顺序图Sequence Diagram**
☑顺序图是一种交互图，描述对象之间的动态交互关系，着重体现对象间消息传递的时间顺序
◆对象(Object):对象、对象的生命线、对象的执行发生和对象的删除
◆消息(Message):简单消息、同步消息、异步消息、返回消息

![image-20220423152838830](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220423152838830.png)

**利用顺序图进行职责分配**
☑以B-C-E的方式绘制顺序图，并以Control类将控制逻辑隐藏起来
☑可以将对象之间的信息传递以“//”的方式标记，表明初步进行类的职责分配，该项信息尚未制定完全
☑可以利用白话的方式将信息进行的说明，在信息长度不够时，可以加上UML的注释来做说明
☑分析阶段顺序图中所找出的对象可以放置到分析阶段的类图上，反之，也可以由分析阶段的类图上找出顺序图中所需的对象

**指南：将职责分配到分析类**
☑以分析类的构造型作为分配标准
◆边界类：承担与参与者进行通信的职责
◆控制类：承担协调用例参与者与数据操作之间交互的职责
◆实体类：承担对被封装的内部数据进行操作的职责

☑专家模式：将职责分配给具有当前职责所需要的数据的类
◆如果一个类有这个数据，就将职责分配给这个类
◆如果多个类有这个数据

​	将职责分配给其中的一个类，并对其它类增加一个关系
​	将职责放在控制类中，并对需要该职责的类增加关系
​	创建一个新类，将职责分配给该类，并对需要该职责的类增加关系

**顺序图中的交互片段**
☑顺序图主要用于描述顺序的执行流程对于简单分支或循环，可直接描述
◆执行的条件用[]括起来描述，表示条件为真时才执行，否则不执行
◆循环条件要在条件前加上“*”来描述表示条件为真时重复执行
◆其他约束用{}括起来
☑UML2为顺序图提供了交互片段来描述分支、循环、并发等备裴题度的情况软件

#### 4.VOPC图

☑对于每个“用例实现"都存在若干张交互图进行描述，而这些交互图中会使用到各种分析类的对象
☑对于每一个“用例实现”，需要绘制与之相关的类图，即VOPC图
◆参与类类图(VOPC,View Of ParticipatingClasses Class Diagram)
◆类图中的元素来自于交互图中的对象
◆类图中的关系来自于交互图中的消息（和业务对象模型)，分析阶段主要使用关联关系，也可根据业务模型引入泛化、聚合等关系

## 定义分析类

☑定义分析类
◆最终目标是从系统的角度明确说明每一个分析类的职责和属性以及类之间的关系，从而构造系统的分析类视图
◆并根据这些视图来描述和理解目标系统，从而为后续的设计提供基本的素材
◆在构造用例实现的过程中已经获得了分析类的基本定义，但那是在单个用例实现的基础上完成的，主要关注的是用例事件流的交互过程，而对单个类自身的特征和行为缺少统一的考虑

### 定义分析类的过程

☑从单个分析类入手，完成如下工作：
◆1.定义职责
◆2.定义属性
◆3.定义关系

​	3.1关联关系
​	3.2聚合关系
​	3.3泛化关系
◆4.限定分析机制
◆5.统一分析类

### 1.定义分析类的职责

☑职责是要求某个类的对象所要履行的行为契约，在设计中将演化为类的操作（一个或多个）
☑获取类的职责
◆从交互图中的消息
◆从非功能需求中
☑分析阶段表示类的职责
◆分析"操作，约定分析操作前加/"
◆文本描述

#### 利用文本方式描述职责

☑可以直接利用文字描述单个类的职责
☑传统的面向对象方法提供了一种“CRC卡”的技术可以更好地描述类的职责
☑CRC卡由三部分组成，即类(Class)、职责(Responsibility)、协作(Collaborator)

#### 保持类职责的一致性

☑从每个用例实现中发现类的职责，之后，要从系统整体角度定义类的职责
◆类中的互不相干职责
◆跨类的职责冗余
◆一个职责的类
◆没有职责的类
◆行为的更佳分配
◆与许多其它类交互的类

### 2.定义分析类的属性

☑属性(Attribute)是类的已命名属性，用来存储对象的数据信息，是没有职责的原子事物
◆属性名是一个名词，清楚地表达了属性保留的信息
◆可以利用文字详细说明属性中将要存储的相关信息
◆属性类型应来自业务领域，与编程语言无关
☑从以下几个方面来定义属性：
◆识别分析类的过程中，也可同时发现类的属性，包括：接在所有格后面的名词或形容词（即某某的属性）、不能成为类的名词以及字段列表中所描述的数据需求
◆作为一般业务常识，是否有从类职责范围考虑所应包括的属性
◆该业务领域的专家意见以及过去的类似系统

### 3.定义分析类的关系

☑对象不能孤立地存在，它们之间需要频繁地通过消息进行交互从而执行有用的工作，并达到用例的目标
☑为此，相应的类之间也应该存在特定的关系来支持这种交互过程
◆3.1关联关系：协作关系
◆3.2聚合关系：整体-部分
◆3.3泛化关系：抽象-具体

#### 3.1关联关系

☑关联是类之间的一种结构化关系，是类之间的语义联系
◆表明类的对象之间存在着链接
◆对象是类的实例，而链接是关联的实例
☑识别关联的基本思路
◆从交互模型中发现对象之间的链接，从而在相应的类上建立关联关系：如VOPC图中关联关系
◆从业务领域出发，分析领域中所存在的实体类之间的语义联系为那些存在语义联系的类之间建立关联关系：如实体类之间的各种语义联系

##### 细化关联关系

☑关联具有：名称、端点和角色名、多重性
◆名称：动词短语
◆端点和端点名
◆多重性表达式：`*`，1.*，1-40,5,3,5,8，…

##### 自反关联

☑自反关联是指一个类自身之间存在关联，它表明同一个类的不同对象之间存在链接

##### 关联类

☑关联类(Association Class)
◆是一种被附加到关联上的类，用来描述该关联自身所拥有的属性和行为
◆当某些属于关联自身的特征信息无法被附加到关联两端的类时，就需要为该关联定义关联类

#### 3.2聚合关系

☑聚合(Aggregation)关系是一种株殊的关联关系
◆除了拥有关联关系所有的基本特征之外
◆两个关联的类还分别代表“整体”和“"部分”，意味着整体包含部分
☑可以在已有的关联关系基础上，通过分析两个关联的类之间是否存在如何语义来识别聚合关系
◆A(整体)由B(部分)构成
◆B(部分)是A(整体)的一部分

#### 3.3泛化关系

☑泛化是指类间的结构关系、亲子关系
◆子类继承父类所具有的属性、操作和关联
☑分析阶段的泛化关系主要来自与业务对象模型，针对实体类，结合业务领域的需求，从两个方面来提取泛化关系：
◆是否有类似的结构和行为的类，从而可以抽取出通用的结构和行为构成父类
◆单个实体类是否存在一些不同类别的结构和行为，从而可以将这些不同类别的结构抽取出来构成不同的子类

### 4.限定分析机制

☑建立分析类和分析机制的对应图

![image-20220423161516458](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220423161516458.png)

![image-20220423161609948](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220423161609948.png)

### 5.统一分析类

☑类体现了系统的静态结构，通过分析类图体现软件静态结构
☑统一分析类的目的是确保每个分析类表示一个单一的明确定义的概念，而不会职责重叠
☑在分析工作完成之前，需要过滤分析类以确保创建最小数量的新概念

### 再说分析类图

☑分析阶段的重点在于找出体现系统核心业务所需数据的实体类，而界面和业务逻辑细节分别由边界类和控制类隐藏

☑分析阶段的重点在于找出体现系统核心业务所需数据的实体类，而界面和业务逻辑细节分别由边界类和控制类隐藏
☑在很多UML模型中，分析阶段的工作就是找到这些实体类
☑这些实体类组成系统慨念模型（分析类图）
☑通过各个用例的VOPC图，删除那些没有引用的实体类，即可得到由实体类组成的分析类图，这些是分析的关键

# 面向对象的设计原则

☑面向对象的设计原则
◆是面向对象设计的基本指导思想
◆是评价面向对象设计的价值观体系
◆是设计模式的出发点和归宿
☑面向对象的设计原则是构造高质量软件的出发点

**设计目标**

☑构造出高质量软件，以保持系统稳定
☑设计目标
◆高可用性
◆高可靠性
◆高性能
◆高可支持性

◆......

**设计质量：培养灵敏的嗅觉**
☑糟糕的设计总是散发出臭味，让人不悦
◆判断一个设计的好坏，主观上能否让你的合作方感到心情愉悦，是最直观的标准
☑设计开发人员要培养嗅觉，当你看到UML图或者代码，感到杂乱、繁琐、郁闷的时候，你可能正面对一个糟糕的设计
☑这种嗅觉是在实践开发中培养起来的，而面向对象设计原侧对此加以归纳和总结

**设计质量：坏的设计**
☑什么是坏的设计？
◆僵硬性(Rigidity):刚性，难以扩展
◆脆弱性(Fragility)：易碎，难以修改
◆牢固性(Immobility)：无法分解成可移植的组件
◆粘滞性(Viscosity)：设计和环境
◆不必要的复杂性(Needless Repetition):Ctrl C+Ctrl V
◆晦涩性(Opacity）:不透明，很难看清设计者的真实意图

**设计质量：好的设计**
☑什么是好的设计？
◆容易理解
◆容易修改和扩展
◆容易复用
◆容易实现与应用
◆简单、紧凑、经济适用
☑让人工作起来心情愉快的设计
☑设计原则是提高设计质量的基本原则

☑LSP:Liskov替换原则
The Liskov Substitution Principle
☑OCP:开放-封闭原则
The Open-Close Principle
☑SRP:单一职责原则
The Single Responsibility Principle
☑ISP:接口隔离原侧
The Interface Segregation Principle
☑DIP:依赖倒置原则
.The Dependency Inversion Principle
☑......

## LSP（里氏替换原则）

☑LSP(The Liskov Substitution Principle,Liskov替换原则)

◆“若对于类型S的任一对象01，均有类型T的对象02存在，使得在T定义的所有程序P中，用01替换o2之后，程序的行为不变，则S是T的子类型”
◆如果在任何情况下，子类（或子类型)或实现类与基类都是可以互换的，那么继承的使用就是合适的。为了达到这一目标，子类不能添加任何父类没有的附加约束
◆子类对象必须可以替换基类对象”

在可能的情况下，由抽象类（接口）继承

### 抽象类与具体类

√只要有可能，不要从具体类继承
√行为集中的方向是向上的(抽象类）
√数据集中的方向是向下的（具体类）

### 由LSP引发的思考

☑如何评价设计质量
◆从LSP的判定规则可以看出，判断继承层次是否合适并不是从参与继承的类本身来判定的，而是从**使用该继承层次的程序**入手
◆评价一个设计方案的质量，不能完全孤立地看这个方案本身，应该根据设计**使用者提出的合理假设**来审视

## OCP

☑OCP(The Open-Close Principle,开放-封闭原则)
◆软件实体(类、模块、函数等)应该是可扩展的，但是不可修改的
☑特征：
◆对于**扩展是开放的**(Open for extension):模块的行为可以扩展，当应用的需求改变时，可以对模块进行扩展，以满足新的需求
◆对于**更改是封闭的**(Closed for modification):对模块行为扩展时，不必改动模块的源代码或二进制代码

☑OCP的关键在于抽象
◆抽象技术：abstract class,Interface
◆抽象预见了可能的所有扩展闭
◆由抽象可以随时导出新的类（开）

### 关于OCP

☑OCP是OOD中很多说法的核心
◆如果这个原则应用得有效，应用程序就会具有更多的可维护性、可重用性以及可健壮性
◆很多设计模式都是遵从这个原则而提出来的
☑SP是OCP成为可能的主要原则之一
◆正是子类型的可替换性才使得使用基类类型的模块在无需修改的情况下就可以扩展

## SRP

☑SRP(The Single Responsibility Principle,单一职责原则)
◆就一个类而言，应该仅有一个引起它变化的原因
☑有关类的职责分配问题，是面向对象设计中最重要的基本原则
"A critical,fundamental ability in OOA/D is to skillfully
assign responsibility to software components."
Craig Larman

### SRP本质

☑SRP体现了内聚性(Cohesion)
◆内聚性：一个模块的组成元素之间的功能相关性
☑类的职责定义为“变化的原因”，每个职责都是变化的一个轴线；
◆当需求变化时，该变化会反映为类的职责的变化

◆如果一个类承担了多于一个的职责，那么引起它变化的原因就会有多个

## ISP

☑ISP(The Interface Segregation Principle,接▣隔离原则)
◆客户不应该依赖他们不用到的方法，只给每个客户它所需要的接口
◆为了避免“肥接口(fat interface)",应当以一个类实现多个接口， 而各客户仅仅获知必须的接口

**解决方案：分离接口**
☑使用委托分离接口：Adapter模式
☑使用多重继承实现)分离接口

### ISP本质

☑使用多个专门的接口比使用单一的接口好
☑一个类对另一个类的依赖性应当是建立在最小的接口上的
☑避免接口污染(Interface Pollution)

## DIP

☑DIP(依赖倒置原则，The Dependency Inversion Principle)
◆高层模块不依赖于低层模块，二者都依赖于抽象
◆抽象不依赖于细节，细节依赖于抽象
◆针对接口编程，不要针对实现编程
◆又称控制反转(IoC,Inversion of Control)、依赖注入
☑Booch：所有结构良好的面向对象架构都具有清晰的层次定义，每个层次通过一个定义良好的、受控的接口向外提供了一组内聚的服务

### 启发式原则

☑“依赖于抽象”--程序中所有依赖关系都应该终止于抽象类或者接口
☑启发式原则：
◆任何变量都不应该拥有指向具体类的指针或者引用
◆任何类都不应该从具体类派生
◆任何方法都不应该改写其任何基类中已经实现的方法

### DIP的本质（做中间件）

☑通过抽象提取业务本质，并建立一个稳定的结构描述这个本质
☑对于具体的业务规则的处理是在这个本质的基础上的扩展
☑技术、工具、意识形态等的发展可能使业务规则不断变化，但本质不变；而DIP则帮助我们轻松的适应这些变更

## 不好的类设计

### 泡泡类(Vapor Classes)

☑所谓泡泡类，就是没有带来任何好处的类
◆封装成类的目的是什么？
☑考虑Light类：

这种类的存在似乎是只是让代码变得简洁好看一些，从实际作用来看，毫无价值

### 无用的抽象

☑考虑UML类图中的两个继承关系，
试着为两个基类（或接口）写出代码

看上去似乎很不错，问题是：谁会使用这两个类？

### 上帝类(God Classes）

☑全部逻辑都集中在CoffeeMaker类中，这个类就是整个程序，其他的类都是臆想出来的、没有用的、多余的
☑这种集中了程序全部或几乎全部逻辑的类，称为上帝类(God Classes)
☑如果你的设计中出现了上帝类，那说明设计得很糟糕

### 关于抽象

☑在软件设计中，抽象有两层含义：
◆提供下层机制的良好抽象，使高层次的操作无需顾及到下层的细节问题。比如JVM、比如CORBA
◆抓住客观世界的本质，把握和描述这个本质，建立抽象的概念，通过对这种概念的描述，隔离可能发生的变化
	在这个意义上，“面向对象”的多态机制提供了强大的工具，大大超越了“面向过程”和“基于对象”所能够达到的层次

### 抽象：把握现实世界的本质

☑抽象：透过现象看本质
◆抓住客观世界的本质，把握和描述这个本质，建立抽象的概念，通过对这种概念的描述隔离可能发生的变化
◆如何认识世界，这是个哲学认识论的命题，在面向对象设计里却有着至关重要的地位
☑面向对象的设计目标是提高系统的可维护能力，而如何找到系统的稳定状态呢？

### 通信图Communication Diagram

☑通信图描述对象之间消息的连接关系，侧重说明哪些对象之间有消息传递
◆通信图中对象用对象图符表示，箭头表示消息发送的方向，编号标明消息的执行顺序

​		顺序法：简单编号方案，从1开始，由小到大，顺序排列
​		层次法：小数点制编号方案
◆与顺序图相比，通过编号来看消息的执行顺序比较困难，但通信图中对象间灵活的空间布局可以更方便地展示动态连接关系等有用信息

### 通信图-推荐的使用场合

☑通信图是一种交互图，而交互图主要用于
◆描述对象之间的动态协作关系通信图)以及协作过程中的行为序（顺序图)
◆常常用来描述一个用例的行为，显示该用例中所涉及的对象以及这些对象之间的协作和消息传递情况

### 通信图与顺序图对比

☑功能完全相同，可以利用工具进行互相转换
☑侧重点不同，根据实际情况选择一种合适的图进行用例分析和设计

顺序图

☑显示了消息的明确顺序

☑更适用于全部流的可视

☑更适用于实时规约和复

通信图

☑显示除交五之外的关系

☑更适用于协作模式的可化视化

☑更适用于一个既定对象杂场景上的所有效果的可视化

☑更易于头脑风暴讨论使

# 面向对象的设计模式

## 模式与设计模式

### 模式

模式是对成功应用经验的总结与复用
模式在现实生活中随处可见

### 模式的特点

☑模式可以解决实际问题
◆模式可以解决具体问题，而不只是抽象原则或策略
☑模式是经受过考验的概念
◆模式有实际解决问题的记录，而不是理论上的思索或推导
☑模式表达了一种关系
◆模式不仅描述了模块，而且描述了更深层的系统结构与机制
☑模式具有很强的人文因素
◆最佳模式通常具有良好的美感兼实用性
☑......

### 设计模式

☑设计模式是在构件设计阶段，通过定义类或特定对象之间
的结构和行为，从而解决每类设计问题的通用解决方案
☑设计模式的产生
◆设计就是解决方案一对某个问题的解决
◆如果某个解决方案对某类问题都很有用
◆这时就把它总结出来
◆这就产生了设计模式

### 设计模式

☑是：
◆优秀的设计范例
◆从优秀设计方案中发现和总结出来的经验
◆在实践中反复出现的设计问题的优秀解决方案
◆设计者相互交流的基本术语：设计语言
◆培养优秀设计师的一条捷径
☑不是：
◆面向对象设计的框架
◆可供简单组合的设计元件
◆发明创造出来的创新思路
◆解决面向对象设计问题的完整方案

### 设计模式s设计原则

☑设计原则是面向对象设计的指导思想
◆设计模式只是更好地遵循这一指导思想的手段之一
☑设计模式是面向对象设计的具体技术
◆设计模式抽象出成功设计的共性，并进行分类与标识
◆设计模式通过描述对象、协作和职责将设计中的意图抽取出来

### 设计模式Vs架构模式

☑架构模式所研究的对象粒度更大
◆架构模式可以是为单个应用而设计
◆设计模式通常是为了多个软件产品的生产线而设计
☑某些专家也将软件体系结构看作抽象层次更高的模式
◆架构模式（宏模式）、设计模式（微模式）与习惯用法三个层次

## GoF模式

☑时间
◆1994
☑人物
◆Erich Gamma、John Vlissides、Ralph Johnson、Richard Helm
◆合称GoF(Gang of Four)
☑事件
◆Design Patterns:Elements of Reusable Object-Oriented Software(设计模式-可复用面向对象软件的基础)的出版

◆提出23种设计模式，统称为GoF模式

### GoF模式分类

☑根据模式的目的（用来完成什么工作的）
◆创建型模式
◆结构型模式
◆行为型模式
☑根据模式的作用范围（是处理类还是处理对象的）：
◆类模式
◆对象模式

☑创建型模式
◆创建型类模式将对象的部分创建工作延迟到子类
◆创建型对象模式将它延迟到另一个对象中
☑结构型模式
◆结构型类模式使用继承机制来组合类
◆结构型对象模式描述了对象间的组装方式
☑行为型模式
◆行为型类模式使用继承描述算法与控制法
◆行为型对象模式则描述一组对象怎样协作完成单个对象无法完成的工作

### 创建型模式

☑1工厂方法factory method
◆定义一个用于创建对象的接口，让子类决定实例化哪一个类

☑2抽象工厂abstract factory
◆提供一个接口，不必指定具体类即可创建一族相关的或相依赖的对象

☑3生成器builder
◆将一个复杂对象的构建与它的表示分离，从而同一构造过程可以创建不同的表示

☑4原型prototype
利用一个原型实例指定创建对象的类别，从而创建该原型的新对象副本

☑5单例singleton
◆保证一个类只有一个实例，并提供访问它的一个全局访问点

### 结构型模式

☑6适配器adapter
◆将一个类的接口转换成客户希望的另外一个接口，使因为接口不兼容的类可以互相工作

☑7桥bridge
◆将抽象部分与实现部分分离，使之可以独立的变化

☑8组合composite&
◆将对象组合成树型结构表示“部分-整体”层次结构，允许客户程序以统一方式处理单个对象与组合对象

☑9装饰decorator
◆动态地给一个对象增加附加职责

☑10外观facade
◆为一个复杂的子系统提供一个简单的、统一的接口，这一接口使得子系统更易使用

☑11享元flyweight
◆运用共享技术有效支持大量细粒度对象

☑12代理proxy
◆为一个对象提供一个代理或占位符，从而控制对该对象的访问

### 行为型模式

☑13解释器interpreter
◆设计一种语言，定义其语法表示并提供一个基于该语法的解释器

☑14模板方法template method
定义一个操作的算法框架，而将一些步骤延迟到子类中表达；即允许子类重定义算法中的某些步骤，而无需改变算法的结构

☑15职责链chain of responsibility
◆使多个对象都有机会处理请求，从而避免请求的发送者与接收者之间的耦合关系

◆将接收对象连成一条链，并沿着这条链传递请求，直到有一个对象处理这个请求为止

☑16命令command
◆将一个请求封装为对象，从而以不同请求将客户程序参数化；可以将请求排队或是记录请求日志，并支持undo操作

☑17迭代器iterator
◆提供一种方法顺序访问一个聚和对象中各个元素，而又不暴露该对象的内部表示

☑18中介者mediator
◆用一个中介者来封装一系列的对象交互。使各对象不需要显式的相互引用，从而使耦合松散，而且可以独立改变它们的交互

☑19备忘录memento
在不破坏封装性的前提下，获取对象的内部状态并将其外部化，从而对象可以在以后恢复到原状态

☑20观察者observer
◆在对象之间定义一对多依赖，从而一个对象改变状态时其依赖对象都可被通知并自动地更新

☑21状态state
◆当对象的内部状态改变时，允许该对象改变其行为，就好像更换了类一样
☑22策略strategy
◆定义一系列的算法，然后把它们封装起来，使它们可以相互替换。即算法可独立于使用它的客户而变化

☑23访问者visitor
◆对一个对象结构的所有元素执行操作，无须改变所操作元素的类即可定义一个新操作

### 模式思维

☑设计模式最根本的意图是适应需求变更
☑设计模式的核心思维
◆应对变更的直接手段就是封装变更，从而是变更的影响降到最小
◆封装复杂性，对外提供简单接口，通过多态包容的特性扩展新功能来应对变更
◆多态包容：宿主对象中包含抽象基类（或接口)的引用，而实际行为委托给这个引用所指向的实际对象，从而使这些行为可以根据该引用所指向的实际对象不同而不同

### 设计模式的实现思路

☑增加间接层
◆“任何问题都可以通过增加一个间接层次来解决。(抽象层)
◆通过增加一个间接层（多为抽象层），将具体类之间的关系转变为具体类和抽象层之间的关系，使依赖止于抽象，从而设计出高质量的方案
☑针对接口编程，不针对实现编程
◆具体类之间通过接口相互通信
◆是对增加间接层设计思路的进一步表述
☑优先使用聚合，而不是继承
◆利用聚合能在运行时动态修改的特点应对变更

◆聚合抽象类（接口），并继承（或实现）具体类来扩展相应的功能，从而动态改变聚合行为

### 学习和使用设计模式

☑设计模式根本的意图是适应需求变更
◆在需求频繁变更的地方（变化点）引入设计模式应对变更
☑实践设计模式
◆“无招胜有招
◆不是简单的背诵和抄袭的过程。每个设计模式都有其应用背景（意图）和解决方案，只有在需要的场合选择合适的模
式才能有效地发挥模式的作用，过度地滥用模式也会陷入过度设试

更多的模式
☑Null Object
☑Abstract Server
☑Active Object
☑......

## 职责分配模式

### 职责分配

☑职责和职责分配是面向对象分析何设计的最核心工作，合理的职责分配直接决定了设计的质量
☑用于指导职责分配的原则和模式
◆SRP、ISP
◆GRASP

### GRASP

GRASP (General Responsibility Assignment SoftwarePattern, 通用职责分配软件模式)
☑GRASP模式描述了将职责分配给对象的**基本原则**，这些原则被表示成模式

### 9种GRASP模式

Craig Larman,Applying UML and Patterns(2nd)
◆创建者(Creator)
◆信息专家(InformationExpert)
◆低耦合(Low Coupling)
◆控制器(Controller)
◆高内聚(High Cohesion)）
◆多态（Polymorphism)
◆纯虚构（Pure Fabrication)
◆中介者(Indirection)
◆受保护变化模式(Protected Variations)

### GRASP:信息专家模式

☑将职责分配拥有履行一个职责所必需信息的类，即信息专家
◆专家模式在职责分配中的应用比任何其他模式都广泛，它是面向对象的设计中的一个基本指导原则
◆专家不是一个模糊或者新奇的设计概念，它表述了最普遍的一种“直觉”即对象所能完成的工作要依赖于它所掌握的信息
☑优点：
◆封装能够得以维持，因为对象只使用他们自己包含的信息来完成任务（低耦合)
◆系统行为只分布在具有所需信息的类中（高内聚）
☑别名：
◆把责任交给数据；谁知道谁来干；拟人化；自己做.…

### GRASP:受保护变化

☑识别可预知的变化或不稳定点；通过分配职责来创建围绕它们的稳定接口
◆PV是大多数编程和设计的机制和模式的基本动机之一，它使得
系统能适应和隔离变化
◆PV与开放-封闭原则思想是一样的，只是侧重点稍异
☑优点
◆低耦合

### Demeter准则

☑作为PV模式的一个特例，Demeter准则是获得受限结构变化的一种机制，它给出了在一个方法内应该向哪些对象发送消息的限制
☑Demeter准则(Law of Demeter）:给出了在一个方法内应该向哪些对象发送消息的限制，规定在一个方法中，消息只能发往以下对象
◆对象本身
◆该方法的一个参数
◆对象本身的属性
◆对象本身的一个属性集合中的元素
◆该方法内创建的对象
☑别名：不要和陌生人讲话

## 其他问题

### 模式与编程语言

☑模式不依赖于编程语言
☑某种程度上来说，模式构成了一种设计语言，它比编程语言更进了一步，使开发人员可以彼此交流设计思想
☑可以用任何语言实现任何设计模式
◆对于特定的模式，用某些语言要比用其他语言更容易实现

### 重构

☑重构：改善既有代码的设计（第2版）
◆Refactoring: Improving the Design of Existing Code
☑所谓重构是这样一个过程：在不改变代码外在行为的前提下，对代码做出修改，以改进程序的内部结构
☑“在代码写好之后改进它的设计"

#### 关于重构

☑重构源于Smalltalk,Smalltalk中提供了Refactoring Browser来支持重构
☑重构成为XP(eXtreme Programming)中最重要的实践过程
◆开始时，如果没有看出抽象的必要，可以先实现一个简单的，当第一次被需求触发而显现出抽象的必要时，这时机会就来了，需要运用设计原则或模式，提取抽象接口
☑重构的目标：使软件模块（类、构件等）具有它合适的职责
◆运行起来所完成的功能
◆应对变化
◆和阅读它的人进行沟通

### 设计模式与重构

☑设计模式为重构提供了目标
◆重构工作依据设计模式来进行
☑重构使设计模式重新闪现光辉
◆追求完美的设计却无法写出实用的代码，而“实用”使软件压倒一切的要素
◆Joshua Kerievsky在"模式与XP指出：在设计前期使用模式常常会导致过度工程
◆简单设计，再重构
◆重构到模式(Refactoring to Patterns)

# 架构设计

