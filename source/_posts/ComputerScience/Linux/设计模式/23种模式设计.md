## 创造型模式

### 工厂方法模式(虚拟构造函数)

#### 目的

在父类中提供一个创建对象的方法，允许子类决定实例化对象的类型

#### 运用场景举例

现有一个手机制造厂商，需要生产A型手机和B型手机。那么我们如何用工厂方法模式来描述以上作业流程呢？

根据工厂方法模式的目的可以得，手机制造厂商需要将A型手机的生产和B型手机的生产分别放入转给手机生产流水线A和手机生产流水线B，并且手机生产商还需要有A型手机和B型手机的生产标准。

#### 工厂方法模型类图

[![L5frkR.png](https://s1.ax1x.com/2022/04/24/L5frkR.png)](https://imgtu.com/i/L5frkR)

#### 工厂方法模式C++代码实现

##### 用普通类进行实现

`creator.h`

```c++
#ifndef CREATOR_H
#define CREATOR_H

class Product;

//实现业务相关的核心逻辑
class Creator
{
public:
    //该函数在内存的存在方式：当该类实例化的时候，即调用构造函数的时候，编译会在该对象的内存空间中存放一个虚函数指针vfptr用于指向一个虚函数表vftable,vftable中存放的是虚函数的首地址即虚函数名，由于此函数为纯虚函数，所以vftable中的存放函数名的空间是空着的，因此，当一个子类重写该函数的时候，就会将子类的同名函数的首地址即函数名存放到vftable中预留的空闲空间中，因此可以通过父类的指针指向子类的对象来使用该同名函数。
    virtual Product* createProduct()=0;
    void doOthersSomething();
    virtual ~Creator()=0;
protected:
     Creator();//只允许继承了该类的子类可以调用，即只允许子类实例化该类，外界无法通过无参构造函数进行该类的实例化
};
class ConcreteProuductA:public Creator
{
public:
    ConcreteProuductA();
    virtual Product * createProduct() override;
    ~ConcreteProuductA();
};
class ConcreteProuductB:public Creator
{
public:
    ConcreteProuductB();
    virtual Product * createProduct() override;
    ~ConcreteProuductB();
};

#endif // CREATOR_H

```

`product.h`

```c++
#ifndef PRODUCT_H
#define PRODUCT_H
#include <iostream>

class Product
{
public:
    virtual void case01()=0;
    virtual void case02()=0;
    virtual ~Product();
protected:
    Product();
private:
};

class ProductA:public Product
{
public:
    ProductA();
    virtual void case01();
    virtual void case02();
    ~ProductA();
};

class ProductB:public Product
{
public:
    ProductB();
    virtual void case01();
    virtual void case02();
    ~ProductB();
};

#endif // PRODUCT_H

```

`creator.cpp`

```c++
#include "creator.h"
#include <iostream>
#include "product.h"

Creator::Creator(){std::cout<<"Creator constructor"<<std::endl;}
Creator::~Creator(){std::cout<<"Creator destructor"<<std::endl;}

void Creator::doOthersSomething()
{
    Product* pro = createProduct();
    pro->case01();
    pro->case02();
}

ConcreteProuductA::ConcreteProuductA(){std::cout<<"ConcreteProuductA constructor"<<std::endl;}

Product *  ConcreteProuductA::createProduct(){return new ProductA();}

ConcreteProuductA::~ConcreteProuductA(){std::cout<<"ConcreteProuductA destructor"<<std::endl;}


ConcreteProuductB::ConcreteProuductB(){std::cout<<"ConcreteProuductB constructor"<<std::endl;}

Product * ConcreteProuductB::createProduct(){return new ProductB();}
ConcreteProuductB::~ConcreteProuductB(){std::cout<<"ConcreteProuductB destructor"<<std::endl;}

```

`product.cpp`

```c++
#include "product.h"
#include <iostream>

Product::~Product(){std::cout<<"Product constructor"<<std::endl;}
Product::Product(){std::cout<<"Product destructor"<<std::endl;}

ProductA::ProductA(){std::cout<<"ProductA constructor"<<std::endl;}
void  ProductA::case01(){std::cout<<"A::case1"<<std::endl;}
void  ProductA::case02(){std::cout<<"A::case2"<<std::endl;}
ProductA::~ProductA(){std::cout<<"ProductA destructor"<<std::endl;}

ProductB::ProductB(){std::cout<<"ProductB constructor"<<std::endl;}
void ProductB::case01(){std::cout<<"B::case1"<<std::endl;}
void ProductB::case02(){std::cout<<"B::case2"<<std::endl;}
ProductB::~ProductB(){std::cout<<"ProductB destructor"<<std::endl;}

```

`main.cpp`

```c++
#include <iostream>
#include "creator.h"
#include "process.h"
#include <string>
using namespace std;

void test01()
{
   string end=string();
   cout<<"input \"start\" to launch "<<endl;
   cin>>end;
   while(end.compare("end")!=0)
   {
       end.clear();
       cout<<"input \"A\"or\"B\"o\"end\""<<endl;
       cin>>end;
      if(end.compare("A")==0)
      {
          Creator* createA = new ConcreteProuductA();
          createA->doOthersSomething();//业务相关的核心逻辑
      }
      if(end.compare("B")==0)
      {
          Creator* createB = new ConcreteProuductB();
          createB->doOthersSomething();//业务相关的核心逻辑
      }
   }
}

int main()
{
    test01();
    return 0;
}

```



##### 类在内存空间中的分配情况分析

###### productA、productB和Product的关系

[![L5hljO.png](https://s1.ax1x.com/2022/04/24/L5hljO.png)](https://imgtu.com/i/L5hljO)

###### PrdouctA的内存分布

[![L5hM36.png](https://s1.ax1x.com/2022/04/24/L5hM36.png)](https://imgtu.com/i/L5hM36)

###### ProudctB的内存分布

[![L5hQgK.png](https://s1.ax1x.com/2022/04/24/L5hQgK.png)](https://imgtu.com/i/L5hQgK)



###### Product的内存分布

[![L5hK9x.png](https://s1.ax1x.com/2022/04/24/L5hK9x.png)](https://imgtu.com/i/L5hK9x)

###### ProductA、ProductB和Product的代码调用过程

[![L5h3uD.png](https://s1.ax1x.com/2022/04/24/L5h3uD.png)](https://imgtu.com/i/L5h3uD)



##### 用模板进行实现

`main.cpp` 主调文件

```c++
#include <iostream>
#include "creator.hpp"
#include "product.hpp"
#include <string>
using namespace std;

struct Attribute_Str
{
   enum{off,on=1};
   string productName = "Xiaomi";
   int status =on;
   string CPU = "Xiaolong 855";
   string mem = "flash";
   void print()
   {
       cout<<"*****************************"<<endl;
       cout<<"name: "<<productName<<endl;
       cout<<"status: "<<status<<endl;
       cout<<"CPU: "<<CPU<<endl;
       cout<<"memory: "<<mem<<endl;
       cout<<"****************************"<<endl;
   }

};

void test01()
{
   string end=string();
   cout<<"input \"start\" to launch "<<endl;
   cin>>end;
   while(end.compare("end")!=0)
   {
       end.clear();
       cout<<"input \"Xiaomi\"or\"Huwei\"o\"end\""<<endl;
       cin>>end;
      if(end.compare("Xiaomi")==0)
      {
          Creator<Attribute_Str>* plantXiaomi = new ConcreteProductA<Attribute_Str>();
          Attribute_Str xiaomi_attri;
          plantXiaomi->setAttri(xiaomi_attri);
          plantXiaomi->showCreator().print();
          plantXiaomi->showProduct().print();

      }
      if(end.compare("Huwei")==0)
      {
          Creator<Attribute_Str>* plantHuawei = new ConcreteProductB<Attribute_Str>();
          Attribute_Str Huawei_attri;
          Huawei_attri.productName = "Huawei";
          Huawei_attri.CPU = "Qilin 970";
          plantHuawei->setAttri(Huawei_attri);
          plantHuawei->showCreator().print();
          plantHuawei->showProduct().print();

      }
   }
}

int main()
{
   test01();
    return 0;
}

```

`Creator.hpp`创建者的实现

```c++
#ifndef CREATOR_HPP
#define CREATOR_HPP
#include "product.hpp"

template <class T>
class Creator
{
public:
    virtual~Creator(){std::cout<<"Creator destructor"<<std::endl;}
    virtual Product<T>* createProduct()=0;

    T& showCreator(){ return this->mAttribute;}
    T& showProduct(){
        Product<T>* pro = createProduct();
        return pro->getProductAttribute();

    }
    void setAttri(const T& attri){this->mAttribute = attri;}
protected:
    Creator(){std::cout<<"Creator no parameter constructor"<<std::endl;}
    Creator(T Attribute):mAttribute(Attribute){std::cout<<"Creator parameter constructor"<<std::endl;}
private:
    T mAttribute;
};

template <class T>
class ConcreteProductA:public Creator<T>
{
public:
    ConcreteProductA(){std::cout<<"ConcreteProductA non-parameter constructor"<<std::endl;}
    ConcreteProductA(T attri):Creator<T>(attri){std::cout<<"ConcreteProductA parameter constructor"<<std::endl;}
    ~ConcreteProductA(){std::cout<<"ConcreteProductA destructor"<<std::endl;}
    Product<T>* createProduct(){

        return new ProductA<T>();
    }
};

template <class T>
class ConcreteProductB:public Creator<T>
{
public:
    ConcreteProductB(){std::cout<<"ConcreteProductB non-parameter constructor"<<std::endl;}
    ConcreteProductB(T attri):Creator<T>(attri){std::cout<<"ConcreteProductB parameter constructor"<<std::endl;}
    ~ConcreteProductB(){std::cout<<"ConcreteProductB destructor"<<std::endl;}
    Product<T>* createProduct(){

       return new ProductB<T>();
    }
};
#endif // CREATOR_HPP

```

`Product.hpp`产品接口的实现

```c++
#ifndef PRODUCT_HPP
#define PRODUCT_HPP
#include <iostream>
template <class T>
class Product
{
public:
    virtual T& getProductAttribute()=0;
    virtual void setProductAttribute(const T& attri)=0;
    virtual ~Product(){std::cout<<"Product destructor"<<std::endl;}
protected:
    Product(){std::cout<<"Product constructor"<<std::endl;}
};

template<class T>
class ProductA:public Product<T>
{
public:
    ProductA(){std::cout<<"ProductA no parameter constructor"<<std::endl;}
    ProductA(T attri):mattri(attri){std::cout<<"ProductA parameter constructor"<<std::endl;}
    T& getProductAttribute(){return this->mattri;}
    void setProductAttribute(const T& attri){this->mattri = attri;}
    ~ProductA(){std::cout<<"ProductA constructor"<<std::endl;}
private:
    T mattri;
};

template<class T>
class ProductB:public Product<T>
{
public:
    ProductB(){std::cout<<"ProductB no parameter constructor"<<std::endl;}
    ProductB(T attri):mattri(attri){std::cout<<"ProductB parameter constructor"<<std::endl;}
    T& getProductAttribute(){return this->mattri;}
    void setProductAttribute(const T& attri){this->mattri = attri;}
    ~ProductB(){std::cout<<"ProductB constructor"<<std::endl;}
private:
    T mattri;
};
#endif // PRODUCT_HPP
```



**在模板类中使用虚函数和在普通类中使用虚函数一样。**

#### 总结

1. 模板类和普通类中的虚函数是一样的语法规则，没有特殊。

### :star:工厂方法模式适用场景

1. 当你在编写代码的过程中，如果**无法预知对象确切类别以及依赖关系**时，可以使用工厂方法

   工厂方法将创建产品的代码与实际使用产品的代码分离， 从而能在不影响其他代码的情况下扩展产品创建部分代码。例如， 如果需要向应用中添加一种新产品， 你只需要开发新的创建者子类， 然后重写其工厂方法即可。

2. 如果希望**用户能够扩展你的软件库或框架的内部组件**，可以使用工厂方法

   继承可能是扩展软件库或框架默认行为的最简单方法。 但是当你使用子类替代标准组件时， 框架如何辨识出该子类？解决方案是将各框架中构造组件的代码集中到单个工厂方法中， 并在继承该组件之外允许任何人对该方法进行重写。

3. 如果你希望**复用现有对象来节省系统支援，而不是每次都重新创建对象**，可以使用工厂方法

   在处理大型资源密集型对象 （比如数据库连接、 文件系统和网络资源） 时， 你会经常碰到这种资源需求。

   让我们思考复用现有对象的方法：

   1. 首先， 你需要创建存储空间来存放所有已经创建的对象。
   2. 当他人请求一个对象时， 程序将在对象池中搜索可用对象。
   3. …然后将其返回给客户端代码。
   4. 如果没有可用对象， 程序则创建一个新对象 （并将其添加到对象池中）。

   这些代码可不少！ 而且它们必须位于同一处， 这样才能确保重复代码不会污染程序。可能最显而易见， 也是最方便的方式， 就是**将这些代码放置在我们试图重用的对象类的构造函数中。** 但是从定义上来讲， 构造函数始终返回的是**新对象**， 其无法返回现有实例。因此， 你需要有一个**既能够创建新对象， 又可以重用现有对象的普通方法。** 