## 定义：

红黑树是一种每个节点都带由颜色属性(或红或黑)的特殊的平衡二叉树。

由于每一颗红黑树都是一颗二叉查找树，所以在对红黑树进行查找时，可以采用运用于普通二叉树排序上的查找算法，在查找过程中不需要颜色信息。

## 性质：

1. 结点是红色或黑色。
2. 根节点是黑色。
3. 所有叶子节点是黑色，叶子节点是空结点。
4. 每个红色结点的两个子结点都为黑色，即从叶子节点到根结点的所有路径上不能有两个连续的红色结点。
5. 从任意结点到每个叶子结点的所有路径都包含相同数目的黑色结点。

从以上性质可得结论：

1. 从根结点到叶子结点的最长可能路径不多于最短可能路径的两倍，因此这就导致这棵树大致是平衡的。（性质5）
2. 因为操作比如插入、删除和查找某个值的最坏情况时间都要求与树的高度成比例，这个在高度上的理论上限允许红黑树在最坏情况下都是高效的，而不同于普通的二叉查找树。是性质4导致路径上不能有两个连续的红色结点确保了这个结果。
3. 最短的可能路径都是黑色结点，最长的可能路径有交替的红色和黑色结点。

红黑树的本质就是对2-3-4树的一种实现。

红黑树转化为2-3树必须为左倾红黑树（即红色结点在其子树左边）

红黑树如果是基于2-3-4树实现的，其阶数为4的结点必须平衡，即黑色父结点和两个红色子结点，红色子结点不能在同一边。

红色结点的意义就是==与父节点进行关联==

2-3树的插入操作：

如果在一个2阶结点插入一个结点，2阶结点就变成3阶结点，不用进行任何操作。此时对应着，红黑树中黑色父结点下增加了一个红色儿子。

如果在一个3阶结点上插入一个结点，3阶结点就变成临时4阶结点，然后进行分裂。此时对应着，红黑树中黑色父结点和两个红色儿子结点（不在同一边）。

2-3树的删除操作：

1. 删除的元素在3阶结点上，此时删除结点后，3阶结点转为2阶结点
2. 删除的元素在2阶结点上，兄弟结点是3阶结点，此时从兄弟结点借一个元素到父结点，于此同时父结点下调一个元素到当前要删除的结点，然后再进行删除操作。
3. 删除的元素在2阶结点上，兄弟结点是2阶结点，父结点为3阶结点，此时从父结点下调一个元素到当前结点，并与兄弟结点进行合并，形成临时4阶结点，然后进行删除操作。
4. 删除的元素在2阶结点上，兄弟结点和父结点各位2阶结点，此时将父结点和兄弟结点与当前结点进行合并，形成临时4阶结点，然后进行删除操作。

## 红黑数的插入操作

插入规则：插入的结点默认为红色，插入后不能破坏红黑树。

1. 红黑树为空树：直接插入结点，将颜色变成黑色。
2. 插入位置的父结点是黑色：直接插入，不需要做调整。
3. 插入位置的父结点为红色且叔叔结点为红色：先将结点插入到当前位置，此时父结点和当前结点都为红色，此时违背了红黑树的性质4，即路径上不能出现连续的红色。因此需要对结点进行颜色调整，将祖父结点变成红色，将父结点和叔叔结点变成黑色。
   1. 如果祖父结点的父结点为红色，我们需要以祖父结点为起始位置开始向上继续调整，直到整个树满足红黑树的定义。
   2. 如果祖父结点的父结点为黑色，我们就不需要进行调整。
4. 插入位置的父结点为红色，叔叔结点为黑色或没有叔叔
   1. 插入位置为左孩子的右子树上，即父亲结点为祖父结点的左孩子，插入位置为父亲的右孩子：此时先对父亲结点做一次左旋，然后对祖父结点做一次右旋，即先左后右，其次再将祖父结点的颜色变成红色，插入结点的颜色变成黑色。
   2. 插入位置为左孩子的左子树上，即父亲结点为祖父结点的左孩子，插入位置为父亲的左孩子：此时先对祖父节点做一次右单旋，然后将祖父结点的颜色变成红色，将父亲结点的颜色变成黑色。
   3. 插入位置为右孩子的左子树上，即父亲结点为祖父结点的右孩子，插入位置为父亲结点的左孩子：此时先对父亲做一次右旋，然后对祖父系欸但做一次左旋，即先右后左，其次再将祖父结点的颜色变成红色，插入结点的颜色变成黑色。
   4. 插入位置为右孩子的右子树上，即父亲结点为祖父结点的右孩子，插入位置为父亲的右孩子：此时先对祖父节点做一次左单旋，然后将祖父结点的颜色变成红色，将父亲结点的颜色变成黑色。

## 红黑树的删除操作

用需要删除结点的前驱或后继来替换当前要删除的结点。直到需要删除的结点没有孩子结点，即需要删除的结点移至之最后一层。

1. 删除结点没有孩子结点（此时说明已在最后一层）
2. 删除结点有一个孩子结点
   1. 删除结点有左子树，用前驱进行替换
   2. 删除结点有右子树，用后继进行替换
3. 删除结点有两个孩子结点
   1. 删除结点既有左子树又有右子树，可以用前驱或后继进行替换

最后情况2和3会转换为情况1.

此时，我们就可以对情况1进行下一步的颜色讨论。

1. 删除结点为红色：直接删除

2. 删除结点为黑色（双黑）：删除后，违背红黑树的性质，所以需要进行修复，即进行调整操作。

   1. 删除结点的父结点为红色且删除结点为左孩子

      1. 删除结点的兄弟结点的两个孩子结点都为红色：删除结点后，先对父结点进行左旋，然后将父结点变成黑色，兄弟结点变成红色，兄弟结点的右孩子变成黑色。
      2. 删除结点的兄弟结点只有一个左孩子，该左孩子一定为红色（性质5）：此时相当于右孩子的左子树上，所以先对兄弟结点进行一次右旋，然后对父结点进行一次左旋，其次将父结点变成黑色，兄弟结点变成红色。
      3. 删除结点的兄弟结点只有一个右孩子，该右孩子一定为红色（性质5）：此时相当于右孩子的右子树上，所以先对父结点进行一次右旋，其次将父结点变成黑色，兄弟结点变成红色。
      4. 兄弟结点没有孩子或都为黑色孩子：只需将结点删除后，将父结点的颜色变成黑色，兄弟结点的颜色变成红色。

   2. 删除结点的父结点为红色且删除结点为右孩子，此种情况与上述情况类似。

   3. 删除结点的父结点是红色且删除结点为左孩子

      1. 删除结点的兄弟结点为红色，此时兄弟结点必须有两个孩子（性质5），且2个孩子都为黑色(性质4)：此时先对父结点做左旋，然后再对父结点做左旋，父结点颜色变成红色，兄弟结点变成黑色。如果当前父结点后面有孩子，则该孩子一定为红色，此时我们可以将其当作新插入的结点进行处理。
      2. 删除结点的兄弟结点为黑色，此时兄弟结点必须有两个孩子，且2个孩子都为红色：此时先对兄弟做右旋，再对父亲做左旋，兄弟的左孩子变成黑色。
      3. 删除结点的兄弟结点是黑色，并且只有一个左孩子（与情况2相同）
      4. 删除结点的兄弟节点是黑色，并且只有一个右孩子，且该右孩子一定为红色：只用对父节点做左旋，然后对兄弟的右孩子进行反色。
      5. 删除结点的兄弟节点是黑色，没有孩子结点：删除节点后，局部无法修复，但是可以先做到有祖父结点的局部平衡，将兄弟结点的颜色变成红色。虽然此时局部时平衡的，但是整个红黑树是失衡的。此时就转换为修复失衡的黑色结点（一般为父结点）。

   4. 修复失衡结点，失衡结点一定为黑色

      1. 失衡结点的父结点是红色

         1. 兄弟结点的左孩子结点是黑色：只需对父结点进行左旋
         2. 兄弟结点的左孩子结点是红色，右孩子结点时黑色：将父结点的颜色变成黑色，将兄弟结点的颜色变成红色，此时兄弟结点和其左孩子都为红色，此时变成了修复连续红色结点的文件，即可以将其左孩子当作一个新插入的结点来处理即可。
         3. 兄弟结点的两个孩子都是红色：首先，将父亲变成黑色；第二，将兄弟变成红色；第三，将兄弟的右孩子变成黑色；最后，对父亲进行一次左旋。

      2. 失衡结点的父结点是黑色

         1. 兄弟结点是黑色，其孩子结点都是黑色：将兄弟结点变成红色，此时父结点变成了新的失衡结点，然后再向上求助祖父节点

         2. 兄弟结点为黑，其右孩子为红：对父节点做左旋，然后将兄弟节点的右孩子染成黑色，即可完成修复

         3. 兄弟节点为黑色，兄弟节点的左孩子为红色，兄弟节点的右孩子为黑色：首先将兄弟结点的左孩子变成黑色，然后对兄弟结点做右旋，其次对父亲结点做左旋。

         4. 兄弟节点为红色，兄弟节点一定有两个黑色的孩子：

            首先，将父亲染成红色；然后，将兄弟染成黑色；其次，对父亲做左旋，然后变成情况1，这时只需根据情况一中的三种情况分类处理即可。

## 红黑树的应用

用红黑树实现关联数组

1. 红黑结点定义

   ```cpp
   template <class T1, class T2>
   struct BRNode{
     T1 key;
     T2 val;
     struct BRNode* parent;
     struct BRNode* left, * right;
     NodeColor color=NodeColor::RED;
   };
   enum class NodeColor{RED,BLACK};
   enum class ChildSide{LEFT, RIGHT};
   ```

2. 红黑树定义

   ```cpp
   template <class T1, class T2>
   class BRTree{
   public:
       BRTree();
       ~BRTree();
       //深拷贝
       BRTree(const BRTree &p);
       //将红黑树清空
       clear();
   public:
      /*红黑树的相关操作*/
       
       /*判断红黑树中是否有指定的键值对*/
       //通过key来判断
       bool hasKeyVal(const T1& key);
       //通过val来判断,并返回个数
       bool hasKeyVal(const T2& val,int& count);
       
       /*获取数据*/
       //通过key来获取val
       T2& getData(const T1& key);
       //通过val来获取key，返回一个数组
       T1* getKey(const T2& val);
       
       /*删除指定结点*/
       //通过key来指定结点来进行删除
       RBTree<T1,T2>& reomve(const T1& key);
       //通过val来指定指定结点来进行删除
       RBTree<T1,T2>& remove(const T2& key);
       
       /*插入结点*/
       RBTree<T1,T2>& insert(const T1& key, const T2& val);
   
   private:
     //类内部数据类型的定义
     struct BRNode{
       T1 key;
       T2 val;
       struct BRNode* parent;
       struct BRNode* left, * right;
       NodeColor color=NodeColor::RED;
     };
     enum class NodeColor{RED,BLACK};
     enum class ChildSide{LEFT, RIGHT};
       
   private:
       //数据
       BRNode* node =nullptr;
   private:
       //私有操作
       //递归的释放结点
       cleanUp(RBNode* node);
       
       //右旋操作
       void rotateRight(RBNode* node);
       //左旋操作
       void rotateLeft(RBNode* node);
       //修复"连续红色结点"问题
       void fixUpContinuousRedNode(RBNode* node);
       //修复“失衡结点”问题
       void fixUpUnblancedNode(RBNode* node);  
       
   };
   ```

   



