## 信号与槽机制

信号槽是Qt框架引以为豪的机制之一。所谓信号槽，实际就是观察者模式。当某个事件发生之后，比如，按钮检测到自己被点击了一下，它就会发出一个信号(signal)。这种发出是没有目的的，类似广播。**如果有对象对这个信号感兴趣，它就会使用连接(connect)函数，**意思是，**将想要处理的信号和自己的一个函数（称为槽(s1ot))绑定来处理这个信号。**也就是说，当信号发出时，被连接的槽函数会自动被回调。这就类似观察者模式：当发生了感兴趣的事件，某一个操作就会被自动触发。

## 系统自带的信号和槽

下面我们完成一个小功能，上面我们已经学习了按钮的创建，但是还没有体现出按钮的功能，按钮最大的功能也就是点击后触发一些事情，比如我们点击按钮，就把当前的窗口给关闭掉，那么在Q中，这样的功能如何实现呢？

其实无法两行代码就可以搞定了，我们看下面的代码

```c++
QPushButton米quitBtn=new QPushButton("关闭窗口"，this):
connect (quitBtn,&QPushButton:clicked,this,&MyWidget:close)
```

第一行是创建一个关闭按钮，这个之前已经学过，第二行就是核心了，也就是信号槽的使用方式

```c++
connect(函数最常用的一般形式);
connect(sender,signal,receiver,slot);
参数解释：
sender:发出信号的对象
signal:发送对象发出的信号
receiver:接收信号的对象
s1ot:接收对象在接收到信号之后所需要调用的函数（槽函数）
```



```c++
Widget::Widget(QWidget *parent)
    : QWidget(parent)
{
       //创建一个按钮 点击按钮关闭窗口
    QPushButton *p = new QPushButton("关闭",this);
    p->move(100,100);
    //设置连结 点击按钮产生信号 会调用窗口的close函数
    //param1: 信号的发送者
    //param2: 发送的信号
    //param3: 信号接收者
    //param4: 接收者的槽函数
    connect(p,&QPushButton::clicked,this,&QWidget::close);
}
```

## 按钮常用的信号

那么系统自带的信号和槽通常如何查找呢，这个就需要利用帮助文档了，在帮助文档中比如我们上面的按钮的点击信号，在帮助文档中输入QPushBut ton,首先我们可以在Contents中寻找关键字Signals,信号的意思，但是我们发现并没有找到，这时候我们应该想到也许这个信号是被父类继承下来的，因此我们去他的父类QAbstractButton中就可以找到该关链字，点击signals索引到系统自带的信号有如下几个

| void | [clicked](qabstractbutton.html#clicked)(bool *checked* = false) |
| ---- | ------------------------------------------------------------ |
| void | [pressed](qabstractbutton.html#pressed)()                    |
| void | [released](qabstractbutton.html#released)()                  |
| void | [toggled](qabstractbutton.html#toggled)(bool *checked*)      |

槽函数的寻找方法和信号一样，只不过他的关键子是slot。

## 自定义的槽函数

使用connect()可以让我们连接系统提供的信号和槽。但是，Qt的信号槽机制并不仅仅是使用系统提供的那部分，还会允许我们自己设计自己的信号和槽。

声明槽函数

```c++
#ifndef WIDGET_H
#define WIDGET_H

#include <QWidget>
#include <QPushButton>

class Widget : public QWidget
{
    Q_OBJECT

    QPushButton* btn;
public:
    Widget(QWidget *parent = nullptr);
    ~Widget();
    
//自定义槽函数
public slots:
    void print();
};
#endif // WIDGET_H

```

实现槽函数

```c++
#include "widget.h"
#include <QDebug>
Widget::Widget(QWidget *parent)
    : QWidget(parent)
{
       btn = new QPushButton();
       btn ->setParent(this);
       btn->setText("打印(print)");
       //注册信号与槽的连接
       connect(btn,&QPushButton::pressed,this,&Widget::print);
}

Widget::~Widget()
{
}

void Widget::print()
{
    qDebug()<<"Qt是嵌入式的界面应用之一";
}

```

槽函数的参数由对应的信号的参数决定

## 自定义信号

`sonwidget.h`

```c++
#ifndef SONWIDGET_H
#define SONWIDGET_H

#include <QWidget>
#include <QPushButton>

class SonWidget : public QWidget
{
    Q_OBJECT
    QPushButton* btn;
public:
    explicit SonWidget(QWidget *parent = nullptr);

signals:
    //信号没有返回值 可以有参数 信号函数不需要定义 只要声明
    void show_hide_signal(int a);
public slots:
    void emit_mySignal();

};

#endif // SONWIDGET_H
```

`widget.h`

```c++
#ifndef WIDGET_H
#define WIDGET_H

#include <QWidget>
#include "sonwidget.h"

class Widget : public QWidget
{
    Q_OBJECT
    QPushButton * btn;
public:
    Widget(QWidget *parent = nullptr);
    ~Widget();
    SonWidget* sonWidget;
public slots:
    void covert();
    void signal_cb(int a);
};
#endif // WIDGET_H
```

`main.cpp`

```c++
#include "widget.h"

#include <QApplication>

int main(int argc, char *argv[])
{
    QApplication a(argc, argv);
    Widget w;
    w.show();
    w.setWindowTitle("parent");
    return a.exec();
}
```

`sonwidget.cpp`

```c++
#include "sonwidget.h"

SonWidget::SonWidget(QWidget *parent) : QWidget(parent)
{
   btn = new QPushButton("隐藏子窗口 显示父窗口",this);
   connect(btn, &QPushButton::clicked, this, &SonWidget::emit_mySignal);
}
void SonWidget::emit_mySignal()
{
    emit show_hide_signal(1);
}
```

`widget.cpp`

```c++
#include "widget.h"
#include <QtDebug>

Widget::Widget(QWidget *parent)
    : QWidget(parent)
{
    this->sonWidget = new SonWidget;
    sonWidget->show();
    sonWidget->setWindowTitle("son");
    //sonWidget->setParent(this);
    btn = new QPushButton("隐藏父窗口 显示子窗口",this);
    btn->move(300,200);
    connect(btn,&QPushButton::clicked,this,&Widget::covert);
    connect(sonWidget,&SonWidget::show_hide_signal, this, &Widget::signal_cb);
}

Widget::~Widget()
{
}
void Widget::covert()
{
    sonWidget->show();
    this->hide();
}
void Widget::signal_cb(int a)
{
    qDebug()<<a;
    sonWidget->hide();
    this->show();
}
```

## 自定义信号槽需要注意的事项

- 发送者和接收者都需要是QObject的子类（当然，槽函数是全局函数、Lambda表达式等无需接收者的时候除外)：
- 信号和槽函数返回值是void
- 信号只需要声明，不需要实现
- 槽函数需要声明也需要实现
- 槽函数是普通的成员函数，作为成员函数，会受到public、private、protected的影响；
- 使用emit在恰当的位置发送信号；
- 使用connect()函数连接信号和槽。
- 任何成员函数、static函数、全局函数和Lambda表达式都可以作为槽函数
- 信号槽要求信号和槽的参数一致，所谓一致，是参数类型一致。
- 如果信号和槽的参数不一致，允许的情况是，槽函数的参数可以比信号的少，即便如此，槽函数存在的那些参数的顺序也必须和信号的前面几个一致起来。这是因为，你可以在槽函数中选择忽略信号传来的数据（也就是槽函数的参数比信号的少）。

## 信号槽的拓展

- 一个信号可以和多个槽相连

  如果是这种情况，这些槽会一个接一个的被调用，但是它们的调用顺序是不确定的。

- 多个信号可以连接到一个槽

  只要任意一个信号发出，这个槽就会被调用。

- 一个信号可以连接到另外的一个信号

  当第一个信号发出时，第二个信号被发出。除此之外，这种信号-信号的形式和信号-槽的形式没有什么区别。

- 槽可以被取消链接

  这种情况并不经常出现，因为当一个对象delete之后，Qt自动取消所有连接到这个对象上面的槽。

- 信号槽可以断开

  利用disconnect关键字是可以断开信号槽的

- 使用Lambda表达式

  在使用Qt5的时候，能够支持Qt5的编译器都是支持Lambda表达式的。在连接信号和槽的时候，槽函数可以使用Lambda表达式的方式进行处理。后面我们会详细介绍什么是Lambda表达式

## Qt4版本的信号槽写法

`connect(zt,SIGNAL(hungry(QString)),st,SLOT(treat(QString)));`

这里使用了SIGNAL和SLOT这两个宏，将两个函数名转换成了字符串。注意到connect()函数的signal和slot都是接受字符串，一旦出现连接不成功的情况，Qt4是没有编译错误的（因为一切都是字符串，编译期是不检查字符串是否匹配）,而是在运行时给出错误。这无疑会增加程序的不稳定性

**Qt5在语法上完全兼容Qt4,而反之是不可以的**。

## Lambda表达式

