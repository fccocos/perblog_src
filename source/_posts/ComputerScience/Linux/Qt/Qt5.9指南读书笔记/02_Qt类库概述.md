## Qt Core的特点

### 概述

1. Qt

   Qt是一个跨平台的C++开发类库。

2. Qt元编译器

   元编译器是一个预处理器，在源程序被编译之前，Qt特有的特性会转换为标准C++兼容的形式，然后再由标准C++进行编译。

   需要在自定义的类里面添加一个Q_OBJECT宏，MOC才能够处理类里面的信号和槽

3. Qt Core

   Qt Core是Qt的核心模块，所有的其他模块都依赖于此模块

4. Qt的元对象系统

   Qt的扩展特性在Qt core模块当中实现的，是由Qt元对象系统实现的，包括信号与槽机制、属性系统、动态转换等。

### 元对象系统(MOS)

1. 元对象系统是为了实现信号与槽机制、属性系统、动态转换等Qt扩展机制而存在的。
2. 元对象系统的组成
   - 所有Qt对象的基类QObject
   - 在一个private中声明Q_OBJECT宏
   - MOC为每一个自定的类提供必要的代码来实现元对象系统的特性

3. 元对象提供出信号和槽以外的功能
   - `QObject::metaObject()`返回一个与类相关联的元对象`QMetaObject`, 它包含了一些访问对象的接口函数
   - `QObject::newInstance()` 函数创建一个新的实例对象
   - `QObject::inherits(const char *className)` 判断一个对象实例是否是`className`的类或QObject的子类实例。
   - `QObject::tr()`和`QObject::trUtf8()`可以翻译字符串
   - `QObject::setProperty()`和`QObject::property()`通过属性名动态的设置或获取属性值

```c++
#include <QCoreApplication>
#include <iostream>
#include <QMetaObject>
#include <QObject>
#include <QDebug>
#include <QTimer>

class QTestMetaObj:public QObject{
#ifndef Q_OBJECT
#define Q_OBJECT
#endif
private:
private slots:
public:
    QTestMetaObj(){};
    ~QTestMetaObj(){};
};

int main(int argc, char *argv[])
{
    QCoreApplication a(argc, argv);

    /*metaObject函数测试*/
    QObject *obj = new QTestMetaObj; //向上转型
    qDebug()<<"className:"<<obj->metaObject()->className();// 打印值 className:QObject

    /*inherits函数测试*/
    QTimer *time = new QTimer;
    qDebug()<<"QTimer:"<<time->inherits("QTimer");
    qDebug() << "QObject: "<<time->inherits("QObject");
    qDebug() << "QTestMetaObj:" << time->inherits("QTestMetaObj");
    /*
     * QTimer: true
     * QObject:  true
     * QTestMetaObj: false
    */
    
    

    return a.exec();
}

```

4. 动态转换函数`qobject_cast<>()`, 此函数只能在具有继承关系的对象之间进行转换。

### 属性系统(property)

1. 属性定义：`Q_PROPERTY()`宏函数
2. 属性的使用：通过`QObject::property()`获取属性值，`QObject::setProperty()`设置属性值
3. 动态属性: `QObject::setProperty()`可以在运行时为类定义一个新属性
4. 类的附加信息：属性系统还可以用宏`Q_CLASSINFO()`为类的对象定义"名称--值"信息，用元对象的一些函数获取类的附加信息，如`QMetaClassInfo QMetaObject::classInfo(int index) const`

```c++
#ifndef WIDGET_H
#define WIDGET_H

#include <QWidget>
#include <QPushButton>

QT_BEGIN_NAMESPACE
namespace Ui { class Widget; }
QT_END_NAMESPACE

class Widget : public QWidget
{
   
    Q_OBJECT
    /***************附加信息*********************/
    Q_CLASSINFO("author","gunfire")
    Q_CLASSINFO("company","UPC")
    Q_CLASSINFO("version","1.0.0")
    /*******************************************/

public:
    Widget(QWidget *parent = nullptr);
    ~Widget();

private:
    Ui::Widget *ui;
    QPushButton *qbtn;
    void showWidgetsInWidget();
};
#endif // WIDGET_H

```

```c++
void Widget::showWidgetsInWidget()
{
    qbtn = new QPushButton(this);
    QObject *object = qbtn;
    //设置属性值
    qbtn->setProperty("flat", true);
    //获取属性值
    qDebug() << "QPushButton::Flat"<<object->property("flat").toBool();
    //获取附加信息
    qDebug()<<"classInfo Number:"<<this->metaObject()->classInfoCount();
    for(int i = 0; i<this->metaObject()->classInfoCount(); i++)
    {
        QMetaClassInfo qmcinfo = this->metaObject()->classInfo(i);
        qDebug() << "classInof["<<i<<"]: "<<qmcinfo.name()<<"——"<<qmcinfo.value();
    }

}
```

### 信号与槽

Qt信号与槽实现对象间通信

1. `connect`函数的不同参数形式

   ```c++
   /*第一种形参的函数原型*/
   QMetaObject::Connection QObject::connect(const QObject *sender, const char *signal, const QObject *recvier, const char *method, Qt::ConnectType type = QT::AutoConnection);
   /*使用形式*/
   connect(spinNum, SIGNAL(valueChanged(int)), this, SLOT(updateStatus(int)));
   
   /*第二种形参的函数原型, 信号名称唯一的，没有参数不同而同名的两个信号，可以使用函数指针形式进行关联*/
   QMetaObject::Connection QObject::connect(const QObject *sender, const QMetaMethod &signal, const QObject *recevier, const QMetaMethod &method, Qt::ConnectType type = Qt::AutoConnection);
   /*使用形式*/
   connect(lineEdit, &QLineEidt::textChanged, this, &widget::on_texChanged);
   
   ```

   - 第5个参数为`Qt::connectType type`, 缺省值为`Qt::AutoConnection`
   - 枚举类型`Qt::AutoConnection`表示信号和槽之间的关联方式
   - `Qt::AutoConnection`: 如果信号的接收者与发射者在同一个线程，就使用`Qt::AutoConnection`
   - `Qt::QueuedConnection`: 在信号发射时自动确定关联方式。
   - `Qt::DirectConnection`: 信号被发射时槽函数立即执行，槽函数与信号在同一线程。
   - `Qt::QueuedConnection`: 在事件循环回到接收者线程后执行槽函数，槽函数与信号在不同的线程
   - `Qt::BlockingQueuedConnection`: 与`Qt::QueuedConnection`相似，知识信号线程会阻塞直到槽函数执行完毕。当信号与槽函数在同一线程时绝对不能使用这种方式，否则会造成死锁。

2. 使用`QObject::sender()`函数获取信号的发射者： 在槽函数中是使用`QObject::sendder()`函数来获取信号发射者的指针

3. 自定义信号及其使用

## Qt全局定义

包含在`QtGlobal`头文件中，包括数据类型、函数和宏

### 数据类型

| Qt数据类型 | 等效定义           | 字节数 |
| ---------- | ------------------ | ------ |
| qint8      | char               | 1      |
| qint16     | short              | 2      |
| qint32     | int                | 4      |
| qint64     | long long          | 8      |
| qlonglong  | long long          | 8      |
| quint8     | unsigned char      | 1      |
| quint16    | unsigned short     | 2      |
| quint32    | unsigned int       | 4      |
| quint64    | unsigned long long | 8      |
| qulonglong | unsigned long long | 8      |
| uchar      | unsigned char      | 1      |
| ushort     | unsigned char      | 2      |
| uint       | unsigned int       | 3      |
| ulong      | unsigned long long | 8      |
| qreal      | double             | 8      |
| qfloat16   |                    | 2      |

## 全局函数

| 函数                                                         | 功能                                           |
| ------------------------------------------------------------ | ---------------------------------------------- |
| T qAbs(const T &value)                                       | 返回绝对值                                     |
| const T& qBound*(const T &min, const T &value, cosnt T &max) | 获取value在min到max之间的值                    |
| bool qFuzzyCompare(double p1, double p2)                     | p1是否约等于p2                                 |
| bool qFuzzyIsNull(double p1)                                 | p1是否约等于0                                  |
| double qInf()                                                | 获取一个无穷大的数                             |
| bool qIsFinite(double d)                                     | d是否为有限数                                  |
| bool qIsInf(double d)                                        | d是否是无穷数                                  |
| const T& qMax(const T &value1, cosnt T &value2)              | 获取value1和value2中最大的那个                 |
| const T& qMin(const T &value1, const T &value2)              | 获取value1和value2中最小的那个                 |
| qint64 qRound64(double value);                               | 将一个double类型的value近似为最接近的int64整数 |
| int qRound(double value)                                     | 将一个double类型的value近似为最接近的int整数   |
| int qrand()                                                  | c++线程安全版的随机函数的重构                  |
| void qrand(uint seed)                                        | c++线程安全版的随机函数的重构                  |

### 宏定义

| 宏定义                       | 说明                                                         |
| ---------------------------- | ------------------------------------------------------------ |
| QT_VERSION                   | 当前使用Qt的版本号。宏展开为0xMMNNPP的形式                   |
| QT_VERSION_CHECK             | 当前使用Qt的版本号。宏展开是一个整数                         |
| QT_VERSION_STR               | 当前使用Qt的版本号。宏展开为一个字符串                       |
| Q_DECL_IMPORT                | 共享库的导入                                                 |
| Q_DECL_EXPORT                | 共享库的导出                                                 |
| Q_DECL_OVERRIDE              | 用于声明虚函数重写                                           |
| Q_DECL_FINAL                 | 当它用在声明类时，表示该类不能被继承，当它用在成员函数上时，表示该函数不能被重写 |
| Q_BYTE_ORDER                 | 当前存储使用的字节序                                         |
| Q_BIG_ENDIAN                 | 大端字节序                                                   |
| Q_LITTLE_ENDIAN              | 小端字节序                                                   |
| Q_UNUSED(value)              | 屏蔽那些在函数体中不使用的参数                               |
| foreach(variable, container) | 用于容器类遍历                                               |
| forever                      | 一个死循环                                                   |

## 容器类

### 容器概述

基于模板的容器类

Qt的容器类是隐式共享和可重入且线程安全的(当容器只读的时候，可以同时被多个线程访问)

Qt容器分为顺序容器和关联容器

用容器迭代器遍历容器种的数据项

用foreach宏遍历容器中的数据项

### 顺序容器

QList

QLinkedList

QVector

QStack

QQueue

#### QList

以数组列表的形式实现，在其前或后插入或删除元素速度快。

以数组索引的形式访问容器中的数据项

- insert() 在头部插入数据
- replace() 替换数据
- removeAt() 通过索引来删除数据
- move()移动数据
- swap()交换数据
- append()在尾部追加数据
- prepend()在首部追加数据
- removeFirst()删除首部数据
- removeLast()删除尾部数据
- at()函数等同数组索引
- isEmpty()判断容器是否为空

#### QLinkedList

链式列表，数据项不同连续内存存储。

它基于迭代器访问数据没有，它不提供数组索引功能。

插入和删除数据项的时间复杂度相同

QLinkedList容器所提供的函数与QList基本相同，除了不提供数组索引功能外。

#### QVector

提供动态数组的功能，有数组索引的功能

QVector和QList的函数基本一样。

QVector比QList效率更高，因为QVector中的数据项是连续存储的。

#### QStack

提供LIFO操作的容器。

函数接口：

- push()
- pop()
- isEmpty()

#### QQueue

提供FIFO操作的容器

主要函数接口

- enqueue 进队
- dequeue 出队
- isEmpty()

### 关联式容器

QMap

QMultiMap

QHash

QMultiHash

QSet

其中QMultiMap和QMultiHash提供一个键关联多个值

#### QSet

基于散列表的集合模板类，它存储数据的顺序不定的，查找速度非常的快。

#### QMap

提供一个字典，一个键一个值。

QMap存储数据时按照键的顺序来的。

#### QMultiMap

QMultiMap是QMap子类，区别在于QMultiMap的一个键可以关联多个值

#### QHash

基于散列表实现字典功能的模板类

QHash存储的键值对就要有非常快的查找速度

#### QMultiHash

QMultiHash是QHash子类，区别在于QMultiHash的一个键可以关联多个值



### 迭代器

#### Java类型的迭代器

| 容器类            | 只读迭代器          | 读写迭代器                 |
| ----------------- | ------------------- | -------------------------- |
| QList, QQueue     | QListIterator       | QMutableListIterator       |
| QLinkedList       | QLinkedListIterator | QMutableLinkedListIterator |
| QVector           | QVectorIterator     | QMutableVectorIterator     |
| QSet              | QSetIterator        | QMutableSetIterator        |
| QMap, QMultiMap   | QMapIterator        | QMutableMapIterator        |
| QHash, QMultiHash | QHashIterator       | QMutableHashIterator       |

QMap和QHash等关联式容器的迭代器的用法相同，QList和QLinkedList、QSet等容器的用法相同

##### 顺序容器类的迭代器的使用

`QListIterator<T> iterator(container)`

`while(iterator.hasNext()){iterator.next()}` // 顺序遍历

`while(iterator.hasPrevious()){iterator.pervious()}` // 逆序遍历

QListIterator常用函数

| 函数名                  | 功能                                           |
| ----------------------- | ---------------------------------------------- |
| void toFront()          | iterator移到容器中第一个数据项之前             |
| void toBack()           | iterator移到容器中最后一个数据项之后           |
| bool hasNext()          | iterator是否位于容器最后位置                   |
| const T& next()         | 返回后一个数据项，并将iterator向后移动一个位置 |
| const T& peekNext()     | 返回后一个数据项，但不移动iterator的位置       |
| bool hasPrevious()      | iterator是否位于容器最前位置                   |
| const T& previous()     | 返回前一个数据项，并将iterator向前移动一个位置 |
| const T& peekPrevious() | 返回前一个数据项，但不移动iterator的位置       |
|                         |                                                |

#### STL迭代器

| 容器类            | 只读迭代器                     | 读写迭代器               |
| ----------------- | ------------------------------ | ------------------------ |
| QList, QQueue     | QList<T>::const_iterator       | QList<T>::iterator       |
| QLinkedList       | QLinkedList<T>::const_iterator | QLinkedList<T>::iterator |
| QVector           | QVector<T>::const_iterator     | QVector<T>::iterator     |
| QSet              | QSet<T>::const_iterator        | QSet<T>::iterator        |
| QMap, QMultiMap   | QMap<T>::const_iterator        | QMap<T>::iterator        |
| QHash, QMultiHash | QHash<T>::const_iterator       | QHash<T>::iterator       |

## Qt类库模块

- Qt基本模块(`Qt Essentials`): 提供Qt在所有平台上的基本功能
- Qt附加模块(`Qt Add-Ons`): 实现一些特定功能的提供附加价值的模块
- 增值模块(`Value-Add Modules`): 单独发布的提供额外价值的模块或工具
- 技术预览模块(`technology Preview Modules`): 处于开发阶段，但可以作为技术预览使用的模块
- Qt工具(Qt Tools): 帮助应用程序开发的工具

