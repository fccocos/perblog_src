## 对象模型（对象树）

在Qt中创建对象的时候会提供一个Parent对象指针，下面来解释这个parent到底是干什的。

- QObject是以对象树的形式组织起来的。

  - 当你创建一个QObject对象时，会看到QObject的构造函数接收一个QObject指针作为参数，这个参数就是parent,也就是父对象指针。这相当于，**在创建QObject对象时，可以提供一个其父对象，我们创建的这个QObject对象会自动添加到其父对象的children()列表。**

  - **当父对象析构的时候，这个列表中的所有对象也会被析构。（注意，这里的父对象并不是继承意义上的父类！)**

- QWidget是能够在屏幕上显示的一切组件的父类。
  - **QWidget继承自Q0 bject,因此也继承了这种对象树关系。一个孩子自动地成为父组件的一个子组件。**因此，它会显示在父组件的坐标系统中，被父组件的边界剪裁。例如，当用户关闭一个对话框的时候，应用程序将其删除，那么，我们希望属于这个对话框的按钮、图标等应该一起被删除。事实就是如此，因为这些都是对话框的子组件。
  - 当然，**我们也可以自己删除子对象，它们会自动从其父对象列表中删除。**比如，当我们删除了一个工具栏时，其所在的主窗口会自动将该工具栏从其子对象列表中删除，并且自动调整屏幕显示。

**Qt引入对象树的概念，在一定程度上解决了内存问题。**

- 当一个QObject对象在堆上创建的时候，1Qt会同时为其创建一个对象树。不过，对象树中对象的顺序是没有定义的。这意味着，销毁这些对象的顺序也是未定义的。

- 任何对象树中的Q0bject对象delete的时候，如果这个对象有parent,则自动将其从parent的children()列表中删除：如果有孩子，则自动delete每一个孩子。Qt保证没有QObject会被delete两次，这是由析构顺序决定的。

**如果QObject在栈上创建，Qt保持同样的行为。正常情况下，这也不会发生什么问题。**

来看下下面的代码片段：

```
QWidget window;
QPushButton quit=QPushButton("退出"，&window):
```

作为父组件的window和作为子组件的quit都是QObject的子类（事实上，它们都是QWidget的子类，而QWidget是Q0bject的子类)。这段代码是正确的，quit的析构函数不会被调用两次，因为标准C+要求，局部对象的析构顺序应该按照其创建顺序的相反过程。因此，这段代码在超出作用域时，会先调用quit的析构函数，将其从父对象window的子对象列表中删除，然后才会再调用window的析构函数。

但是，如果我们使用下面的代码：

```cpp
QPushButton quit("Quit");
QWidget window;
quit.setParent(&window);
```

情况叹有所不同，析构顺序就有了问题。我们看到，在上面的代码中，作为父对象的window会首先被析构，因为它是最后一个创建的对象。在析构过程中，它会调用子对象列表中每一个对象的析构构函数，也就是说，quit此时就被析构了。然后，代码继续执行，在window析构之后，quit也会被析构，因为quit也是一个局部变量，在超出作用域的时候当然也需要析构。但是，这时候已经是第二次调用quit的析构函数了，C++不允许调用两次析构函数，因此，程序崩溃了。由此我们看到，Qt的对象树机制虽然帮助我们在一定程度上解决了内存问题，但是也引入了一些值得注意的事情。这些细节在今后的开发过程中很可能时不时跳出来烦扰一下，所以，我们最好从开始就养成良好习惯。

**在Qt中，尽量在构造的时候就指定parent对象，并且大胆在堆上创建。**

