---
title: 8_C_字符串处理函数
date: 2022/4/11/ 8:00
categories:
  - 计算机科学
tags:
  - 嵌入式
  - C语言
  - 笔记
sticky: true
valine:
  placeholder: "1. 提问前请先仔细阅读本文档⚡\n2. 页面显示问题💥，请提供控制台截图📸或者您的测试网址\n3. 其他任何报错💣，请提供详细描述和截图📸，祝食用愉快💪"
---



# 字符串处理函数 

## 获取字符串长度

- 头文件：`#include<string.h>`
- 函数定义：`size_t strlen(const char *s)`
- 函数功能：计算字符指针s指向的字符串中字符的个数，不包括'\0'
- 返回值：字符串的长度
- strlen获取的字符串的长度遇到第一个`\0`结束

## 字符串拷贝函数

- 头文件：`#include<string.h>`
- 函数定义：`char* strcpy(char *dest, char *src)`
- 函数说明：拷贝src指向的字符串到des指针指向的内存单元，'\0'也会拷贝
- 函数返回值：目的内存的地址
- 注意：在使用次函数的时候，必须保证dest指向的内存空间足够大，否则会出现内存污染
- `char *strncpy(char *dest, char *src, size_t n)`
- 函数说明：将src指向的字符串前n个字节拷贝到dest指向的内存中
- 返回值：目的内存的首地址
- 注意：
  1. strncpy不拷贝'\0'
  2. 如果n大于src执行的字符串中的字符个数，则在dest后面填充`n-strlen(src)`个'\0'

## 字符串追加函数

- 头文件：`#include <string.h`
- 函数定义：`char *strcat(char *dest, const char *src)`
- 函数功能：strcat函数最佳src字符串到dest指向的字符串的后面。追加的时候会加'\0'
- 注意：保证dest指向的内存空间足够大
- `char *strncat(char* dest, const char* src, size_t n)`
- 追加src指向的字符串的前n个字符到dest指向的字符串的后面
- 注意：如果n大于src的字符串的个数，则只将src字符串追加到dest 指向的字符串的后面，追加时会加'\0'

## 字符串比较函数

- `strcmp/strncmp`
- 头文件：`#include <string.h>`
- 函数定义：`int strcmp(const char *s1, const char *s2)`
- 函数说明：比较s1和s2指向的字符串的大小
  - 比较的方法：逐个比较字符的ascII码，一旦比出大小返回
  - 如果所有的字符都一样，返回0
  - strcmp函数是一个字符一个字符逐个比较的，只要出现不一样的，就会立刻返回
- 返回值：
  - 如果s1指向的字符串大于s2指向的字符串，返回1
  - 如果s1指向的字符串小于s2指向的字符串，返回-1
  - 如果相等，返回0
- `int strncmp(cosnt char *s1, const char*s2)`
- 函数说明：比较s1和s2执行的字符串中的前n个字符

## 字符查找函数

- 头文件：`#include <string.h>`
- 函数定义：`char *strchr(const char*s, int c)`
- 函数说明：在字符指针s指向的字符串中找ascii码为c的字符
- 注意：是首次匹配的字符，如果s指向的字符串中有多个ASCII为c的字符，则找的是第一个字符
- 返回值：找到了返回找到的字符的地址，找不到返回NULL
- `char *strrchr(const char *s, int c)`
- 函数说明：末次匹配，在s指向的字符串中，找最后一次出现的ASCII为c 的字符
- 返回值：末次匹配的字符的地址

## 字符串匹配函数

- 头文件：`#include <string.h>`
- 函数定义：`char *strstr(const char *haystack, const char *neddle)`
- 函数说明：在haystack指向的字符串中查找needle指向的字符串，也是首次匹配
- 返回值：
  - 找到：返回字符串首地址
  - 未找到：返回NULL

## 字符串转换数值

- `atoi/atol/atof//字符串转换功能`
- 头文件：`#include <stdlib.h>`
- 函数的定义：`int atoi(const char *nptr)`
- 函数的功能：将nptr指向的字符串转换为整数
- `long atol(const char *nptr)`
- `double atof(const char *nptr)`



## 字符串切割函数

- 头文件：`#include <string.h>`
- 函数定义：`char *strtok(char *str, const char *delim)`
- 函数功能：字符串切割，按照delim指向的字符串中的字符，切割str指向的字符串。其实就是在str指向的字符串中发现了delim字符串的字符，就将器变成'\0'，嗲用一次strtok只切割一次，切割一次之后，再去切割的时候strtok的第一个参数传NULL，意思是接着上一次切割的位置继续切
- 注意：如果str字符串中出现了连续几个delim中的字符，则只将第一个字符变成'\0'

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main()
{
    char str[]="111:222:333:444:555";
    char *p=NULL;
    int i=0;
    p=strtok(str, ":");
    printf("P[%d] = %s\n",++i,p);
    while(p=strtok(NULL,":"))
    {
        ++i;
        printf("P[%d] = %s\n",i,p);
    }
}
```

## 格式化字符串操作函数

1. `int sprintf(char *buf, const char* format, ...);//输出到buf指定的内存区域`

   ```c
   char buf[20];
   sprintf(buf,"%d:%d:%d",2013,10,1);
   printf("buf = %s\n", buf);
   ```

2. `int sscanf(const char* buf, const char *format, ...)//从buf指定的内存区域中读入信息`

   ```c
   int a,b,c;
   sscanf("2013:10:1","%d:%d:%d", &a, &b, &c);
   printf("%d  %d  %d\n", a, b, c);
   ```

3. `sscanf的高级用法`

   1. 跳过数据：`%*s或%*d`

      ```c
      char buf1[100];
      sscanf("1234 5678","%*d %s", buf1);
      printf("%s\n", buf1);
      ```

   2. 读指定宽度的数据：`%[width]s`

      ```c
      char buf2[20];
      sscanf("12345678","%4s ",buf2);
      printf("%s\n",buf2);
      ```

   3. 支持集合操作：只支持获取字符串

      1. `%[a-z] `表示匹配a到z中的任意字符（尽可能多的匹配）
      2. `%[aBc] `匹配a、B、c中一员，贪婪性
      3. `%[^aFc]`匹配非a、F、c中的任意字符，贪婪性
      3. `%[^a-z]`表示读取除a-z以外的所有字符
      
      ```c
      char buf3[20];
      sscanf("agcd32DajfDdFF","%[a-z]",buf3);
      printf("%s\n",buf3);
      ```
      
      

## const

1. 修饰普通变量，代表只读的意思

   `const int a=100;//定义了一个只读变量a值为100`

   以后再程序中，不能再给a赋值了

2. 修饰指针

   1. `const char *str`的意思是str指向的内存的内容不能通过str来修改，用来保护str指向内存的内容，但是str的指向是可以改变
   2. 如果const修饰指针变量的类型，不能通过指针变量修改地址里面的值
   3. 如果const修饰指针变量，无法需改指针保存的地址
   4. 如果const既修饰指针变量的类型，又修饰指针变量，则只能通过变量本身来修改值

3. 修饰全局变量

   全局变量只能使用不能修改，修改const修饰的全局变量的值，编译器报错，如果使用全局变量的地址修改值，运行时程序会出现异常

4. 修饰普通局部变量

   可以读取变量的值，但不能直接通过变量进行修改值，可以通过变量的地址来修改变量的值

   