---
title: 7_C_动态内存申请
date: 2022/4/10/ 8:00
categories:
  - 计算机科学
tags:
  - 嵌入式
  - C语言
  - 笔记
sticky: true
valine:
  placeholder: "1. 提问前请先仔细阅读本文档⚡\n2. 页面显示问题💥，请提供控制台截图📸或者您的测试网址\n3. 其他任何报错💣，请提供详细描述和截图📸，祝食用愉快💪"
---



# 动态内存申请 

## 动态分配内存的概述

数组的长度是预先定义好的，在整个程序中是固定不变的

内存空间取决于实际输入的数据

内存管理函数 按需动态的分配内存空间，也可以把不使用的空间回收

## 静态分配、动态分配

### 静态配分

1. 在程序编译或运行过程中，按事先规定大小分配内存空间的分配方式。
2. 必须实现知道所需空间的大小
3. 分配在栈区或全局变量区，一般以数组的形式。
4. 计划分配

#### 动态分配

1. 在程序运行过程中，根据需要大小自由分配所需空间
2. 按需分配
3. 分配在堆区，一般使用特定的函数进行分配

## 动态分配函数

| 函数                         | 头文件               | 函数原型                                      | 功能说明                                                     | 返回值                                       | 注意                                                         |
| ---------------------------- | -------------------- | --------------------------------------------- | ------------------------------------------------------------ | -------------------------------------------- | ------------------------------------------------------------ |
| `malloc函数`                 | `#include<stdlib.h>` | `void* malloc(unsigned int size)`             | 在内存的动态存储区中分配一块长度为size字节的连续区域，用来存放类型说明字符指定的类型。函数原型返回`void*`指针，使用时必须做相应的强制类型转换，分配的内存空间内容不确定，一般使用memeset初始化 | 分配空间的起始地址(分配成功)  NULL(分配失败) | 1. 在调用malloc之后，一定要判断一下，是否申请内存成功<br>2. 如果多次malloc申请的空间，第一次和第二次申请的内存不一定是连续的<br>3. 使用malloc开辟空间需要保存好空间的地址，但是由于不确定空间用来干什么，一本身返回值类型为`void*`，所以在调用函数时根据接收者的类型对其进行强制类型转换 |
| `free函数`（释放内存函数）   | `#include<stdlib.h>` | `void free(void *ptr)`                        | free函数释放ptr指向的内存                                    | 没有返回值                                   | 1. ptr指向的内存必须时malloc、calloc、relloc动态申请的内存<br>2. free后，因为没有用给指针赋值，所以指针还是指向原来动态申请的内存，但是内存已经不再使用了，此时的指针就变成了野指针,所以一般为了防止野指针，会free后对指针赋值为NULL<br>3. 一块动态申请的内存只能free一次，不能多次free |
| `calloc函数`                 | `#include<stdlib.h>` | `void* calloc(size_t nmemb, size_t size)`     | 在内存的堆中申请nmemb块，每块的大小为size个字节的连续区域    | 申请的内存首地址（成功）<br>NULL(失败)       | malloc和calloc都是用来申请内存的                             |
| `ralloc函数`（重新申请内存） | `#include<stdlib.h>` | `void* ralloc(void*s, unsigned int newsize);` | 在原先s指向的内存基础上重新申请内存，新的内存的大小为new_size个字节，如果原先内存后面有足够大的空间，就追加，如果后面的内存不够用，则relloc函数会在堆区找一个newsize个字节大小的内存申请，将原先内存中的内容拷贝过来，然后释放原先的内存，最后返回新内存地址。如果newsize比原先的内存小，则会释放原先内存后面的存储空间，只保留newsize个字节 | 新申请内存的首地址                           |                                                              |

### malloc和calloc函数的区别

1. 函数的名字不一样
2. 参数不一样
3. malloc申请的内存中的内容是随机的，而calloc申请的内存中的内容为0

**注意：malloc calloc ralloc申请的空间只有free或程序结束后才能够释放**

## 内存泄露

### 内存泄露的概念

申请的内存，首地址丢失后，找不到，再也无法使用，也无法释放，这块内存就被泄露了。

内存泄露案例1

```c
char *p;
p = (char*)malloc(100*sizeof(char));
p="hello world";//p指向了别的地方，保存了字符常量的首地址
//从此以后，再也找不到申请到的100个字节，动态申请的100个字节的存储空间就被泄露了
```

内存泄漏案例2

```c
void fun()
{
    char *p;
    p=(char*)malloc(100);
}
int main()
{
    //每调用一次，内存就会泄漏一次
    fun();
    fun();
    fun();
}
```

解决方式1

```c
void fun()
{
    char *p;
    p =(char*)malloc(100);
    ......
    free(p);
}
```

解决方式二

```c
char* fun()
{
    char *p;
    p = (char*)malloc(100);
    return p;
}
int main()
{
    char *q;
    q = fun();
    .....
    free(q);
    q=NULL;
}
```

**总结：申请的内存，一定不要把首地址给丢失，在不同的时候一定要释放内存**