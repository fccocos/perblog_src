---
title: 9_C_结构体、共用体、枚举
date: 2022/4/12/ 8:00
categories:
  - 计算机科学
tags:
  - 嵌入式
  - C语言
  - 笔记
sticky: true
valine:
  placeholder: "1. 提问前请先仔细阅读本文档⚡\n2. 页面显示问题💥，请提供控制台截图📸或者您的测试网址\n3. 其他任何报错💣，请提供详细描述和截图📸，祝食用愉快💪"
---



# 结构体、共用体、枚举 

## 结构体类型的概念以及定义

数组也是一种构造类型

### 构造类型

不是基本类型的数据结构也不是指针，他是若干个相同或不同类型的数据构成的集合

描述一组具有相同类型数据的有序集合，用于处理大相同类型的数据运算，有时候我们需要将不同类型的数据组合成一个有机整体，以便于引用，如：学生的学号、姓名、性别、年龄、家庭住址等属性

常用的构造类型有数组、结构体、共用体、枚举

数组用于保存类型相同的数据，结构体用于保存类型不同的数据

### 结构体类型的概念

结构体是一种构造类型的数据结构，是一种或多种基本类型或构造类型的数据的集合

### 结构体类型的定义

使用结构体之前必须先有类型，然后用类型定义数据结构，这个类型相当于一个模具。

1. 先定义结构体类型，再去定义结构体的变量

   ```c
   struct 结构体类型名{
       成员列表
   };
   struct student{
       int num;
       char name[20];
       char sex;
       char addr[32];  
   };
   //有了结构体类型后，就可以用类型定义变量
   struct student lucy,bob,lilei;//定义了三个struct student 类型的变量，每个变量都有四个成员，分别为num name sex addr
   ```

2. 在定义结构体类型的时候顺便定义结构体变量，以后还可以定义结构体变量

   ```c
   struct 结构体类型名{
   	成员列表;
   }结构体变量1，变量2，...;
   struct 结构体变量 变量3，变量4，...;
   
   struct student{
       int num;
       char name[20];
       char sex;
       char addr[32];  
   }lucy, bob, lilei;
   struct student xiaohong, xiaoming;
   ```

   注意：一般结构体类型都会定义在全局，也就是main函数外面，所以在定义结构体类型的同时定义变量，这些变量一般都是全局变量，定义完类型之后的结构体变量内存分配要看定义的位置

3. 无名结构体的定义

   在定义结构体的时候，没有结构体类型名，顺便定义结构体变量，由于没有类型名，所以以后不能再定义相关类型的数据

   ```c
   struct {
       成员变量;
   }变量1, 变量2, ...;
   ```

   由于无名结构体没有类型，所以只能在定义结构体的同时定义结构体变量

4. 给结构体类型取别名

   通常将一个结构体类型重新起一个类型名，用新的类型名来替代原来的类型

   1. 先用结构体类型定义变量

      ```c
      stru stu{
          int num;
          char name[20];
          char sex;
      }bob;
      ```

   2. 用新的类型名替换变量名

      ```c
      stru stu{
          int num;
          char name[20];
          char sex;
      }STU;
      ```

   3. 在`struct`的前面用`typedef`关键字进行修饰

      ```c
      typedef stru stu{
          int num;
          char name[20];
          char sex;
      }STU;
      ```

   `typedef`关键字的作用是给一个类型取别名，如果结构体取别名，一般不需要先给结构体定义名字，定义结构体变量时，直接使用别名，可以不加关键字`struct`

## 结构体变量的定义初始化及使用

### 结构体变量的定义和初始化

结构体变量，是一个变量，这个变量是若干个数据的集合

***

1. 在定义结构体变量之前首先的有结构体类型，然后在定义变量
2. 在定义结构体变量的时候，可以顺便给结构体变量赋初值，称为结构体变量的初始化
3. 结构体变量初始化的时候，**各个成员顺序初始化**

```c
#include <stdio.h>
#include <string.h>

//定义结构体
struct stu{
    int id;
    char name[20];
    char sex;
    int age;
    //定于结构体变量之定义结构体类型的同时定义结构体变量
}zhangsan,lisi={1002,"李四","B", 22};

//如果加typedef对结构体类型取别名
typedef struct{
    int a;
    int b;
    char c;
}MSG;
typedef struct{
  int year;
  int month;
  int day;
}BD;
typedef struct{
    int id;
    char name[32];
    BD birth;
}STU;

void test2()
{
    STU xiaoming;
    xiaoming.id = 1001;
    strcpy(xiaoming.name, "小明");
    //如果结构体中嵌套结构体，赋值时找到最内层的成员再进行赋值
    xiaoming.birth.year = 2002;
    xiaoming.birth.month = 12;
    xiaoming.birth.day = 20;
    printf("%d - %s - %d:%d:%d\n",xiaoming.id,xiaoming.name,xiaoming.birth.year ,xiaoming.birth.month,xiaoming.birth.day);
    嵌套的形式定义并初始化
    STU xiaoli = {1002,"小丽",{2000,1,2}};
}

void test1()
{
    //类型定义完毕后定义变量
    struct stu wangwu;
    //结构体变量初始化
    struct stu zhaoliu = {1000,"赵六",'B',20};
    
    //如果使用typedef对结构体类型取别名
    //就无法在定义类型的时候定义结构体变量
    //在定义结构体变量的时候不用加struct
    MSG msg1,msg2 = {100,20,'w'};
    
    //结构体变量的使用
    zhangsan.id = 1001;
    strcpy(zhangsan.name, "张三");
    zhangsan.sex = 'B';
    zhangsan.age = 18;
    printf("%d-%s-%c-%d\n",zhangsan.id,zhangsan.name,zhangsan.sex.zhangsan.age);
    printf("%d-%s-%c-%d\n",lisi.id,lisi.name,zlisi.sex.lisi.age);
    printf("%d-%s-%c-%d\n",zhaoliu.id,zhaoliu.name,zhaoliu.sex.zhaoliu.age);

}

int main(int argc, char *argv[])
{
    test1();
    test2();
    return 0;
}
```





### 结构体变量的使用

结构体变量对成员调用的方式：`结构体变量.结构体成员`

注意：此时的结构体变量是普通的结构体变量

## 相同类型的结构体变量可以相互赋值

```c
#include <stdio.h>
#include <string.h>

struct stu{
    int id;
    char name[20];
    char sex;
    int age;   
};
int main(int argc, char *argv[])
{
    struct stu zhangsan;
    zhangsan.id = 1001;
    strcpy(zhangsan.name,"张三");
    zhangsan.sex = 'B';
    zhangsan.age = 18;
    //相同类型的结构体变量可以相互赋值
    struct stu lisi = zhangsan;
    strcpy(lisi.name, "李四");
}
```



## 结构体数组

结构体数组是一个数组，由若干个相同类型的结构体变量构成的集合

### 结构体数组的定义

```c
struct 结构体类型名 数组名[元素个数];
struct stu{
    int num;
    char name[20];
    char sex;
};
struct stu edu[3];//定义了一个struct stu类型的结构体数组edu
```

### 结构体数组元素的引用

`结构体数组名[下标]`

### 结构体数组元素的使用

```c
edu[0].num = 101;//用101给edu数组的第0个结构体变量的num赋值
strcpy(edu[1].name,"lucky");
```

```c
#include <sdtio.h>
#include <string.h>

typedef struct{
	int num;
    char name[32];
    int score;
}STU;
void test()
{
    //定义一个结构体数组并初始化
    STU edu[3]={
        {1001, "Bob", 78},
        {1003, "Lucky", 66},
        {1005, "Lucas", 61}
    };
    int i=0;
    for(i;i<3;++i)
        printf("%d - %s - %d", edu[i].num, edu[i].name, edu[i].score);
}
```



## 结构体指针

结构体指针即结构体的地址，结构体变量存放内存中，也有起始地址，定义一个变量来存放这个地址，那这个变量就叫做结构体指针变量。

### 结构体指针变量的定义

`struct 结构体类型名 *结构体指针变量名;`

### 结构体指针变量对成员的引用

```c
(*结构体指针变量名).成员
结构体指针变量名->成员
```



## 结构体内存分配问题

结构体变量大小是它所有成员之和，因为结构体变量是所有成员的集合。

但是在实际给结构体变量分配内存的时候，是规则的

**规则1：以多少个字节为单位开辟内存**

***

给结构体变量分配内存的时候，会去结构体变量中找基本类型的成员，哪个基本类型的成员占字节数多，就以它的大小为单位开辟内存。

在`gcc`中出现`double`类型的例外

1. 成员中只有`char`型数据，以1字节为单位开辟内存。

2. 成员中出现了`short int `类型数据，没有更大字节数的基本数据类型数据，以2字节为单位开辟内存

3. 出现了`int` `float`没有更大字节数的基本类型数据的时候，以4字节为单位开辟内存

4. 出现了`double`类型的数据

   1. 在`vc`中，以8字节为单位开辟内存
   2. 在`gcc`中，以4字节为单位开辟内存

   无论是哪一种环境，`double`型变量占用8个字节

> TODO:
>
> 如果在结构体中出现了数组，数组可以看成多个变量的集合。
>
> 如果出现指针的话，没有占字节数更大的类型，以4字节为单位开辟内存
>
> 在内存中存储结构体成员的时候，按定义的结构体成员顺序存储

**规则2：字节对齐**

***

1. `char` 1字节对齐，即存放`char`型的变量，内存单元的编号是1的倍数即可
2. `short int` 2字节对齐，即存放`short int`型的变量，起始内存单元的编号是2的倍数即可
3. `int`  4字节对齐，即存放`int`型的变量，起始内存单元的编号是4的倍数即可
4. `long int`  在32位平台下，4字节对齐，即存放`long int`型的变量，起始内存单元的编号是4的倍数即可
5. `float`  4字节对齐，即存放`float`型的变量，起始内存单元的编号是4的倍数即可
6. `double`
   1. `vc`环境下，8字节对齐，即存放`doule`型的变量，起始内存单元的编号是8的倍数即可，`double`变量占8个字节
   2. `gcc`环境下，4字节对齐，即存放`double`型的变量，起始内存单元的编号是4的倍数即可，`double`变量占8个字节

> TODO:
>
> 当结构体成员中出现数组的时候，可以看成多个变量
>
> 开辟内存空间的时候，从上到下一次按照成员在结构体中的位置顺序开辟空间

**字节对齐的优点：用空间换时间，提高cpu读取数据的效率**



**指定对齐原则**

使用`#program pack`改变默认对齐规则

格式：`#program pack (value)\\value为指定对齐值`

注意：

1. value只能是：1、2、4、8等

2. 指定对齐值与数据类型对齐值相比取较小值

   1. 以多少字节为单位开辟内存

      结构体成员中，占字节数最大的类型长度和value比较，取较小值为单位开辟内存

   2. 结构体成员中的对齐方法，各个默认的对齐字节数和value相比取较小值

## 位段

在结构体中，以位为单位的成员，称之为位段（位域）

```c
struct packed_data{
    unsigned int a:2;
    unsigned int b:6;
    unsigned int c:4;
    unsigned int d:4;
    unsigned int i;
}data;
```

不能对位段成员取地址

```c
#include<stdio.h>

struct packed_data{
    unsigned int a:2;
    unsigned int b:6;
    unsigned int c:4;
    unsigned int d:4;
    unsigned int i;
}data;
int main()
{
    printf("%d\n",sizeof(data));
     printf("%d\n",&data);
     printf("%d\n",&data.i);
}

```

位段注意事项：

1. 对于位段的引用：`data.a = 2`，赋值时，不要超出位段的定义范围，例如：段成员a定义位2位，最大值位3，即11，所以data.a = 5; 就会取4的低两位进行赋值101-->01
2. 位段成员的类型必须指定为整型或字符型
3. 一个位段必须存放在一个存储单元中，不能跨两个单元，第一个单元空间不能容纳下一个位段，则该空间不用，而从下一个单元起存放该位段

**位段长度不能大于存储单元的长度**

1. char型位段 <=  8位
2. short int型位段 <= 16位
3. int型位段 <=  32位
4. long int位段 <=  32位

**如果一个段想从另一个存储单元开始，可以这样定义**

```c
unsigned char a:1;
unsigned char b:2;
unsigned char :0;
unsigned char c:3;//从下一个单元开始存储该位段
```

由于用了长度位0的位段，其作用是式下一个位段从下一个存储单元开始存放，即将a和b存放在一个存储单元中，而c用另一个存储单元存储。

**可以定义无意义的位段**

```c
unsigned int a:1;
unsigned int :2;//此为无意义的位段
unsigned int b:3;
```

## 共用体

[![LeGStH.png](https://s1.ax1x.com/2022/04/12/LeGStH.png)](https://imgtu.com/i/LeGStH)
[![Le8v7D.png](https://s1.ax1x.com/2022/04/12/Le8v7D.png)](https://imgtu.com/i/Le8v7D)

## 枚举