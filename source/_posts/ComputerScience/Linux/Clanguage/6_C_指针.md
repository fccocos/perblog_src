---
title: 6_C_指针
date: 2022/4/9/ 8:00
categories:
  - 计算机科学
tags:
  - 嵌入式
  - C语言
  - 笔记
sticky: true
valine:
  placeholder: "1. 提问前请先仔细阅读本文档⚡\n2. 页面显示问题💥，请提供控制台截图📸或者您的测试网址\n3. 其他任何报错💣，请提供详细描述和截图📸，祝食用愉快💪"
---



# 指针 

## 关于内存的那点事儿

## 指针的相关概念

操作系统给每个存储单元分配一个编号，0x00 00 00 00~0xff ff ff ff，这个编号就称为**地址**，指针就是地址

[![Le8nQx.png](https://s1.ax1x.com/2022/04/12/Le8nQx.png)](https://imgtu.com/i/Le8nQx)

### 指针变量

指针变量是一个变量，是一个指针变量，即这个变量用来存放一个地址编号

在32位平台下，地址总线是32位的，所以地址是32位编号，所以指针变量是32位的即4个字节

> 注意：
>
> 1. 无论什么类型的地址，都是存在单元的编号，在32位平台下都是4个字节，即任何类型的指针变量都只占用4个字节大小
> 2. 对应类型的指针变量，只能存放对应类型的变量的地址。例如，整型的指针变量只能存放整型变量的地址



**扩展：**

==字符变量== `char ch;` ch占用一个字节， 它只有一个地址编号，这个地址编号就是ch的地址 

==整型变量==  `int a;` a占用4个字节，它占用4个字节的存储单元，有四个地址编号，而a的地址就是它所占用的4个字节的存储单元中编号最小的那一个编号

## 指针的定义方法

### 简单指针

```c
数据类型 * 指针变量名;
int * p;//定义了一个指针变量p
在定义指针变量的时候 * 是用来修饰变量的，说明变量p是一个指针变量
```

### 关于指针的运算符

| 运算符 | 意义             |
| ------ | ---------------- |
| `&`    | 取地址           |
| `*`    | 间接运算符，取值 |

```c
int a = 0x0000234f;
int *p;//定义指针变量的时候*表示修饰的意思，修饰p是一个指针变量
p = &a;//把a的地址赋值给p
```

### 扩展

在一行中定义多个指针变量，每个指针变量前面都需要加`*`来修饰

```c
int *p,*q;//定义了两个整型的指针变量p和q
int *p,q;//定义了一个整型指针变量p和一个整型变量q
```

> 注意
>
> 在一个函数内部定义一个指针变量的时候，由于该指针变量是一个局部变量，局部变量没有赋初值，它的值是随机的，该指针变量指向哪里不一定，所以该指针变量是野指针

### 指针的大小

在32位系统下，所有类型的指针都是4个字节大小，因为不管地址空间多大，但是地址的长度是固定的。



## 指针的分类

### 按照指针指向的数据类型分类

#### 字符指针

字符型数据的地址

```c
char *p;//定义了一个字符指针变量，只能存放字符型数据的地址编号
char ch;
p = &ch;    
```

#### 短整型指针

```c
short int *p;//定义了一个短整型指针变量，只能存放短整型数据的地址编号
short int a;
p = &a;
```

#### 整型指针

```c
int *p;//定义了一个整型指针变量，只能存放整型数据的地址编号
int a;
p = &a;
```

> 注意
>
> 多字节变量，占用多个存储单元，每个存储单元都有地址编号，C语言谷底那个，存储单元编号最小的那个编号，是多字节变量的地址编号

#### 长整型指针

```c
long int *p;//定义了一个长整型指针变量，只能存放长整型数据的地址编号
long int a;
p = &a;
```

#### float型指针

```c
float *p;//定义了一个float型指针变量，只能存放float型数据的地址编号
float a;
p = &a;
```

#### double型指针

```c
double *p;//定义了一个double型指针变量，只能存放double型数据的地址编号
double a;
p = &a;
```

#### 函数指针

```c
返回指类型 (*函数指针名)(形参列表);
void (*p)(int, int);
常用于回调函数
//回调函数
int process(int (*callback)(int, int), int a, int b);
```

#### 结构体指针

```c
typedef struct A{
	char ch[32];
	int year;
	int month;
	int day;
    struct A *next; //指向下一个节点
}*data;//data就是一个结构体指针变量
```

#### 指针的指针

```c
int a,*p,**q;
p = &a;
q = &p;//指针的指针中存放的是指针变量的地址，即指向的是指针的指针
```

#### 数组指针

```c
int (*a)[5];//数组指针本质是一个指针，是一个指向数组的指针，加1，此时指向下一个数组
```

## 指针和变量的关系

### 指针可以存放变量的地址编号

在程序中，应用变量的方法

1. 直接通过变量的名称

   ```c
   int a;
   a = 100;
   ```

2. 通过指针变量来引用变量

   ```c
   int *p;//定义的时候，*p不是取值的意识，而是修饰的意思，告诉编译器，这是个指针变量
   p = &a;//取a的地址赋值给p,p保存的是a的地址，也就是说p指向了a
   *p = 100;//在调用的时候*是取值的意思，*指针变量 等价于 指针指向的变量
   ```

> 注意
>
> 1. 指针变量在定义的时候可以初始化
>
>    ```c
>    int a;
>    int *p = &a;//用a的地址初始化指针变量p
>    ```
>
> 2. 指针就是用来存放变量的地址
>
> 3. `*+指针变量` 相当于 指针指向的变量
>
> 4. 指针变量只能保存开辟好空间的地址，不能随意保存地址

### 扩展

对应类型的指针，只能保存对应类型数据的地址

如果想让不同类型的指针相互赋值，就必须强制类型转换

> 注意
>
> 1. *+指针 取值，去几个字节，由指针类型决定。指针为字符指针则取一个字节，指针为整型指针则取4个字节，指针为double型指针则取8个字节
>
> 2. 指针++  指向下一个对应类型的数据地址
>
>    字符指针++，指向下一个字符数据的地址，指针存放的地址编号加1
>
>    整型指针++，指向下一个整型数据的地址，指针存放的地址编号加4





## 指针和数组元素之间的关系

1. 变量存放在内存中，有地址编号，定义的数组是多个相同类型的变量的集合；每个变量都占用内存空间，都是地址编号；指针变量当然可以存放数组源的地址

   ```c
   int a[10];
   int *p;
   p = &a[0];
   指针变量p保存了数组a中第0个元素的地址，即a[0]的地址
   ```

2. 数组元素的引用方法

   1. 数组名[下标]   `int a[10]; a[2]=100;`

   2. 指针名加下标

      ```c
      int a[10]
      int *p;
      p = a;
      p[2] = 100;// p 和 a 等价
      //补充：c语言规定，数组的名字就是数组的首地址，即第0个元素的地址，是一个地址常量
      # 注意：p和a的不同， p是指针变量，而a是一个常量。所以可以用等号给p赋值，但不能给a赋值
      
      ```

   3. 通过指针运算加取值的方法来引用数组的元素

      ```c
      int a[10];
      int *p;
      p = a;
      *(p+2) = 100;//相当于 a[2] = p[2] = 100
      解释：p是第0个元素的地址，p+2就是a[2]的地址
      ```

## 指针的运算

1. 指针可以加一个整数，往下指几个它指向的变量，结果还是一个地址。能完成该动作的前提的是，指针指向数组的时候，加一个整数才有意义

2. 两个相同类型指针可以比较大小

   前提：只有两个 相同类型的指针 指向 同一个数组的元素 的时候，比较大小才有意义

   只想前面元的指针 小于 指向后面元素的指针

3. 两个相同类型的指针可以做减法

   ==前提==：必须是**两个相同类型的指针**指向**同一个数组的元素**的时候，做减法才有意义，做减法的结果是，两个指针指向的中间有多少个元素

4. 两个相同类型的指针可以相互赋值

   只有心痛类型的指针才可以相互赋值（void*类型除外）

   ```c
   int *p;
   int *q;
   int a;
   p = &a;//p保存了a的地址，p指向了a
   q = p; 用p给q赋值，q也保存了a的地址，也指向a
   ```

   > ​	如果类型不相同的指针要想相互赋值，必须进行强制类型转

## 指针数组

1. 指针和数组的关系

   1. 指针可以保存数组元素的地址
   2. 可以定义一个数组，数组中有若干个相同类型指针变量，这个数组被称为指针数组
   3. 指针数组：指针数组本身就是一个数组，是一个指针类型的数组，是若干个相同类型的指针变量构成的集合

2. 指针数组定义方法

   ```c
   数据类型 * 数组名[元素个数];
   int *p[10];// 定义了一个整型的指针数组p,每一个元素都是int*类型的变量
   int a;
   p[1] = &a;
   int b[10];
   p[2] = &b[3];
   //p[2],*(p+2)是等价的
   ```

3. 指针数组的分类

   - 字符指针数组 `char *p[10]`
   - 短整型指针数组 `short int *p[10]`
   - 整型指针数组 `int *p[10]`
   - 长整型指针数组 `long int *p[10]`
   - float型指针数组 `float *p[10]`
   - double型指针数组 `double *p[10]`
   - 结构体指针数组 `struct *AAA[10]`
   - 函数指针数组 `void *p[10](int, int)`

## 指针的指针--二级指针

指针的指针，即指针的地址，定义一个指针变量本身指针变量占用4个字节，指针变量也有地址编号

[![Le1Du8.png](https://s1.ax1x.com/2022/04/12/Le1Du8.png)](https://imgtu.com/i/Le1Du8)

```c
int a,*p;
p = &a;// *p <==> a
int **q;
q = &p; // *q <==> p  **q <==> *p <==> a
int ***m;
m = &q; // *(*(*m)) <==> a
    
```

> 注意：
>
> p q m 都是指针变量，都占用4个字节，都存放地址编号，只不过类型不一样而已







## 字符串和指针

### 字符串的概念

字符串就是以'\0'结尾的若干的字符的集合

### 字符串的存储形式：数组、字符串指针、堆

1. `char string[100]="I love C"`

   定义了一个字符数组string，用来存放多个字符，并且用"I love C"给string 数组初始化，字符串"I love C"存放在string 中

2. `char *str = "I love C"`

   定义了一个指针变量`str`，只能存放字符串地址编号，所以"I love C"这个字符串不能存放在`str`指针变量中。`str`只是存放了字符`I`的地址编号，"I love C"存放在文字常量区

3. `char *str = (char*)malloc(10*sizeof(char));//动态的申请了10个字节的存储空间，首地址赋值给str`

   `strcpy(str,"I love C");//将字符串"I love C"拷贝到str指向的内存空间`

### 字符数组

在内存（栈、静态全局区）中开辟了一段空间并存放字符串

### 字符串指针

在文字常量区开辟了一段空间存放字符串，将字符串的首地址赋值给`str`

### 堆

使用`malloc`函数在堆区申请空间，将字符串拷贝到堆区

> 注意
>
> **可修改性**
>
> 1. 栈很全局区内存中的内容是可以修改的
>
>    ```c
>    char str[100] = "I love c";
>    str[0] = 'y'; //正确 是可以修改的
>    ```
>
> 2. 文字常量区中内容是不可以修改的
>
>    ```c
>    char *str = "I love C";
>    *str = 'y';//错误 不可以修改的，因为‘I’存放在文字常量区
>    ```
>
> 3. 堆区的内容是可以修改的
>
>    ```c
>    char *str = (char*)malloc(10*sizeof(char));
>    strcpy(str, "I love C");
>    *str = 'y';//正确， 可修改的，因为堆区的内容是可以修改的
>    ```
>
> `str`指针指向的内存能不能修改，要看`str`指向哪一个分区
>
> `str`指向文字常量区的时候，内存中的内容是不可以修改的
>
> `str`指向栈、堆、静态全局区的时候，内存的内容是可以修改的

### 初始化

字符数组、指针指向的字符串: 定义时可以直接初始化

```c
char buf_aver[] = "hello world";
char *buf_point = "heloo world";

```

堆中存放的字符串不能初始化，只能使用`strcpy`、`scanf`赋值

```c
char *buf_heap;
buf_heap = (char*)malloc(15*sizeof(char));
strcpy(buf_heap, "hello world");
scanf("%s", buf_heap);
```

### 使用时赋值

字符数组：使用`scanf`或`strcpy`

```c
char buf_aver[] = "hello world";
buf_aver = "hello kitty"; //错误，因为赐福数组的名字是一个常量
strcpy(buf_aver,"hello kitty");//正确
scanf("%s", buff_aver);//正确
```

指向字符串的指针

```c
char *buf_point = "heloo world";
buf_point = "hello kitty"; // 正确 buf_pint指向另一个字符串
strcpy(buf_pint, "hello kitty");//错误 由于buf_point指向的内存空间只能读，所以不能修改buf_piont所指向的内容
```

## 数组指针

1. 二维数组

   二位数组，有行，有列。二维数组可以看成多个一维数组构成的，时多个一维数组的集合，可以认为二维数组的每一个元素都是一个一维数组

   二维数组a中，a+1指向下一个元素，即指向下一个一维数组，即二维数组的下一行。

2. 数组指针的概念：数组指针本身就是一个指针，是一个指向数组的指针，加1跳到下一个数组，即指向下一个数组。

3. 数组指针的定义方法

   ```c
   数据类型 (*数组指针变量名)[指向数组的元素个数];
   int (*p)[5];//定义一个数组指针变量p，p指向的是整型的有5个元素的数组，p+1向下指有5个整型元素的数组，即跳过了一个有5个整型元素的数组
   ```

4. 各种数组指针的定义

   1. 以为数组指针，加1后指向指向下一个一维数组

      ```c
      int (*p)[5];
      配合每行有5个int类型元素的二维数组来用
      int a[3][5];
      int b[4][5];
      int c[5][5];
      p=a;
      p=b;
      p=c;
      都是可以的
      ```

   2. 二维数组指针，加1后指向下一个二维数组

   3. 三位数组指针，加1后指向下一个三位数组

   4. 以此类推

5. 易混淆内容

   - 指针数组：是一个数组，有若干个相同类型的指针构成的集合
   - 数组指针：是一个指针，是一个指向数组的指针，加1跳到下一个数组
   - 指针的指针: 二级指针，本质还是一个指针，不过是存放指针变量地址的指针变量，即指向指针的指针

6. 数组名字取地址 变成 数组指针

   一维数组名字取地址，变成一维数组指针，即加1跳一个一维数组

   ```c
   int a[10];
   // a+1 跳一个整型元素，是a[1]的地址
   // a 和 a+1 相差一个元素， 4个字节
   /********************************/
   // &a 就变成了一个一维数组指针，相当于 int (*p)[10]
   //(&a)+1 和 &a 相差一个有10个整型元素的数组，即40个字节
   ```

7. 数组名和指针变量的区别和相同

   ```c
   int a[10];
   int *p;
   p = a;
   ```

   **相同点**：

   ​	a是数组的名字，是a[0]的地址，p=a即p也保存了a[0]的地址，即a和p都指向a[0]，所以在引用数组元素的时候，a和p等价

   **不同点**：

   1. a是常量、p是变量，可以用等号给p赋值，但不能用等号给a赋值
   2. 对a取地址和对p取地址的结果不同，因为a是数组的名字，所以对a取地址结果为数组指针。p是一个指针变量，所以对p区地址(&p)结果为指针的指针

8. 多维指针中指针的转换

   在二维数组中，行地址取*不是取值的意思，而是指针降级的意思，由行地址（数组指针）变成这一行第0个元素的地址。取`*`前后还是指向同一个地方，但是指针的类型不一样了

**数组指针的作用就是可以保存二维数组的首地址**

### 数组指针的用法

可以将二维数组的首地址传递到另一个函数里面，此时函数的形参就需要定义为数组指针

## 指针和函数的关系

### 函数的传参方式

复制传参，地址传参，全局传参(几乎用不到)

**复制传参：**将实参的值传递给形参，不管形参怎么变，跟实参没有任何关系

**地址传参：**将实参的地址传递给实参，形参对博爱村的地址的内容进行的任何操作，实参的值也会跟着改变

```c
void fun(char* p)
{
    p = "hello world";
}
int mian()
{
    char *p = "hello world";
    fun(p);
    printf("%s\n",p);//打印 hello world
}
```

```c
void fun(char **q)
{
    *q = "hello kitty";
}
int main()
{
    char *p = "hello world";
    fun(&p);
    printf("%s\n", p);//打印 hello kitty
}
```

**总结**：想要改变主调函数中变量的值，必须传递的是变量的地址，而且还得通过`*+地址`去赋值。无论这个变量是什么类型的。

**注意：**如果实参是一个普通变量，地址传参的话就需要形参是一个一级指针；如果实参是一个一级指针，地址传参的话就需要形参是一个二级指针；以此类推。



### 传数组

将数组作为参数传递给函数，不存在复制传参，本质都是传地址，所以在函数内部对数组进行改变，则函数执行完毕后，原本的数组也会改变，因为传递给函数的都是函数的地址。

传一维数组

```c
方法一
    void func(int a[])
方法二（常用）
    void func(int *p)
```

传二维数组

```c
方法一
    void func(int p[][4]);
方法二(通过数组指针)
    void func(int (*p)[4])
```

传指针数组

```c
void func(char **p);
```

**指针函数**：指针作为函数的返回值

一个函数可以返回整型数据、字符数据、浮点型的数据，也可以返回一个指针

指针函数本质就是一个函数，不过是一个返回值类型为指针的函数。

**函数指针**：指针保存函数的地址

定义的函数，在运行程序的时候，会将函数的指令加载到内存的代码段。所以函数也有起始地址。

C语言规定：函数的名字就是函数的首地址，即函数的入口地址

可以定义一个指针变量来存放函数的首地址，这个指针变量就是函数指针变量

函数指针变量的定义方法

`返回值类型 (*函数指针变量名)(形参列表);`

```c
int (*p)(int,int);//定义一个函数指针变量p,p指向的函数必须由一个整型的返回值，有两个整型参数
int max(int x,int y){}
int min(int x, int y){}
//可以用这个p存放这类函数的地址
p=max;
p=min;
```



### 调用函数的方法

1. 通过函数的名字去调用

   ```c
   int max(int x,int y){}
   int main()
   {
       int num;
       num = max(3,5);
   }
   ```

2. 可以通过函数指针变量去调用

   ```c
   int max(int x, int y){}
   int main()
   {
       int num;
       int (*p)(int, int);
       p = max;
       num = p(3,5);
   }
   ```

   

### 函数指针数组

**函数指针数组**：本质是一个数组，数组里面的每一个元素都是一个函数指针

返回值类型  (*函数指针变量名[函数指针的个数])（形参列表）

`int (*p[10])(int, int);`

定义了一个函数指针数组，有10个元素，每个元素都是函数指针变量，指向函数，必须有整型的返回值，两个整型参数



### 函数指针最常用的地方

函数指针最常用的地方在于**将一个函数作为参数传递给另一个函数的时候**要使用函数指针

将函数作为参数传递个另一个函数，将这个函数称为**回调函数**

```c
#include <stdio.h>

int add(int a, int b)
{
    return a+b;
}
int sub(int a, int b)
{
    return a-b;
}
int mux(int a, int b)
{
    return a*b;
}
int dive(int a, int b)
{
    return a/b;
}
int mod(int a, int b)
{
    return a%b;
}
int process(int (*p)(int,int), int a, int b)
{
    return p(a,b);
}

int main(int argc, char *argv[])
{
    int ret;
    int a = 8;
    int b = 3;
    ret = process(add, a, b);
    printf("a+b = %d\n", ret);
    
    ret = process(sub, a, b);
    printf("a-b = %d\n", ret);
    
    ret = process(mux, a, b);
    printf("a*b = %d\n", ret);
    
    ret = process(dive, a, b);
    printf("a/b = %d\n", ret);
    
    ret = process(mod, a, b);
    printf("a%b = %d\n", ret);
    return 0;
}
```



## 经常容易混淆的指针

第一组：

1. `int *a[10]`，这是一个指针数组，素组a中有 10个整型的指针变量

2. `int  (*a)[10]`，这是一个数组指针，他是一个指针变量，它占用4个字节，存放地址编号，它指向一个数组，它加1的话，指向下一个数组

3. `int **p`，这是一个指针的指针，保存的是指针变量的地址

4. 常见用法1

   ```c
   int **p;
   int *q;
   p =&q;
   ```

5. 常见用法2

   ```c
   int **p;
   int *q[10];
   分析：q是指针数组的名字，是指针数组的首地址，是q[0]的首地址，q[0]是一个int*类型的指针。所以q[0]指针变量的地址是int**类型的
   p = &q[0]; // 等价于 p = q;
   ```

**第二组：**

1. `int *f(void);`，*f没有用括号括起来，他是一个函数声明，声明的这个函数返回值为`int *`类型的
2. `int (*f)(void);`，*f用括号括起来了，`*`修饰f说明f是一个指针变量，f是一个函数指针变量，存放函数的地址，它指向的函数，必须有一个int型的返回值，没有参数

## 特殊指针

1. 空类型指针(`void*`)：通用指针，任何类型的指针都可以给`void*`类型的指针变量赋值

   ```c
   函数memset
   void * memset(void *s, int c, size_t n);
   这个函数的功能就是将s指向的内存前n个字节全部赋值为c.
   memset可以设置字符数组、整型数组、浮点型数组的内容，所以第一个参数就必须是一个通用指针变量，它的返回值是s指向的内存的首地址，可以是不同的类型。所以返回值也得是通用指针
       
   ```

   > 注意：void * 类型的指针，它是一个指针变量，在32位系统下，占用四个字节

主要用于函数的参数和返回值

2. NULL 

   空指针：一般NULL 用在 给指针初始化

   

## main函数传参

```c
#include <stdio.h>

int main(int argc, char* argv[])
{
 	int i;
    printf("argc=%d\n",argc);
    for(i = 0; i<argc; i++)
    {
        printf("argv[%d] = %s\n",i,argv[i]);
    }
    
    return 0;
}
argc:是一个int类型的变量，标识命令终端传入的参数的个数
argv:是一个指针数组，用于保存每一个名终端传入的参数
```











