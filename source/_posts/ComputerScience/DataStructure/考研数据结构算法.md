---
title: è€ƒç ”æ•°æ®ç»“æ„ç®—æ³•
date: 2021/12/15 10:30
sticky: true
categories:	
  - è®¡ç®—æœºç§‘å­¦
tag:
  - è€ƒç ”
  - æ•°æ®ç»“æ„
  - å¤ä¹ 
valine: 
  placeholder: "1. æé—®å‰è¯·å…ˆä»”ç»†é˜…è¯»æœ¬æ–‡æ¡£âš¡\n2. é¡µé¢æ˜¾ç¤ºé—®é¢˜ğŸ’¥ï¼Œè¯·æä¾›æ§åˆ¶å°æˆªå›¾ğŸ“¸æˆ–è€…æ‚¨çš„æµ‹è¯•ç½‘å€\n3. å…¶ä»–ä»»ä½•æŠ¥é”™ğŸ’£ï¼Œè¯·æä¾›è¯¦ç»†æè¿°å’Œæˆªå›¾ğŸ“¸ï¼Œç¥é£Ÿç”¨æ„‰å¿«ğŸ’ª"

---



# çº¿æ€§è¡¨

## é“¾è¡¨çš„åŸºæœ¬æ“ä½œ

### å¤´æ’æ³•

```c++
s->next = L->next;
L->next = s;
```

### å°¾æ’æ³•

```c++
p->next =s;
p=p->next;
```

### å¤´æ’æ³•å’Œå°¾æ’æ³•çš„åº”ç”¨

#### åº”ç”¨ä¸€

##### å°¾æ’æ³•åˆ›å»ºé“¾è¡¨

```c++
void createlistR(LNode *&L, int a[], int n)
{
    LNode *p, *s;
    int i;
    L = (LNode*)malloc(sizeof(LNode));
    p=L;
    for(i = 0; i < n; ++i)
    {
        s = (LNode*)malloc(sizeof(LNode));
        s->data = a[i];
        p->next = s;
        p = p->next;
    }
    p->next = NULL;
}
```

##### å¤´æ’æ³•åˆ›å»ºé“¾è¡¨

```c++
void createlistH(LNode *&L, int a[], int n)
{
    LNode *s;
    L = (LNode*)malloc(sizeof(LNode));
    L->next = NULL;
    int i;
    for(i = 0; i < n; ++i)
    {
        s = (LNode*)malloc(sizeof(LNode));
        s->data = a[i];
        s->next = L->next;
        L->next = s;
    }
}

```

#### åº”ç”¨äºŒ

##### ç”¨å°¾æ’æ³•å°†ä¸¤ä¸ªé€’å¢æœ‰åºçš„åˆ—è¡¨åˆå¹¶æˆä¸€ä¸ªé€’å¢æœ‰åºçš„åˆ—è¡¨

###### ä¸ç”¨æ–°å¢å¤´ç»“ç‚¹çš„æƒ…å†µ

```c++
void merge(LNode *&A, LNode *B)
{
    //å®šä¹‰ä¸‰ä¸ªä¸ªæ¸¸æ ‡
    LNode *pa, *pb, *pr,*pre;
    pa = A->next;
    pb = B-->next;
    pre = B;
    pr = NULL;
    free(B);
    while(pa!==NULL&&pb!=NULL)
    {
        if(pa->data<pb->data)
        {
           pre = pre->next;
           pa = pa->next; 
        }else{
            pr=pb;
            pb = pb->next;
            pr->next=pre->next;
            pre->next=pr;
            pre=pa;
            pa = pa->next;
        }
    }
    if(pb !=NULL) pa->next = pb; 
}
```

###### æ–°å¢å¤´ç»“ç‚¹çš„æƒ…å†µ

```c++
void merge(LNode *A, LNode *B, LNode *&C)
{
    LNode *pa,*pb,*pc;
    C = (LNode*)malloc(sizeof(LNode));
    C=NULL;
    pc=C;
    pa = A->next;
    pb = B->next;
    free(A);
    free(B);
    while(pa!=NULL&&pb!=NULL)
    {
        if(pa->data < pb->data)
        {
            pc->next = pa;
            pa = pa->next;
            pc = pc->next;
        }else{
            pc->next = pb;
            pb = pb->next;
            pc = pc->next;
        }
    }
    pc->next=NULL;
    if(pa!=NULL) pc->next = pa;
    if(pb!=NULL) pc->next = pb;
}
```

##### ç”¨å¤´æ’æ³•å°†ä¸¤ä¸ªé€’å¢æœ‰åºçš„åºåˆ—åˆå¹¶æˆé€’å‡æœ‰åºçš„åºåˆ—

```c++
void merge(LNode *A, LNode *B, LNode *&C)
{
    LNode *pa, *pb,*s;
    C = (LNode*)malloc(sizeof(LNode));
    C=NULL;
    pa = A ->next;
    pb = B ->next;
    free(A);
    free(B);
    while(pa!=NULL&&pb!=NULL)
    {
        if(pa->data < pb->data)
        {
            s = pa; 
            pa = pa->next;
            s->next = C->next;
            C->next = s;
        }else{
            s = pb;
            pb = pb->next;
            s ->next = C->next;
            C->next = s;
        }
    }
    while(pa!=NULL)
    {
        s = pa;
        pa = pa->next;
        s->next = C->next;
        C->next = s;
    }
    while(pb!=NULL)
    {
        s = pb;
        pb = pb->next;
        s->next = C->next;
        C->next = s;
    }
}
```

### é¡ºåºè¡¨çš„é€†ç½®

```c++
void reverse(int a[], int left, int right)
{
    for(int i = left, j = right; i<j; ++i,--j)
    {
        int temp = a[i];
        a[i] = a[j];
        a[j] = temp;
    }
}
```

# æ ˆå’Œé˜Ÿåˆ—

## æ ˆ

### æ ˆçš„å‡ ç§çŠ¶æ€

#### æ ˆç©º

##### é¡ºåºæ ˆ

```c++
s.top == -1
```

##### é“¾æ ˆ

```c++
lst->next=NULL;
```

#### æ ˆæ»¡

##### é¡ºåºæ ˆ

```c++
s.top = MaxSize -1;
```

##### é“¾æ ˆ

```c++
ä»é€»è¾‘ä¸Šæ¥è¯´ï¼Œé“¾æ ˆæ²¡æœ‰æ ˆæ»¡çš„æƒ…å†µ
```

#### éæ³•çŠ¶æ€

ä¸Šæº¢ï¼šæ ˆæ»¡ï¼Œç»§ç»­è¿›æ ˆã€‚

ä¸‹æº¢ï¼šæ ˆç©ºï¼Œç»§ç»­å‡ºæ ˆã€‚

### æ ˆçš„ä¸¤ä¸ªæ“ä½œ

#### è¿›æ ˆ

##### é¡ºåºæ ˆ

```c++
s.data[++s.top] = x;
```

##### é“¾æ ˆ

```c++
s->next = lst->next;
lst->next = s;
```

#### å‡ºæ ˆ

##### é¡ºåºæ ˆ

```c++
x = s.data[s.top--];
```

##### é“¾æ ˆ

```c++
p = lst->next;
x = p->data;
lst->next = p->next;
free(p);
```

### å¾ªç¯é˜Ÿåˆ—

#### é¡ºåºé˜Ÿåˆ—çš„å‡æº¢å‡º

æ˜¯æŒ‡é¡ºåºé˜Ÿåˆ—ç»è¿‡ä¸€ç³»åˆ—çš„è¿›é˜Ÿå’Œå‡ºé˜Ÿåï¼Œå¤´å°¾æŒ‡é’ˆéƒ½æŒ‡å‘æ•°ç»„æœ«ç«¯ï¼Œè™½ç„¶é˜Ÿä¸­æ²¡æœ‰å…ƒç´ ï¼Œä½†ä»»ç„¶æ— æ³•è®©å…ƒç´ è¿›é˜Ÿï¼Œè¿™å°±â€œå‡æº¢å‡ºâ€ç°è±¡ã€‚è§£å†³â€œå‡æº¢å‡ºâ€ç°è±¡çš„æ–¹æ³•æ˜¯ï¼Œå°†é¡ºåºé˜Ÿåˆ—æ„é€ æˆç¯çŠ¶ï¼Œè¿™æ ·å¤´å°¾æŒ‡é’ˆå¯ä»¥æ²¿ç€ç¯å¤´ï¼Œè¿™æ ·å°±æ°¸è¿œä¸ä¼šå‡ºç°ä¸¤è€…æ¥åˆ°æ•°ç»„å°½å¤´æ— æ³•ç»§ç»­å¾€ä¸‹èµ°çš„æƒ…å†µï¼Œè¿™å°±æ˜¯å¾ªç¯é˜Ÿåˆ—ã€‚

#### å¾ªç¯é˜Ÿåˆ—çš„ä¸¤ä¸ªçŠ¶æ€

##### é˜Ÿç©ºçŠ¶æ€

```c++
qu.rear == qu.front;
```

##### é˜Ÿæ»¡çŠ¶æ€

```c++
(qu.rear+1)%MaxSize = qu.front;
```

#### å¾ªç¯é˜Ÿåˆ—çš„ä¸¤ç§æ“ä½œ

##### è¿›é˜Ÿ

```c++
qu.rear = (qu.rear+1)%MaxSize; qu.data[qu.rear] = x;
```

##### å‡ºé˜Ÿ

```c++
qu.front = (qu.front+1)%MaxSize; x = qu.data[qu.front];
```

### æŠ½è±¡æ•°æ®ç±»å‹(ADT)

```c++
ADT name
{
    æ•°æ®å¯¹è±¡é›†:
    	å¯¹è±¡1ï¼›å¯¹è±¡2; ... å¯¹è±¡n;
    æ•°æ®å…³ç³»é›†:
    	æ•°æ®å…³ç³»1={<å¯¹è±¡1ï¼Œ å¯¹è±¡2>,<å¯¹è±¡2ï¼Œå¯¹è±¡n>, ..., <å¯¹è±¡n-1, å¯¹è±¡n>}
        æ•°æ®å…³ç³»2={æ ‘ï¼Œ å›¾ï¼Œ çº¿æ€§è¡¨ï¼Œ é›†åˆ}
    æ•°æ®æ“ä½œé›†ï¼š
        æ“ä½œ1;æ“ä½œ2; ... æ“ä½œn;
        
}
```

# æ ‘ã€äºŒå‰æ ‘å’Œæ£®æ—

## æ ‘

## äºŒå‰æ ‘

### äºŒå‰æ ‘çš„éå†

#### é€’å½’ç‰ˆ

##### å…ˆåºéå†

```c++
void preorder(BTNode *p)
{
    visit(p);
    preorder(p->lchild);
    perorder(p->rchild);
}
```

##### ä¸­åºéå†

```c++
void inorder(BTNode *p)
{
    inorder(p->lchild);
    visit(p);
    inorder(p->rchild);
}
```

##### ååºéå†

```c++
void postorder(BTNode *p)
{
    postorder(p->lchild);
    postorder(p->rchild);
    visit(p);
}
```

##### ååºéå†çš„åº”ç”¨

###### è®¡ç®—ç®—æœ¯è¡¨è¾¾å¼çš„å€¼

> **æ€è·¯åˆ†æ**ï¼šå…ˆå°†ç®—æœ¯è¡¨è¿°å­˜å‚¨åˆ°äºŒå‰æ ‘ä¸­ï¼Œç„¶åå…ˆè®¡ç®—å·¦å­æ ‘çš„å€¼ï¼Œå†è®¡ç®—å³å­æ ‘çš„å€¼ï¼Œç„¶åå°†å¾—åˆ°çš„ä¸¤ä¸ªå€¼è®¡ç®—å‡ºæ¥ï¼Œç­‰åˆ°æœ€åçš„å€¼ï¼Œè¿™æ­£å¥½å¯¹åº”å…ˆéå†å·¦å­æ ‘ï¼Œå†éå†å³å­æ ‘ï¼Œæœ€åè®¿é—®æ ¹èŠ‚ç‚¹çš„ååºéå†ã€‚

```c++
int op(char a, char b, char o)
{
    switch(o)
    {
        case '+': return a+b;
        case '-': return a-b;
        case '*': return a*b;
        case '/': return a/b;
    }
}

int comp(BTNode *p)
{
	int A,B;
    if(p!=NULL)
    {
        if(p->lchild!=NULL&&p->lchild!=NULL)
        {
            A=comp(p->lchild);
            B=com(p->rchild);
            return op(A,B,p->data);
        }else return p->data-'0';
    }else return 0;
    
}
```

###### æ±‚ä¸€æ£µäºŒå‰æ ‘çš„æ·±åº¦

>**åˆ†ææ€è·¯ï¼š**æ•´æ£µæ ‘çš„çš„æ·±åº¦D=max{LD,RD}+1ï¼Œæ‰€ä»¥å…ˆæ±‚å‡ºå·¦å­æ ‘çš„æ·±åº¦ï¼Œå†æ±‚å‡ºå³å­æ ‘çš„æ·±åº¦ï¼Œç„¶åæ¯”è¾ƒä¸¤è€…çš„å¤§å°ååŠ 1ï¼Œæœ€åå¾—åˆ°æ•´æ£µæ ‘çš„æ·±åº¦ã€‚æ•´ä¸ªè¿‡ç¨‹æ­£å¥½å¯¹åº”ååºéå†ã€‚

```c++
int getDepth(BTNode *p)
{
    int LD,RD;
    if(p!=NULL)
    {
        LD = getDepth(p->lchild);
        RD = getDepth(p->lchild);
        return ((LD>RD)?LD:RD)+1;
    } 
    return 0;
}
```

##### å±‚åºéå†

```c++
void level(BTNode *p)
{
    BTNode qu[MaxSize];
    int front,rear;
    front=rear=0;
    BTNode* q;
    if(p!=NULL)
    {
        rear=(rear+1)%MaxSize;
        qu[rear] = p;
        Visit(p);
        while(front!=rear)
        {
            front = (front+1)%MaxSize;
            q = qu[front];
            if(q->lchild!=NULL)
            {
                rear = (rear + 1)%MaxSize;
                qu[rear] = q->lchild;
            }
            if(q->rchild!=NULL)
            {
                rear = (rear+1)%MaxSize;
                qu[rear] = q->rchild;
            }
        }
    }
    
}
```

##### å±‚åºéå†çš„åº”ç”¨

###### æ±‚äºŒå‰æ ‘çš„å®½åº¦

```c++
typedef struct{
    BTNode *p;
    int lno;
}St;
int maxNode(BTNode *p)
{
    int front=0,rear=0,Lno=0;
    St que[MaxSize];
    BTNode *q;
    if(p!=NULL)
    {
        ++rear;
        que[rear].p=p;
        que[rear].lno=1;
        while(rear!=front)
        {
            ++front;
            q=que[front].p;
            Lno = que[front].lno;
            if(q->lchild!=NULL)
            {
                ++rear;
                que[rear].p=q->lchild;
                que[rear].lno = Lno+1;
            }
            if(q->rchild!=NULL)
            {
                ++rear;
                que[rear].p = q->rchild;
                que[rear].lno = Lno+1;
            }
        }
        int max = 0;
        for(int i= 1;i <= Lno; ++i)
        {
            int n = 0;
            for(int j=0; j<rear; ++j)
                if(que[j].lno == i) ++n;
            if(n>max)  max=n;
         }
        return max;
    }
    return 0;
}
```

#### éé€’å½’ç‰ˆ

##### å…ˆåºéå†

```c++
void preorderNonRecurision(BTNode *p)
{
    if(p!=NULL)
    {
        BTNode* Stack[MaxSize];
        BTNode* q;
        int top = -1;
        Stack[++top] = p;
        while(top!=-1)
        {
            q = Stack[top--];
            visit(p);
            if(q->rchild) Stack[++top] = q->rchild;
            if(q->lchild) Stack[++top] = q->lchild;
        }
    }
}
```

##### ä¸­åºéå†

```c++
void inorderNonRecurision(BTNode *p)
{
    if(p!=NULL)
    {
        BTNode *stack[MaxSize];
        BTNode *q;
        int top = -1;
        q=p;
        while(top!=-1||q!=NULL)
        {
            while(q!=NULL)
            {
                stack[++top] = q;
                q= q->lchild;
            }
            if(top!=-1)
            {
                q = stack[top--];
                visit(p);
                p = p->rchild;
            }
        }
    }
}
```



##### ååºéå†

> é€†ååºéå†æ˜¯å…ˆåºéå†è¿‡ç¨‹ä¸­å¯¹å·¦å³å­æ ‘éå†é¡ºåºäº¤æ¢æ‰€å¾—çš„ç»“æœã€‚
>
> å› æ­¤ï¼Œé€†ååºéå†ç»è¿‡é€†åºåå°±ç­‰åˆ°äº†ååºéå†ã€‚

```c++
void postorderNonRecurision(BTNode *p)
{
    if(P!=NULL)
    {
        BTNode *s1[MaxSize],*s2[MaxSize];
   		BTNode *q;
    	int top1=-1,top2=-1;
        s1[++top1] = p;
        while(top!=-1)
        {
           q = s1[top1--];
           s2[++top2] = q;
            if(q->lchild) s1[++top1] = q->lchild;
            if(q->rchild) s1[++top1] = q->rchild;
        }
        while(top2!=-1)
        {
            q = s2[top2--];
            visit(q);
        }       
    }  
}
```

#### äºŒå‰æ ‘çº¿ç´¢åŒ–

```c++
typedef TBTNode{
    int data;
    int ltag,rtag;
    TBTNode *lchild, *rchild;
}TBTNode;
```

##### ä¸­åºéå†å¯¹äºŒå‰æ ‘çº¿ç´¢åŒ–

```c++
void InThread(TBTNode *p ,TBTNode* pre)
{
    if(p!=NULL)
    {
        InThread(p->lchild, pre);
        if(p->lchild==NULL)
        {
            p->lchild = pre;
            p->ltag = 1;
        }
        if(pre!=NULL&&pre->rchild==NULL)
        {
            pre->rchild = p;
            pre->rtag = 1;
        }
        pre = p;
        InThread(p->rchild, pre);
    }
}
```

##### é€šè¿‡ä¸­åºéå†å»ºç«‹ä¸­åºçº¿ç´¢äºŒå‰æ ‘

```c++
void createInThread(TBTNode *root)
{
    TBTNode *pre=NULL;
    if(root != NULL)
    {
        InThread(root, pre);
        pre->rchild = NULL;
        pre->rtag = 1;
    }
    
}
```

##### å…ˆåºéå†å¯¹äºŒå‰æ ‘çº¿ç´¢åŒ–

```c++
void PreThread(TBTNode *p, TBTNode *pre)
{
    if(p!=NULL)
    {
        if(p->lchild==NULL)
        {
            p->lchild = pre;
            p->ltag = 1;
        }
        if(pre!=NULL&&pre->lchild==NULL)
        {
            pre->rchild = p;
            p->rtag = 1;
        }
        pre = p;
        PreThread(p->lchild,pre);
        PreThread(p->rchild, pre);
    }
}
```

##### åç»­éå†å¯¹äºŒå‰æ ‘çº¿ç´¢åŒ–

```c++
void PostThread(TBTNode *p, TBTNode *pre)
{
    if(p!=NULL)
    {
        PostThread(p->lchild, pre);
        PostThread(p->rchild, pre);
        if(p->lchild==NULL)
        {
            p->lchild = pre;
            p->ltag = 1;
        }
        if(pre!=NULL&&pre->lchild==NULL)
        {
            pre->rchild = p;
            p->rtag = 1;
        }
        pre = p;
    }
}
```

# å›¾

## å­˜å‚¨ç»“æ„

### é‚»æ¥çŸ©é˜µ

```c++
typedef sturct{
    int adj[MaxSize][MaxSize];
    int n;
    int vex[MaxSize];
}MGraph;
```

### é‚»æ¥è¡¨

```c++
typedef struct ArcNode{
    int adjvex;//è¾¹æ‰€æŒ‡å‘çš„ç»“ç‚¹ä½ç½®
    struct ArcNode* nextarc;//æŒ‡å‘ä¸‹ä¸€æ¡è¾¹çš„æŒ‡é’ˆ
    int infoï¼›
}ArcNode;
typedef struct 
{
    char data;
    ArcNode *firstarc;
}VNode;
typedef struct{
    VNode* adjlist[MaxSize];//é‚»æ¥è¡¨
    int n,e;//å®šç‚¹æ•°å’Œè¾¹æ•°
}AGraph
```

### å›¾çš„éå†æ“ä½œ

#### æ·±åº¦ä¼˜å…ˆéå†

##### ä»¥é‚»æ¥è¡¨ä¸ºå­˜å‚¨ç»“æ„çš„æ·±åº¦ä¼˜å…ˆéå†

```c++
void DFS(AGraph *G, int v0)
{
    int Visited[MaxSize]={0};
    ArcNode *p;
    Visited[v0] = 1;
    Visit(v0);
    p = G->adjlist[v0]->firstrac;//pæŒ‡å‘ç¬¬ä¸€æ¡è¾¹
    while(p!=NULL)
    {
        if(Visited[p->adjvex] == 0)
            DFS(G, p->adjvex);
        p = p->nextarc;
        
    }
}
```

##### ä»¥é‚»æ¥çŸ©é˜µä¸ºå­˜å‚¨ç»“æ„çš„æ·±åº¦ä¼˜å…ˆéå†

```c++
int Visited[MaxSize];
void DFSTraverse(MGraph *G)
{
    for(int v = 0; v< G->n; ++v)
        Visited[v] = 0;
    for(int v = 0; v<G-->n;++v)
        DFS(G,v);
    
}
void DFS(MGraph *G, int v0)
{
    Visited[v0] = 1;
    Visit(v0);
    for(int i = 0; i < n; ++i)
    {
        if(G->edges[v0][i]!=INF&&Visited[i]==0)
            DFS(G, i);
    }
}
```

##### ä»¥é‚»æ¥è¡¨ä¸ºå­˜å‚¨ç»“æ„çš„å¹¿åº¦ä¼˜å…ˆéå†

```c++
void BFS(AGraph *G, int v, int visited[MaxSize])
{
    ArcNode* p;
    int que[MaxSize],front=0,rear=0;
    int j;
    Visit(v);
    visited[v]=1;
    rear = (rear+1)%MaxSize;
    que[rear] = v;
    while(rear!=front)
    {
        front = (front+1)%MaxSize;
        j = que[front];
        p = G->adjlist[j]->firstarc;
        while(p!=NULL)
        {
            if(visited[p->adjvex] == 0)
            {
                Visit(p->adjvex);
                visited[p->adjvex] = 1;
                rear = (rear+1)%MaxSize;
                que[rear] = p->adjvex;
            }
            p = p->nextarc;
        }
    }
}

```



##### prim

```c++
void Prim(MGraph *G, int v0, int &sum)
{
    int vset[maxsize],lowcast[maxisze], v = v0;
    int i, j, k, min;
    for(i = 0; i < G->n; ++i)
    {
        lowcast[i] = G->edges[v0][i];
        vset[i] = 0;
    }
    vset[v0] = 1;
    sum = 0;
    for(i = 0; i < G->n-1; ++i)
    {
        min = INF;
        for(j = 0; j < G->n; ++j)
            if(vset[j]==0&&lowcast[j] < min)
            {
                min = lowcast[j];
                k = j;
            }
        vset[k] = 1;
        v = k;
        sum += min;
        for(j = 0; j < G->n; ++j)
            if(vset[j]==0&&G->edges[v][j]<lowcast[j])
                lowcast[j] = G->edges[v][j];
    }  
}
```

##### kruskal

```c++
typedef struct{
    int a, b;//è¾¹çš„èµ·ç‚¹å’Œç»ˆç‚¹
    int w;//è¾¹çš„æƒå€¼
}Road;
Road road[maxsize];
int v[maxsize];//å®šä¹‰å¹¶æŸ¥é›†
int getRoot(int a)
{
    while(a != v[a]) a = v[a];
    return a;
}
void kruskal(MGraph *G, int &sum, Road road[])
{
    int i;
    int a,b;
    sum = 0;
    for(i = 0; i < G->n; ++i) v[i] = i;
    sort(road, G->e);
    for(i = 0; i < G->e; ++i)
    {
        a = getRoot(road[i].a);
        b = getRoot(road[i].b);
        if(a!=b)
        {
            v[a] = b;
            sum += road[i].
        }
    }
    
}
```

##### dijkstra

```mermaid
graph LR;
a((a))--4-->b((b))
a((a))--6-->d((d))
a((a))--6-->c((c))
b((b))--7-->e((e))
d((d))--5-->f((f))
c((c))--5-->f((f))
f((f))--1-->e((e))
e((e))--6-->g((g))
f((f))--8-->g((g))
```



|      | ç¬¬ä¸€è½®                                                       | ç¬¬äºŒè½®                                                | ç¬¬ä¸‰è½®                                                | ç¬¬å››è½®                                                   | ç¬¬äº”è½®                                                   | ç¬¬å…­è½®                              |
| ---- | ------------------------------------------------------------ | ----------------------------------------------------- | ----------------------------------------------------- | -------------------------------------------------------- | -------------------------------------------------------- | ----------------------------------- |
| b    | <font color = red size=6>4</font><br> <font color=red>a-b</font> |                                                       |                                                       |                                                          |                                                          |                                     |
| c    | <font size =5>6</font><br>a-c                                | <font color=red><font size =5>6</font><br/>a-c</font> |                                                       |                                                          |                                                          |                                     |
| d    | <font size =5>6</font><br>a-d                                | <font size =5>6</font><br/>a-d                        | <font color=red><font size =5>6</font><br/>a-d</font> |                                                          |                                                          |                                     |
| e    | INF<br>a-e                                                   | <font size =5>11</font><br/>a-b-e                     | <font size =5>11</font><br/>a-b-e                     | <font color=red><font size =5>11</font><br/>a-b-e</font> |                                                          |                                     |
| f    | INF<br>a-f                                                   | INF<br/>a-f                                           | <font size =5>11</font><br/>a-c-f                     | <font size =5>11</font><br/>a-c-f                        | <font color=red><font size =5>11</font><br/>a-c-f</font> |                                     |
| g    | INF<br>a-g                                                   | INF<br/>a-g                                           | INF<br/>a-g                                           | INF<br/>a-g                                              | <font size =5>17</font><br/>a-b-e-g                      | <font size =5>17</font><br/>a-b-e-g |
| é›†åˆ | b                                                            | b c                                                   | b c d                                                 | b c d e                                                  | b c d e f                                                | b c d e f g                         |

##### floyd

> 1) è®¾ç½®ä¸¤ä¸ªçŸ©é˜µAå’ŒPathï¼Œåˆå§‹æ—¶å°†å›¾çš„è¿æ¥çŸ©é˜µèµ‹å€¼ç»™Aï¼Œå°†çŸ©é˜µPathä¸­æ‰€æœ‰çš„å…ƒç´ èµ‹å€¼ä¸º-1.
> 2) ä»¥é¡¶ç‚¹kä¸ºä¸­é—´ç‚¹ï¼Œkå–0~n-1å¯¹å›¾ä¸­æ‰€æœ‰é¡¶ç‚¹å¯¹{i,j}è¿›è¡Œå¦‚ä¸‹æ£€æµ‹å’Œä¿®æ”¹ï¼šå¦‚æœ$A[i][j] > A[i][k] + A[k][j]$çš„å€¼ï¼Œå°†$A[i][j] $æ”¹ä¸º$A[i][k] + A[k][j]$çš„å€¼ï¼Œå°†$Path[i][j]$æ”¹ä¸ºk, å¦åˆ™ä»€ä¹ˆéƒ½ä¸åšã€‚

###### æ‰“å°ä»»æ„ä¸¤ç‚¹é—´çš„æœ€çŸ­è·¯å¾„

```c++
void printPath(int u, int v, int path[][maxsize], int A[][maxsize])
{
    if(A[u][v]==INF)
        return;
    else{
        if(path[u][v] == -1)
        {
           cout<<"<"<<u<<","<<v<<">;";
        }else{
            int mid = path[u][v];
            printPath(u, mid, path, A);
            printPath(mid, v, path, A);
        }
    }
}
```

###### floydç®—æ³•çš„å®ç°

```c++
void Floyd(MGraph *G, int Path[][maxsize], int A[][maxsize])
{
    for(int i = 0; i < G->n, ++i)
    	for(int j = 0; j < G->n; ++j)
        {
            Path[i][j] = -1;
            A[i][j] = G->edges[i][j];
        }
    for(int k = 0; k < G->n; ++k)
        for(int i = 0; i < G->n; ++i)
            for(int j = 0; j < G->n; ++j)
                if(A[i][j] > A[i][k] + A[k][j])
                {
                    A[i][j] = A[i][k] + A[k][j];
                    path[i][j] = k;
                }
}
```

##### å®ç°ç”¨é‚»æ¥è¡¨å­˜å‚¨çš„å›¾çš„æ‹“æ‰‘æ’åº

```c++
typedef struct{
    int arcvex;
    struct ArcNode* nextarc;
    int info;
}ArcNode;
typedef struct{
    char data;
    int count;
    ArcNode* firstarc;
}VNode;
typedef struct{
    VNode* adjlist[maxsize];
    int n,e;
}

int TopSort(AGraph *G)
{
    int stack[maxsize],top = -1, n=0;
    ArcNode* p;
    for(int i = 0; i < G->n; ++i)
    {
        if(G->adjlist[i]->count == 0)
            stack[++top] = i;
    }
    while(top != -1)
    {
        int v =stack[top--];
        ++n;
        cout << v<<" ";
        p = G->adjlist[v]->firstarc;
        while(p!=NULL)
        {
            int v1 = ->adjvex;
            --(G->adjlist[v1]->count);
            if(G->adjlist[v1]->count == 0)
                stack[++top] = v1;
            p = p->nextarc;
        }
    }
    if(G->n == n)
        return 1;
    return 0;
}
```

##### å…³é”®è·¯å¾„çš„æ±‚æ³•

> 1. å…ˆæ±‚äº‹ä»¶çš„æœ€æ—©å‘ç”Ÿæ—¶é—´ï¼ˆ$ve(j) =max\{ve(i)+a_k\}$ï¼‰
> 2. å…¶æ¬¡ï¼Œæ±‚å‡ºäº‹ä»¶çš„æœ€æ™šå‘ç”Ÿæ—¶é—´($vl(i) = min\{vl(j)-a_k\}$)
> 3. æœ€åï¼Œæ±‚å‡ºæ´»åŠ¨çš„æœ€æ—©å‘ç”Ÿæ—¶é—´å’Œæœ€æ™šå‘ç”Ÿæ—¶é—´
>    1. æ´»åŠ¨çš„æœ€æ—©å‘ç”Ÿæ—¶é—´ = è¯¥æ´»åŠ¨çš„èµ·å§‹äº‹ä»¶çš„æœ€æ—©å‘ç”Ÿæ—¶é—´ï¼ˆ$e(a_k) = ve(i)$ï¼‰
>    2. æ´»åŠ¨çš„æœ€æ™šå‘ç”Ÿæ—¶é—´ = è¯¥æ´»åŠ¨çš„ç»ˆæ­¢äº‹ä»¶çš„æœ€æ™šå‘ç”Ÿæ—¶é—´ - è¯¥æ´»åŠ¨çš„æŒç»­æ—¶é—´($l(a_k) = vl(j) - a_k$)
>
> **TODO:**åœ¨ï¼ˆ1ï¼‰ä¹‹å‰è¦å¯¹å›¾è¿›è¡Œæ‹“æ‰‘æ’åºï¼Œåœ¨ï¼ˆ3ï¼‰ä¹‹å‰è¦å¯¹å›¾è¿›è¡Œé€†æ‹“æ‰‘æ’åº

# æ’åº

## æ’å…¥ç±»æ’åº

### ç›´æ¥æ’å…¥æ’åºï¼ˆæ—¶é—´å¤æ‚åº¦ä¸å¾…æ’åºåˆ—çš„åˆå§‹åºåˆ—æœ‰å…³ï¼‰

```c++
void InsertSort(int a[], int n)
{
    int tmp=0;
    for(int i = 1; i<n; ++i)
    {
        tmp = a[i];
        j = i-1;
        while(j>=0&&temp<R[j])
        {
            R[j+1] = R[j];
            --j;
        }
        R[j+1] =temp;
    }
}
void InsertSort(int a[], int n)
{
    for(int i=1;i<n;i++)
    {
        int temp=a[i];
        for(int j=i-1;j>=0;--j)
        {
            if(temp<a[j]) a[j+1] = a[j];
        }
        a[j+1] = temp;
    }
}
```

### æŠ˜åŠæ’å…¥æ’åºï¼ˆå…³é”®å­—æ¯”è¾ƒæ¬¡æ•°ä¸åˆå§‹åºåˆ—æ— å…³ï¼‰

```c++
void BinaryInsSort(int a[], int n)
{
    int tmp=0, low=0, high=0, mid=0;
    for(int i = 1; i<n;++i)
    {
        low = 0;
        high = i -1;
        tmp = a[i];
        while(low<=high)
        {
            mid = (low+high)/2;
            if(a[mid] > tmp) high = mid-1;
            else low = mid + 1;
        }
        for(int j = i-1; j>=high+1; --j)
            a[j+1] = a[j];
        a[high+1] = tmp;
    }
    
}
```

### å¸Œå°”æ’åº(ä»…ç”¨äºé¡ºåºå­˜å‚¨ç»“æ„)

```c++
void shell(int a[], int n)
{
    int tmp;
    for(int dk = n/2; dk>=1; dk/=2)
        for(int i = dk; i<n; ++i)
        {
            if(a[i]<a[i-dk])
            {
                a[i] = tmp;
                for(int j = i - dk; j>=0&&tmp<a[j];j-=dk)
                    a[j+dk] = a[j];
                a[j+dk] = tmp;
            }
        }
}
```

## äº¤æ¢ç±»æ’åº

### èµ·æ³¡æ’åº

```c++
void BubbleSort(int a[], int n)
{
    int tmp=0, flag=0;
    for(int i=n-1; i>=1; ++i)
    {
       flag=0;
        for(int j = 1; j<=i; ++j)
            if(a[j-1]>a[j])
            {
                tmp = a[j-1];
                a[j-1] = a[j];
                a[j] = tmp;
                flag = 1;
            }
        if(flag == 1)
            return;    
    }
}
```

### å¿«é€Ÿæ’åº

```c++
void QuickSort(int a[], int low, int high)
{
    int tmp=0;
    int i=low, j=high;
    if(low<high)
    {
        tmp=a[low];
        while(i<j)
        {
            while(i<j&&a[j]>=temp) --j;
            if(i<j)
            {
                a[i] = a[j];
                ++i;
            }
            while(i<j&&a[i]<temp) ++i;
            if(i<j)
            {
                a[j] = a[i];
                --j;
            }
        }
        R[i] = tmp;
        QuickSort(a, low, i-1);
        QuickSort(a, i+1, high);
    }
}
```



## é€‰æ‹©ç±»æ’åº

### ç®€å•é€‰æ‹©æ’åº

```c++
void SelectSort(int a[], int n)
{
    int tmp,k;
    for(int i=0; i<n; ++i)
    {
        k = i;
        for(int j = i+1; j<n; ++j)
            if(a[k]>a[j])
                k = j;
        tmp = a[k];
        a[k] = a[i];
        a[i] = tmp;
    }
                
}
```

### å †æ’åº

åˆå§‹åºåˆ—ï¼š49 38 65 97 76 13 27 49

å»ºå †

```mermaid
graph TD;
a((49))
b((38))
c((65))
d((97))
e((76))
f((13))
g((27))
h((49*))
a---b---d---h
a---c---g
b---e
c---f

```

æ ¹æ®å¤§æ ¹å †çš„å®šä¹‰è°ƒæ•´å †,ä»å †çš„åº•éƒ¨å¼€å§‹è°ƒæ•´

```mermaid
graph TD;
49((49))
38((38))
65((65))
97((97))
76((76))
13((13))
27((27))
49_((49*))
97---49_---38
97---76
65---13
65---27
49---97
49---65


```

```mermaid
graph TD;
49((49))
38((38))
65((65))
97((97))
76((76))
13((13))
27((27))
49_((49*))
97---76
76---49_---38
76---49
65---13
65---27
97---65

```

è°ƒæ•´å®Œæˆåï¼Œç¬¦åˆå¤§æ ¹å †çš„å®šä¹‰ã€‚å¼€å§‹å †æ’åº

å°†97ä»å †ä¸­å–å‡ºï¼Œè°ƒæ•´å †

```mermaid
graph TD;
49((49))
38((38))
65((65))
97((97))
76((76))
13((13))
27((27))
49_((49*))
38---76
38---65
76---49_---97
76---49
65---13
65---27


```

åˆ é™¤97ï¼Œè°ƒæ•´å †

```mermaid
graph TD;
49((49))
38((38))
65((65))
97((97))
76((76))
13((13))
27((27))
49_((49*))

76---49_---38
49_---49
76---65
65---13
65---27
```

ç„¶åä¾æ¬¡ç±»æ¨ï¼Œæœ€åå¾—åˆ°æœ€ç»ˆæ’åº

```mermaid
graph LR;
49_((49))
49((49))
38((38))
65((65))
97((97))
76((76))
13((13))
27((27))
97---76---65---49_---49---38---27---13

```



## å½’å¹¶ç±»æ’åº

```c++
void mergeSort(int a[], int low, int high)
{
    if(low<high)
    {
        int mid = (low+high)/2;
        mergeSort(a, low, mid-1);
        mergeSort(a, mid+1, high);
        merge(A, low, mid, high);
    }
}
```



## åŸºæ•°ç±»æ’åº

## æœ€ä½³å½’å¹¶æ ‘ï¼šmå‰å“ˆå¤«æ›¼æ ‘

## è´¥æ–¹æ ‘

## å†…éƒ¨æ’åºæ€»ç»“

| æ’åºç±»å‹     | æœ€å¥½æ—¶é—´å¤æ‚åº¦ | å¹³å‡æ—¶é—´å¤æ‚åº¦ | æœ€åæ—¶é—´å¤æ‚åº¦ | ç©ºé—´å¤æ‚åº¦ | ç¨³å®šæ€§ |
| ------------ | -------------- | -------------- | -------------- | ---------- | ------ |
| ç›´æ¥æ’å…¥æ’åº | O(n)           | O(n^2)         | O(n^2)         | O(1)       | ç¨³å®š   |
| æŠ˜åŠæ’å…¥æ’åº | O(n^2)         | O(n^2)         | O(n^2)         | O(1)       | ç¨³å®š   |
| å¸Œå°”æ’åº     | O(n^1.5)       | O(n^1.5)       | O(n^1.5)       | O(1)       | ä¸ç¨³å®š |
| èµ·æ³¡æ’åº     | O(n)           | O(n^2)         | O(n^2)         | O(1)       | ç¨³å®š   |
| å¿«é€Ÿæ’åº     | O(nlogn)       | O(nlogn)       | O(n^2)         | O(logn)    | ä¸ç¨³å®š |
| ç®€å•é€‰æ‹©æ’åº | O(n^2)         | O(n^2)         | O(n^2)         | O(1)       | ä¸ç¨³å®š |
| å †æ’åº       | O(nlogn)       | O(nlogn)       | O(nlogn)       | O(1)       | ä¸ç¨³å®š |
| äºŒè·¯å½’å¹¶æ’åº | O(nlogn)       | O(nlogn)       | O(nlogn)       | O(n)       | ç¨³å®š   |
| åŸºæ•°æ’åº     | O(d(n+r_d))    | O(d(n+r_d))    | O(d(n+r_d))    | O(rd)      | ç¨³å®š   |

1. ç»è¿‡ä¸€è¶Ÿæ’åºï¼Œèƒ½å¤Ÿä¿è¯ä¸€ä¸ªå…³é”®å­—è¾¾åˆ°æœ€ç»ˆä½ç½®â€”â€”äº¤æ¢ç±»(èµ·æ³¡æ’åºå’Œå¿«é€Ÿæ’åº)å’Œé€‰æ‹©ç±»æ’åº(ç®€å•é€‰æ‹©æ’åºå’Œå †æ’åº)
2. å…³é”®å­—æ¯”è¾ƒæ¬¡æ•°ä¸åˆå§‹åºåˆ—æ— å…³â€”â€”ç®€å•æ’åºå’ŒæŠ˜åŠæ’å…¥æ’åº
3. æ’åºè¶Ÿæ•°ä¸åŸå§‹åºåˆ—æœ‰å…³â€”â€”äº¤æ¢ç±»æ’åºï¼ˆèµ·æ³¡æ’åºå’Œå¿«é€Ÿæ’åºï¼‰
